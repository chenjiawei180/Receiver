C51 COMPILER V9.00   TIMER                                                                 09/24/2015 16:36:25 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN timer.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\timer.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRINT(.
                    -\timer.lst) TABS(2) OBJECT(timer.obj)

line level    source

   1          #include "timer.h"
   2          #include "key.h"
   3          #include "menu.h"
   4          #include "ev1527.h"
   5          
   6          unsigned char await_number = 0;      //待机时刻计算50MS次数变量
   7          unsigned char await_number_table = 0;//0.5秒标志变量
   8          
   9          unsigned char main_press_time_table = 0;//main计算时间变量跟标志位
  10          unsigned char main_press_time = 0;
  11          
  12          unsigned char again_and_again_time = 0;// 判断重复解码所需要的计算时间变量
  13          
  14          unsigned char logout_cycle_number = 0; //销号 循环 计数变量以及标志位
  15          unsigned char logout_cycle_table = 0;
  16          
  17          unsigned char return_standby_time = 0;//一段时间未操作  返回待机界面
  18          
  19          void Init_Timer0(void)
  20          {
  21   1        TMOD |= 0x01;   //使用模式1，16位定时器，使用"|"符号可以在使用多个定时器时不受影响  
  22   1        TH0 = (65536 - TIMER50MS) >> 8; //重新赋值 5ms
  23   1        TL0 = (65536 - TIMER50MS) & 0xff;
  24   1        EA = 1;            //总中断打开
  25   1        ET0 = 1;           //定时器中断打开
  26   1        TR0 = 1;           //定时器开关打开
  27   1      }
  28          
  29          void Init_Timer1(void) 
  30          {
  31   1        TMOD |= 0x10;   //使用模式1，16位定时器，使用"|"符号可以在使用多个定时器时不受影响  
  32   1        TH1 = (65536 - 100) >> 8; //重新赋值 100us
  33   1        TL1 = (65536 - 100) & 0xff;
  34   1        EA = 1;            //总中断打开
  35   1        ET1 = 1;           //定时器中断打开
  36   1        //TR1=1;           //定时器开关打开
  37   1      }
  38          
  39          void Timer0_isr(void) interrupt 1  //定时器0中断服务程序
  40          {
  41   1        unsigned char func_index_temp = 0;
  42   1        TF0 = 0;
  43   1        TH0 = (65536 - TIMER50MS) >> 8;     //重新赋值 50ms
  44   1        TL0 = (65536 - TIMER50MS) & 0xff;
  45   1        func_index_temp = return_func_index();
  46   1        //if (func_index_temp == MENU_STANDBY || func_index_temp == TWO_MENU_F0_YEAR || func_index_temp == TWO_ME
             -NU_F0_MOUTH 
  47   1        //  || func_index_temp == TWO_MENU_F0_DAY || func_index_temp == TWO_MENU_F0_WEEK || func_index_temp == TWO
             -_MENU_F0_HOUR
  48   1        //  || func_index_temp == TWO_MENU_F0_MINUTE || func_index_temp == TWO_MENU_F1_E1_D1 || func_index_temp ==
             - TWO_MENU_F1_E1_D2
  49   1        //  || func_index_temp == TWO_MENU_F1_E1_D3 || func_index_temp == TWO_MENU_F1_E1_D4 || func_index_temp == 
             -TWO_MENU_F1_E2_D1
  50   1        //  || func_index_temp == TWO_MENU_F1_E2_D2 || func_index_temp == TWO_MENU_F1_E2_D3 || func_index_temp == 
C51 COMPILER V9.00   TIMER                                                                 09/24/2015 16:36:25 PAGE 2   

             -TWO_MENU_F1_E2_D4 
  51   1        //  )
  52   1        if (1)
  53   1        {
  54   2          await_number++;
  55   2          if (await_number == 10)
  56   2          {
  57   3            await_number_table++;
  58   3            await_number = 0;
  59   3          }
  60   2          if (await_number_table >= 4)//确保程序正确延时
  61   2          {
  62   3            await_number_table = 0;
  63   3          }   
  64   2        }
  65   1      
  66   1        if (main_press_time_table == 1) //菜单键按下时间标志
  67   1        {
  68   2          main_press_time++;      //计算菜单键按下时间长度变量
  69   2        }
  70   1      
  71   1        if (return_again_and_again_decoder_table() == 1)
  72   1        {
  73   2          again_and_again_time++;
  74   2          if (again_and_again_time >120)
  75   2          {
  76   3            clear_again_and_again_decoder_table();
  77   3            again_and_again_time = 0;
  78   3          }
  79   2        }
  80   1      
  81   1        if (func_index_temp == DECODER_MENU)
  82   1        {
  83   2          logout_cycle_number++;
  84   2          if (logout_cycle_number == 20)
  85   2          {
  86   3            logout_cycle_table++;
  87   3            logout_cycle_number = 0;
  88   3          }
  89   2      
  90   2        }
  91   1      
  92   1        if (func_index_temp != DECODER_MENU)
  93   1        {
  94   2          return_standby_time++;
  95   2          if (return_standby_time >200)
  96   2          {
  97   3            return_standby_time = 0;
  98   3            set_func_index(MENU_STANDBY);
  99   3          }
 100   2        }
 101   1      }
 102          
 103          void Timer1_isr(void) interrupt 3  //定时器1中断服务程序
 104          {
 105   1        unsigned char func_index_temp = 0;
 106   1        func_index_temp = return_func_index();
 107   1        TF1 = 0;
 108   1        TH1 = (65536 - 100) >> 8;     //重新赋值 100us
 109   1        TL1 = (65536 - 100) & 0xff;
 110   1        if (func_index_temp == TWO_MENU_FA_SET)
 111   1        {
C51 COMPILER V9.00   TIMER                                                                 09/24/2015 16:36:25 PAGE 3   

 112   2          RF_decode_main_sjz_test();
 113   2        }
 114   1        else
 115   1        {
 116   2          RF_decode_main();
 117   2        }
 118   1        
 119   1      }
 120          
 121          unsigned char return_await_number_table(void) //返回await_number_table变量的值
 122          {
 123   1        unsigned char await_number_table_temp=0;
 124   1        await_number_table_temp = await_number_table;
 125   1        return await_number_table_temp;
 126   1      }
 127          
 128          void set_await_number_table(unsigned char temp) //设置await_number_table变量的值
 129          {
 130   1        await_number_table = temp;
 131   1      }
 132          
 133          void set_main_press_time_table(unsigned char temp) //设置main_press_time_table变量的值
 134          {
 135   1        main_press_time_table = temp;
 136   1      }
 137          
 138          unsigned char return_main_press_time(void)
 139          {
 140   1        unsigned char temp = 0;
 141   1        temp = main_press_time;
 142   1        return temp;
 143   1      }
 144          
 145          void clear_main_press_time(void)
 146          {
 147   1        main_press_time = 0;
 148   1      }
 149          
 150          unsigned char return_logout_cycle_table(void)
 151          {
 152   1        unsigned char temp = 0;
 153   1        temp = logout_cycle_table;
 154   1        return temp;
 155   1      }
 156          
 157          void set_logout_cycle_table(unsigned char temp) //设置logout_cycle_table变量的值
 158          {
 159   1        logout_cycle_table = temp;
 160   1      }
 161          
 162          void clear_return_standby_time(void)
 163          {
 164   1        return_standby_time = 0;
 165   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    357    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      8       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.00   TIMER                                                                 09/24/2015 16:36:25 PAGE 4   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
