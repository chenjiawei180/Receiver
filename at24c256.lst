C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE AT24C256
OBJECT MODULE PLACED IN at24c256.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\at24c256.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRIN
                    -T(.\at24c256.lst) OBJECT(at24c256.obj)

line level    source

   1          #include "at24c256.h"
   2          #include "key.h"
   3          #include "usart.h"
   4          
   5          bit ack;                      //Ó¦´ð±êÖ¾Î»
   6          unsigned char xdata at24c64_buff[PAGE_LENGTH] = { 0 }; //24C256Ò³Ãæ´æ´¢»º´æ
   7          unsigned char xdata eeprom_buff[8] = { 0 };                        //×¢²áÊý×é»º´æ
   8          
   9          void DelayUs2x(unsigned char t)
  10          {
  11   1              while (--t);
  12   1      }
  13          /*------------------------------------------------
  14          mSÑÓÊ±º¯Êý£¬º¬ÓÐÊäÈë²ÎÊý unsigned char t£¬ÎÞ·µ»ØÖµ
  15          unsigned char ÊÇ¶¨ÒåÎÞ·ûºÅ×Ö·û±äÁ¿£¬ÆäÖµµÄ·¶Î§ÊÇ
  16          0~255 ÕâÀïÊ¹ÓÃ¾§Õñ12M£¬¾«È·ÑÓÊ±ÇëÊ¹ÓÃ»ã±à
  17          ------------------------------------------------*/
  18          void DelayMs(unsigned char t)
  19          {
  20   1              while (t--)
  21   1              {
  22   2                      //´óÖÂÑÓÊ±1mS
  23   2                      DelayUs2x(245);
  24   2                      DelayUs2x(245);
  25   2              }
  26   1      }
  27          
  28          
  29          /*------------------------------------------------
  30          Æô¶¯×ÜÏß
  31          ------------------------------------------------*/
  32          void Start_I2c()
  33          {
  34   1              SDA = 1;   //·¢ËÍÆðÊ¼Ìõ¼þµÄÊý¾ÝÐÅºÅ
  35   1              _Nop();
  36   1              SCL = 1;
  37   1              _Nop();    //ÆðÊ¼Ìõ¼þ½¨Á¢Ê±¼ä´óÓÚ4.7us,ÑÓÊ±
  38   1              _Nop();
  39   1              _Nop();
  40   1              _Nop();
  41   1              _Nop();
  42   1              SDA = 0;     //·¢ËÍÆðÊ¼ÐÅºÅ
  43   1              _Nop();    //ÆðÊ¼Ìõ¼þËø¶¨Ê±¼ä´óÓÚ4¦Ì
  44   1              _Nop();
  45   1              _Nop();
  46   1              _Nop();
  47   1              _Nop();
  48   1              SCL = 0;    //Ç¯×¡I2C×ÜÏß£¬×¼±¸·¢ËÍ»ò½ÓÊÕÊý¾Ý
  49   1              _Nop();
  50   1              _Nop();
  51   1      }
  52          /*------------------------------------------------
  53          ½áÊø×ÜÏß
  54          ------------------------------------------------*/
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 2   

  55          void Stop_I2c()
  56          {
  57   1              SDA = 0;    //·¢ËÍ½áÊøÌõ¼þµÄÊý¾ÝÐÅºÅ
  58   1              _Nop();   //·¢ËÍ½áÊøÌõ¼þµÄÊ±ÖÓÐÅºÅ
  59   1              SCL = 1;    //½áÊøÌõ¼þ½¨Á¢Ê±¼ä´óÓÚ4¦Ì
  60   1              _Nop();
  61   1              _Nop();
  62   1              _Nop();
  63   1              _Nop();
  64   1              _Nop();
  65   1              SDA = 1;    //·¢ËÍI2C×ÜÏß½áÊøÐÅºÅ
  66   1              _Nop();
  67   1              _Nop();
  68   1              _Nop();
  69   1              _Nop();
  70   1      }
  71          
  72          /*----------------------------------------------------------------
  73          ×Ö½ÚÊý¾Ý´«ËÍº¯Êý
  74          º¯ÊýÔ­ÐÍ: void  SendByte(unsigned char c);
  75          ¹¦ÄÜ:  ½«Êý¾Ýc·¢ËÍ³öÈ¥,¿ÉÒÔÊÇµØÖ·,Ò²¿ÉÒÔÊÇÊý¾Ý,·¢ÍêºóµÈ´ýÓ¦´ð,²¢¶Ô
  76          ´Ë×´Ì¬Î»½øÐÐ²Ù×÷.(²»Ó¦´ð»ò·ÇÓ¦´ð¶¼Ê¹ack=0 ¼Ù)
  77          ·¢ËÍÊý¾ÝÕý³££¬ack=1; ack=0±íÊ¾±»¿ØÆ÷ÎÞÓ¦´ð»òËð»µ¡£
  78          ------------------------------------------------------------------*/
  79          void  SendByte(unsigned char c)
  80          {
  81   1              unsigned char BitCnt;
  82   1              for (BitCnt = 0; BitCnt<8; BitCnt++)  //Òª´«ËÍµÄÊý¾Ý³¤¶ÈÎª8Î»
  83   1              {
  84   2                      if ((c << BitCnt) & 0x80)
  85   2                              SDA = 1;   //ÅÐ¶Ï·¢ËÍÎ»
  86   2                      else
  87   2                              SDA = 0;
  88   2                      _Nop();
  89   2                      SCL = 1;               //ÖÃÊ±ÖÓÏßÎª¸ß£¬Í¨Öª±»¿ØÆ÷¿ªÊ¼½ÓÊÕÊý¾ÝÎ»
  90   2                      _Nop();
  91   2                      _Nop();             //±£Ö¤Ê±ÖÓ¸ßµçÆ½ÖÜÆÚ´óÓÚ4¦Ì
  92   2                      _Nop();
  93   2                      _Nop();
  94   2                      _Nop();
  95   2                      SCL = 0;
  96   2              }
  97   1              _Nop();
  98   1              _Nop();
  99   1              SDA = 1;               //8Î»·¢ËÍÍêºóÊÍ·ÅÊý¾ÝÏß£¬×¼±¸½ÓÊÕÓ¦´ðÎ»
 100   1              _Nop();
 101   1              _Nop();
 102   1              SCL = 1;
 103   1              _Nop();
 104   1              _Nop();
 105   1              _Nop();
 106   1              if (SDA == 1)ack = 0;
 107   1              else ack = 1;        //ÅÐ¶ÏÊÇ·ñ½ÓÊÕµ½Ó¦´ðÐÅºÅ
 108   1              SCL = 0;
 109   1              _Nop();
 110   1              _Nop();
 111   1      }
 112          
 113          /*----------------------------------------------------------------
 114          ×Ö½ÚÊý¾Ý´«ËÍº¯Êý
 115          º¯ÊýÔ­ÐÍ: unsigned char  RcvByte();
 116          ¹¦ÄÜ:  ÓÃÀ´½ÓÊÕ´ÓÆ÷¼þ´«À´µÄÊý¾Ý,²¢ÅÐ¶Ï×ÜÏß´íÎó(²»·¢Ó¦´ðÐÅºÅ)£¬
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 3   

 117          ·¢ÍêºóÇëÓÃÓ¦´ðº¯Êý¡£
 118          ------------------------------------------------------------------*/
 119          unsigned char  RcvByte()
 120          {
 121   1              unsigned char retc;
 122   1              unsigned char BitCnt;
 123   1              retc = 0;
 124   1              SDA = 1;             //ÖÃÊý¾ÝÏßÎªÊäÈë·½Ê½
 125   1              for (BitCnt = 0; BitCnt<8; BitCnt++)
 126   1              {
 127   2                      _Nop();
 128   2                      SCL = 0;       //ÖÃÊ±ÖÓÏßÎªµÍ£¬×¼±¸½ÓÊÕÊý¾ÝÎ»
 129   2                      _Nop();
 130   2                      _Nop();      //Ê±ÖÓµÍµçÆ½ÖÜÆÚ´óÓÚ4.7us
 131   2                      _Nop();
 132   2                      _Nop();
 133   2                      _Nop();
 134   2                      SCL = 1;       //ÖÃÊ±ÖÓÏßÎª¸ßÊ¹Êý¾ÝÏßÉÏÊý¾ÝÓÐÐ§
 135   2                      _Nop();
 136   2                      _Nop();
 137   2                      retc = retc << 1;
 138   2                      if (SDA == 1)retc = retc + 1; //¶ÁÊý¾ÝÎ»,½ÓÊÕµÄÊý¾ÝÎ»·ÅÈëretcÖÐ
 139   2                      _Nop();
 140   2                      _Nop();
 141   2              }
 142   1              SCL = 0;
 143   1              _Nop();
 144   1              _Nop();
 145   1              return(retc);
 146   1      }
 147          
 148          
 149          /*----------------------------------------------------------------
 150          Ó¦´ð×Óº¯Êý
 151          Ô­ÐÍ:  void Ack_I2c(void);
 152          
 153          ----------------------------------------------------------------*/
 154          void Ack_I2c(void)
 155          {
 156   1              SDA = 0;
 157   1              _Nop();
 158   1              _Nop();
 159   1              _Nop();
 160   1              SCL = 1;
 161   1              _Nop();
 162   1              _Nop();              //Ê±ÖÓµÍµçÆ½ÖÜÆÚ´óÓÚ4¦Ì
 163   1              _Nop();
 164   1              _Nop();
 165   1              _Nop();
 166   1              SCL = 0;               //ÇåÊ±ÖÓÏß£¬Ç¯×¡I2C×ÜÏßÒÔ±ã¼ÌÐø½ÓÊÕ
 167   1              _Nop();
 168   1              _Nop();
 169   1      }
 170          
 171          /*----------------------------------------------------------------
 172          ·ÇÓ¦´ð×Óº¯Êý
 173          Ô­ÐÍ:  void NoAck_I2c(void);
 174          
 175          ----------------------------------------------------------------*/
 176          void NoAck_I2c(void)
 177          {
 178   1              SDA = 1;
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 4   

 179   1              _Nop();
 180   1              _Nop();
 181   1              _Nop();
 182   1              SCL = 1;
 183   1              _Nop();
 184   1              _Nop();              //Ê±ÖÓµÍµçÆ½ÖÜÆÚ´óÓÚ4¦Ì
 185   1              _Nop();
 186   1              _Nop();
 187   1              _Nop();
 188   1              SCL = 0;                //ÇåÊ±ÖÓÏß£¬Ç¯×¡I2C×ÜÏßÒÔ±ã¼ÌÐø½ÓÊÕ
 189   1              _Nop();
 190   1              _Nop();
 191   1      }
 192          
 193          /*----------------------------------------------------------------
 194          ÏòÓÐ×ÓµØÖ·Æ÷¼þ·¢ËÍ¶à×Ö½ÚÊý¾Ýº¯Êý
 195          º¯ÊýÔ­ÐÍ: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 196          ¹¦ÄÜ:     ´ÓÆô¶¯×ÜÏßµ½·¢ËÍµØÖ·£¬×ÓµØÖ·,Êý¾Ý£¬½áÊø×ÜÏßµÄÈ«¹ý³Ì,´ÓÆ÷¼þ
 197          µØÖ·sla£¬×ÓµØÖ·suba£¬·¢ËÍÄÚÈÝÊÇsÖ¸ÏòµÄÄÚÈÝ£¬·¢ËÍno¸ö×Ö½Ú¡£
 198          Èç¹û·µ»Ø1±íÊ¾²Ù×÷³É¹¦£¬·ñÔò²Ù×÷ÓÐÎó¡£
 199          ×¢Òâ£º    Ê¹ÓÃÇ°±ØÐëÒÑ½áÊø×ÜÏß¡£
 200          ----------------------------------------------------------------*/
 201          bit ISendStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 202          {
 203   1              unsigned char i;
 204   1              Start_I2c();               //Æô¶¯×ÜÏß
 205   1              SendByte(sla);             //·¢ËÍÆ÷¼þµØÖ·
 206   1              if (ack == 0)return(0);
 207   1              SendByte(suba >> 8);            //·¢ËÍÆ÷¼þ×ÓµØÖ·
 208   1              if (ack == 0)return(0);
 209   1              SendByte(suba);
 210   1              if (ack == 0)return(0);
 211   1              for (i = 0; i<no; i++)
 212   1              {
 213   2                      SendByte(*s);            //·¢ËÍÊý¾Ý
 214   2                      if (ack == 0)return(0);
 215   2                      s++;
 216   2              }
 217   1              Stop_I2c();                  //½áÊø×ÜÏß
 218   1              return(1);
 219   1      }
 220          
 221          
 222          /*----------------------------------------------------------------
 223          ÏòÓÐ×ÓµØÖ·Æ÷¼þ¶ÁÈ¡¶à×Ö½ÚÊý¾Ýº¯Êý
 224          º¯ÊýÔ­ÐÍ: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 225          ¹¦ÄÜ:     ´ÓÆô¶¯×ÜÏßµ½·¢ËÍµØÖ·£¬×ÓµØÖ·,¶ÁÊý¾Ý£¬½áÊø×ÜÏßµÄÈ«¹ý³Ì,´ÓÆ÷¼þ
 226          µØÖ·sla£¬×ÓµØÖ·suba£¬¶Á³öµÄÄÚÈÝ·ÅÈësÖ¸ÏòµÄ´æ´¢Çø£¬¶Áno¸ö×Ö½Ú¡£
 227          Èç¹û·µ»Ø1±íÊ¾²Ù×÷³É¹¦£¬·ñÔò²Ù×÷ÓÐÎó¡£
 228          ×¢Òâ£º    Ê¹ÓÃÇ°±ØÐëÒÑ½áÊø×ÜÏß¡£
 229          ----------------------------------------------------------------*/
 230          bit IRcvStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 231          {
 232   1              unsigned char i;
 233   1              Start_I2c();               //Æô¶¯×ÜÏß
 234   1              SendByte(sla);             //·¢ËÍÆ÷¼þµØÖ·
 235   1              if (ack == 0)return(0);
 236   1              SendByte(suba >> 8);            //·¢ËÍÆ÷¼þ×ÓµØÖ·
 237   1              if (ack == 0)return(0);
 238   1              SendByte(suba);            //·¢ËÍÆ÷¼þ×ÓµØÖ·
 239   1              if (ack == 0)return(0);
 240   1              Start_I2c();
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 5   

 241   1              SendByte(sla + 1);
 242   1              if (ack == 0)return(0);
 243   1              for (i = 0; i<no - 1; i++)
 244   1              {
 245   2                      *s = RcvByte();              //·¢ËÍÊý¾Ý
 246   2                      Ack_I2c();                //·¢ËÍ¾Í´ðÎ» 
 247   2                      s++;
 248   2              }
 249   1              *s = RcvByte();
 250   1              NoAck_I2c();                 //·¢ËÍ·ÇÓ¦Î»
 251   1              Stop_I2c();                    //½áÊø×ÜÏß
 252   1              return(1);
 253   1      }
 254          
 255          bit register_call_function(unsigned char *buf)
 256          {
 257   1                      unsigned char base_address = 0;//»ù×¼µØÖ·   
 258   1                      unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 259   1                      //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 260   1                      /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 261   1                      for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)    //32*32 =1024¸ö±êÖ¾
             -Î»
 262   1                      {
 263   2                              IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½Úµ
             -Ä±êÖ¾Î»
 264   2                              delay10ms();
 265   2                              for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾Í
             -OK
 266   2                              {
 267   3                                      if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 268   3                                      {
 269   4                                              IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff
             -, 8);
 270   4                                              delay10ms();
 271   4      
 272   4                                              if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) =
             -= *(buf + 7)))
 273   4                                              {
 274   5                                                      //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 275   5                                                      Two_Menu_F1_E1[0] = *(eeprom_buff + 1);
 276   5                                                      Two_Menu_F1_E1[1] = *(eeprom_buff + 2);
 277   5                                                      Two_Menu_F1_E1[2] = *(eeprom_buff + 3);
 278   5                                                      Two_Menu_F1_E1[3] = *(eeprom_buff + 4);
 279   5      #ifdef DEBUG
 280   5                                                      uart_printf("caller register is old! \n\r"); 
 281   5      #endif
 282   5      
 283   5      //                                              if (sound_table == 1)
 284   5      //                                              {
 285   5      //#if SOUND
 286   5      //                                                      GD5800_select_chapter(SETERROR_POSITION);
 287   5      //#endif
 288   5      //                                                      sound_table = 0;
 289   5      //                                              }
 290   5                                                      return 0;
 291   5                                              }
 292   4                                      }
 293   3                              }
 294   2                      }
 295   1                      //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 296   1                      for (base_address = 0; base_address<CALL_TABLE_NUMBER; base_address++)
 297   1                      {
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 6   

 298   2                              IRcvStr(I2C_ADDRESS, CALL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C6
             -4ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±êÖ¾Î»
 299   2                              delay10ms();
 300   2                              for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾Í
             -OK
 301   2                              {
 302   3                                      if (at24c64_buff[offset_address] != 0)
 303   3                                      {
 304   4                                              ISendStr(I2C_ADDRESS, (CALL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8);
 305   4                                              delay10ms();
 306   4                                              at24c64_buff[offset_address] = 0;
 307   4                                              ISendStr(I2C_ADDRESS, CALL_TABLE_START+base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 308   4                                              delay10ms();
 309   4                                              //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 310   4      #ifdef DEBUG
 311   4                                              uart_printf("caller register is new! \n\r");
 312   4                                              uart_printf("±êÖ¾µØÖ·Îª %x ! \n\r", (unsigned int)(CALL_TABLE_START + base_address*PAGE_LENGTH) );
 313   4                                              uart_printf("´æ´¢µØÖ·Îª %x ! \n\r", CALL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) *
             - 8);
 314   4      #endif
 315   4      //                                      if (sound_table == 1)
 316   4      //                                      {
 317   4      //#if SOUND
 318   4      //                                              GD5800_select_chapter(SETSUCCESS_POSITION);
 319   4      //#endif
 320   4      //                                              sound_table = 0;
 321   4      //                                      }
 322   4                                              return 1;
 323   4                                              //ÌáÊ¾³É¹¦                              
 324   4                                      }
 325   3                              }
 326   2                      }
 327   1                      return 0;
 328   1      }
 329          
 330          bit register_host_function(unsigned char *buf)
 331          {
 332   1              unsigned char base_address = 0;//»ù×¼µØÖ·   
 333   1              unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 334   1              //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 335   1              /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 336   1              for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)    //32*32 =1024¸ö±êÖ¾Î
             -»
 337   1              {
 338   2                      IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
 339   2                      delay10ms();
 340   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 341   2                      {
 342   3                              if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 343   3                              {
 344   4                                      IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);
 345   4                                      delay10ms();
 346   4      
 347   4                                      if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) ==
             - *(buf + 7)))
 348   4                                      {
 349   5                                              //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 350   5                                              Two_Menu_F1_E2[0] = *(eeprom_buff + 1);
 351   5                                              Two_Menu_F1_E2[1] = *(eeprom_buff + 2);
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 7   

 352   5                                              Two_Menu_F1_E2[2] = *(eeprom_buff + 3);
 353   5                                              Two_Menu_F1_E2[3] = *(eeprom_buff + 4);
 354   5      #ifdef DEBUG
 355   5                                              uart_printf("host register is old! \n\r");
 356   5      #endif
 357   5      
 358   5                                              //                                              if (sound_table == 1)
 359   5                                              //                                              {
 360   5                                              //#if SOUND
 361   5                                              //                                                      GD5800_select_chapter(SETERROR_POSITION);
 362   5                                              //#endif
 363   5                                              //                                                      sound_table = 0;
 364   5                                              //                                              }
 365   5                                              return 0;
 366   5                                      }
 367   4                              }
 368   3                      }
 369   2              }
 370   1              //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 371   1              for (base_address = 0; base_address<HOST_TABLE_NUMBER; base_address++)
 372   1              {
 373   2                      IRcvStr(I2C_ADDRESS, HOST_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C64
             -ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±êÖ¾Î»
 374   2                      delay10ms();
 375   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 376   2                      {
 377   3                              if (at24c64_buff[offset_address] != 0)
 378   3                              {
 379   4                                      ISendStr(I2C_ADDRESS, (HOST_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8);
 380   4                                      delay10ms();
 381   4                                      at24c64_buff[offset_address] = 0;
 382   4                                      ISendStr(I2C_ADDRESS,HOST_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 383   4                                      delay10ms();
 384   4                                      //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 385   4      #ifdef DEBUG
 386   4                                      uart_printf("host register is new! \n\r");
 387   4      #endif
 388   4                                      //                                      if (sound_table == 1)
 389   4                                      //                                      {
 390   4                                      //#if SOUND
 391   4                                      //                                              GD5800_select_chapter(SETSUCCESS_POSITION);
 392   4                                      //#endif
 393   4                                      //                                              sound_table = 0;
 394   4                                      //                                      }
 395   4                                      return 1;
 396   4                                      //ÌáÊ¾³É¹¦                              
 397   4                              }
 398   3                      }
 399   2              }
 400   1              return 0;
 401   1      }
 402          
 403          bit register_alarm_function(unsigned char *buf)
 404          {
 405   1              unsigned char base_address = 0;//»ù×¼µØÖ·   
 406   1              unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 407   1              //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 408   1              /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 409   1              for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)    //32*32 =1024¸ö±êÖ¾Î
             -»
 410   1              {
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 8   

 411   2                      IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
 412   2                      delay10ms();
 413   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 414   2                      {
 415   3                              if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 416   3                              {
 417   4                                      IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);
 418   4                                      delay10ms();
 419   4      
 420   4                                      if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) ==
             - *(buf + 7)))
 421   4                                      {
 422   5                                              //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 423   5                                              Two_Menu_F1_E3[0] = *(eeprom_buff + 1);
 424   5                                              Two_Menu_F1_E3[1] = *(eeprom_buff + 2);
 425   5                                              Two_Menu_F1_E3[2] = *(eeprom_buff + 3);
 426   5                                              Two_Menu_F1_E3[3] = *(eeprom_buff + 4);
 427   5      #ifdef DEBUG
 428   5                                              uart_printf("alarmer register is old! \n\r");
 429   5      #endif
 430   5      
 431   5                                              //                                              if (sound_table == 1)
 432   5                                              //                                              {
 433   5                                              //#if SOUND
 434   5                                              //                                                      GD5800_select_chapter(SETERROR_POSITION);
 435   5                                              //#endif
 436   5                                              //                                                      sound_table = 0;
 437   5                                              //                                              }
 438   5                                              return 0;
 439   5                                      }
 440   4                              }
 441   3                      }
 442   2              }
 443   1              //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 444   1              for (base_address = 0; base_address<ALARM_TABLE_NUMBER; base_address++)
 445   1              {
 446   2                      IRcvStr(I2C_ADDRESS, ALARM_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C6
             -4ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±êÖ¾Î»
 447   2                      delay10ms();
 448   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 449   2                      {
 450   3                              if (at24c64_buff[offset_address] != 0)
 451   3                              {
 452   4                                      ISendStr(I2C_ADDRESS, (ALARM_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8);
 453   4                                      delay10ms();
 454   4                                      at24c64_buff[offset_address] = 0;
 455   4                                      ISendStr(I2C_ADDRESS,ALARM_TABLE_START+base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 456   4                                      delay10ms();
 457   4                                      //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 458   4      #ifdef DEBUG
 459   4                                      uart_printf("alarmer register is new! \n\r");
 460   4                                      uart_printf("±êÖ¾µØÖ·Îª %x ! \n\r", ALARM_TABLE_START + base_address*PAGE_LENGTH);
 461   4                                      uart_printf("´æ´¢µØÖ·Îª %x ! \n\r", ALARM_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) *
             - 8);
 462   4      #endif
 463   4                                      //                                      if (sound_table == 1)
 464   4                                      //                                      {
 465   4                                      //#if SOUND
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 9   

 466   4                                      //                                              GD5800_select_chapter(SETSUCCESS_POSITION);
 467   4                                      //#endif
 468   4                                      //                                              sound_table = 0;
 469   4                                      //                                      }
 470   4                                      return 1;
 471   4                                      //ÌáÊ¾³É¹¦                              
 472   4                              }
 473   3                      }
 474   2              }
 475   1              return 0;
 476   1      }
 477          
 478          bit register_cancel_function(unsigned char *buf)
 479          {
 480   1              unsigned char base_address = 0;//»ù×¼µØÖ·   
 481   1              unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 482   1              //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 483   1              /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 484   1              for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)    //32*32 =1024¸ö±êÖ¾Î
             -»
 485   1              {
 486   2                      IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
 487   2                      delay10ms();
 488   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 489   2                      {
 490   3                              if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 491   3                              {
 492   4                                      IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);
 493   4                                      delay10ms();
 494   4      
 495   4                                      if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) ==
             - *(buf + 7)))
 496   4                                      {
 497   5                                              //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 498   5                                              Two_Menu_F1_E4[0] = *(eeprom_buff + 1);
 499   5                                              Two_Menu_F1_E4[1] = *(eeprom_buff + 2);
 500   5                                              Two_Menu_F1_E4[2] = *(eeprom_buff + 3);
 501   5                                              Two_Menu_F1_E4[3] = *(eeprom_buff + 4);
 502   5      #ifdef DEBUG
 503   5                                              uart_printf("canceler register is old! \n\r");
 504   5      #endif
 505   5      
 506   5                                              //                                              if (sound_table == 1)
 507   5                                              //                                              {
 508   5                                              //#if SOUND
 509   5                                              //                                                      GD5800_select_chapter(SETERROR_POSITION);
 510   5                                              //#endif
 511   5                                              //                                                      sound_table = 0;
 512   5                                              //                                              }
 513   5                                              return 0;
 514   5                                      }
 515   4                              }
 516   3                      }
 517   2              }
 518   1              //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 519   1              for (base_address = 0; base_address<CANCEL_TABLE_NUMBER; base_address++)
 520   1              {
 521   2                      IRcvStr(I2C_ADDRESS, CANCEL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C
             -64ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±êÖ¾Î»
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 10  

 522   2                      delay10ms();
 523   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 524   2                      {
 525   3                              if (at24c64_buff[offset_address] != 0)
 526   3                              {
 527   4                                      ISendStr(I2C_ADDRESS, (CANCEL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8)
             -;
 528   4                                      delay10ms();
 529   4                                      at24c64_buff[offset_address] = 0;
 530   4                                      ISendStr(I2C_ADDRESS,CANCEL_TABLE_START+base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 531   4                                      delay10ms();
 532   4                                      //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 533   4      #ifdef DEBUG
 534   4                                      uart_printf("canceler register is new! \n\r");
 535   4                                      uart_printf("±êÖ¾µØÖ·Îª %x ! \n\r", CANCEL_TABLE_START + base_address*PAGE_LENGTH);
 536   4                                      uart_printf("´æ´¢µØÖ·Îª %x ! \n\r", CANCEL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) 
             -* 8);
 537   4      #endif
 538   4                                      //                                      if (sound_table == 1)
 539   4                                      //                                      {
 540   4                                      //#if SOUND
 541   4                                      //                                              GD5800_select_chapter(SETSUCCESS_POSITION);
 542   4                                      //#endif
 543   4                                      //                                              sound_table = 0;
 544   4                                      //                                      }
 545   4                                      return 1;
 546   4                                      //ÌáÊ¾³É¹¦                              
 547   4                              }
 548   3                      }
 549   2              }
 550   1              return 0;
 551   1      }
 552          
 553          bit delete_call_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 554          {
 555   1              unsigned char base_address = 0;
 556   1              unsigned char offset_address = 0;
 557   1      
 558   1              for (base_address = 0; base_address<CALL_TABLE_NUMBER; base_address++)
 559   1              {
 560   2                      IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸ö±êÖ¾Î»
 561   2                      delay10ms();
 562   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 563   2                      {
 564   3                              if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 565   3                              {
 566   4                                      at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 567   4      #ifdef DEBUG
 568   4                                      uart_printf("caller is delete success \r\n");
 569   4      #endif          
 570   4                              }
 571   3                              else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 572   3                              {
 573   4                                      IRcvStr(I2C_ADDRESS, ( CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff
             -, 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 574   4                                      delay10ms();
 575   4                                      if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 576   4                                      {
 577   5                                              at24c64_buff[offset_address] = 0xff;
 578   5                                              ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 11  

 579   5                                              delay10ms();
 580   5                                              //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 581   5      #ifdef DEBUG
 582   5                                              uart_printf("call is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(eepr
             -om_buff + 6)), (unsigned int)(*(eeprom_buff + 7)) ); //
 583   5                                              uart_printf("call is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(*(
             -eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)) );
 584   5                                              uart_printf("caller is delete success \r\n");
 585   5      #endif          
 586   5                                      }
 587   4      
 588   4                              }
 589   3                      }
 590   2                      ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 591   2                      //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 592   2                      delay10ms();
 593   2              }
 594   1              return 1;
 595   1      }
 596          
 597          bit delete_host_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 598          {
 599   1              unsigned char base_address = 0;
 600   1              unsigned char offset_address = 0;
 601   1      
 602   1              for (base_address = 0 ; base_address< HOST_TABLE_NUMBER ; base_address++)
 603   1              {
 604   2                      IRcvStr(I2C_ADDRESS, HOST_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸ö
             -±êÖ¾Î»
 605   2                      delay10ms();
 606   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 607   2                      {
 608   3                              if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 609   3                              {
 610   4                                      at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 611   4      #ifdef DEBUG
 612   4                                      uart_printf("hoster is delete success \r\n");
 613   4      #endif          
 614   4                              }
 615   3                              else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 616   3                              {
 617   4                                      IRcvStr(I2C_ADDRESS, (HOST_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 618   4                                      delay10ms();
 619   4                                      if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 620   4                                      {
 621   5                                              at24c64_buff[offset_address] = 0xff;
 622   5                                              ISendStr(I2C_ADDRESS, HOST_TABLE_START+base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 623   5                                              delay10ms();
 624   5                                              //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 625   5      #ifdef DEBUG
 626   5                                              uart_printf("host is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(eepr
             -om_buff + 6)), (unsigned int)(*(eeprom_buff + 7))); //
 627   5                                              uart_printf("host is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(*(
             -eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)));
 628   5                                              uart_printf("host is delete success \r\n");
 629   5      #endif          
 630   5                                      }
 631   4      
 632   4                              }
 633   3                      }
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 12  

 634   2                      ISendStr(I2C_ADDRESS, HOST_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 635   2                      //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 636   2                      delay10ms();
 637   2              }
 638   1              return 1;
 639   1      }
 640          
 641          bit delete_alarm_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 642          {
 643   1              unsigned char base_address = 0;
 644   1              unsigned char offset_address = 0;
 645   1      
 646   1              for (base_address = 0; base_address<ALARM_TABLE_NUMBER; base_address++)
 647   1              {
 648   2                      IRcvStr(I2C_ADDRESS, ALARM_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸
             -ö±êÖ¾Î»
 649   2                      delay10ms();
 650   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 651   2                      {
 652   3                              if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 653   3                              {
 654   4                                      at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 655   4      #ifdef DEBUG
 656   4                                      uart_printf("alarmer is delete success \r\n");
 657   4      #endif          
 658   4                              }
 659   3                              else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 660   3                              {
 661   4                                      IRcvStr(I2C_ADDRESS, (ALARM_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff
             -, 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 662   4                                      delay10ms();
 663   4                                      if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 664   4                                      {
 665   5                                              at24c64_buff[offset_address] = 0xff;
 666   5                                              ISendStr(I2C_ADDRESS, ALARM_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 667   5                                              delay10ms();
 668   5                                              //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 669   5      #ifdef DEBUG
 670   5                                              uart_printf("alarm is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(eep
             -rom_buff + 6)), (unsigned int)(*(eeprom_buff + 7))); //
 671   5                                              uart_printf("alarm is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(*
             -(eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)));
 672   5                                              uart_printf("alarm is delete success \r\n");
 673   5      #endif          
 674   5                                      }
 675   4      
 676   4                              }
 677   3                      }
 678   2                      ISendStr(I2C_ADDRESS, ALARM_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 679   2                      //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 680   2                      delay10ms();
 681   2              }
 682   1              return 1;
 683   1      }
 684          
 685          bit delete_cancel_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 686          {
 687   1              unsigned char base_address = 0;
 688   1              unsigned char offset_address = 0;
 689   1      
 690   1              for (base_address = 0; base_address<CANCEL_TABLE_NUMBER; base_address++)
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 13  

 691   1              {
 692   2                      IRcvStr(I2C_ADDRESS, CANCEL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32
             -¸ö±êÖ¾Î»
 693   2                      delay10ms();
 694   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 695   2                      {
 696   3                              if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 697   3                              {
 698   4                                      at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 699   4      #ifdef DEBUG
 700   4                                      uart_printf("canceler is delete success \r\n");
 701   4      #endif          
 702   4                              }
 703   3                              else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 704   3                              {
 705   4                                      IRcvStr(I2C_ADDRESS, (CANCEL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buf
             -f, 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 706   4                                      delay10ms();
 707   4                                      if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 708   4                                      {
 709   5                                              at24c64_buff[offset_address] = 0xff;
 710   5                                              ISendStr(I2C_ADDRESS, CANCEL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 711   5                                              delay10ms();
 712   5                                              //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 713   5      #ifdef DEBUG
 714   5                                              uart_printf("cancel is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(ee
             -prom_buff + 6)), (unsigned int)(*(eeprom_buff + 7))); //
 715   5                                              uart_printf("cancel is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(
             -*(eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)));
 716   5                                              uart_printf("cancel is delete success \r\n");
 717   5      #endif          
 718   5                                      }
 719   4      
 720   4                              }
 721   3                      }
 722   2                      ISendStr(I2C_ADDRESS, CANCEL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 723   2                      //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 724   2                      delay10ms();
 725   2              }
 726   1              return 1;
 727   1      }
 728          
 729          void Delete_all_data(void)
 730          {
 731   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 732   1              unsigned int k;
 733   1              for (k = CALL_TABLE_START ; k<ALL_TABLE_NUMBER; k++)
 734   1              {
 735   2                      ISendStr(I2C_ADDRESS, k * 32, dofly, PAGE_LENGTH);                   //Ð´Èë24c02
 736   2                      delay10ms();
 737   2              }
 738   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4312    ----
   CONSTANT SIZE    =    722    ----
   XDATA SIZE       =     40      88
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.00   AT24C256                                                              10/05/2015 17:39:49 PAGE 14  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
