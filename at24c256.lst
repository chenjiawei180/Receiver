C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE AT24C256
OBJECT MODULE PLACED IN at24c256.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\at24c256.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRIN
                    -T(.\at24c256.lst) TABS(2) OBJECT(at24c256.obj)

line level    source

   1          #include "at24c256.h"
   2          #include "key.h"
   3          #include "usart.h"
   4          
   5          bit ack;                //Ó¦´ð±êÖ¾Î»
   6          unsigned char xdata at24c64_buff[PAGE_LENGTH] = { 0 }; //24C256Ò³Ãæ´æ´¢»º´æ
   7          unsigned char xdata eeprom_buff[8] = { 0 };        //×¢²áÊý×é»º´æ
   8          
   9          void DelayUs2x(unsigned char t)
  10          {
  11   1        while (--t);
  12   1      }
  13          /*------------------------------------------------
  14          mSÑÓÊ±º¯Êý£¬º¬ÓÐÊäÈë²ÎÊý unsigned char t£¬ÎÞ·µ»ØÖµ
  15          unsigned char ÊÇ¶¨ÒåÎÞ·ûºÅ×Ö·û±äÁ¿£¬ÆäÖµµÄ·¶Î§ÊÇ
  16          0~255 ÕâÀïÊ¹ÓÃ¾§Õñ12M£¬¾«È·ÑÓÊ±ÇëÊ¹ÓÃ»ã±à
  17          ------------------------------------------------*/
  18          void DelayMs(unsigned char t)
  19          {
  20   1        while (t--)
  21   1        {
  22   2          //´óÖÂÑÓÊ±1mS
  23   2          DelayUs2x(245);
  24   2          DelayUs2x(245);
  25   2        }
  26   1      }
  27          
  28          
  29          /*------------------------------------------------
  30          Æô¶¯×ÜÏß
  31          ------------------------------------------------*/
  32          void Start_I2c()
  33          {
  34   1        SDA = 1;   //·¢ËÍÆðÊ¼Ìõ¼þµÄÊý¾ÝÐÅºÅ
  35   1        _Nop();
  36   1        SCL = 1;
  37   1        _Nop();    //ÆðÊ¼Ìõ¼þ½¨Á¢Ê±¼ä´óÓÚ4.7us,ÑÓÊ±
  38   1        _Nop();
  39   1        _Nop();
  40   1        _Nop();
  41   1        _Nop();
  42   1        SDA = 0;     //·¢ËÍÆðÊ¼ÐÅºÅ
  43   1        _Nop();    //ÆðÊ¼Ìõ¼þËø¶¨Ê±¼ä´óÓÚ4¦Ì
  44   1        _Nop();
  45   1        _Nop();
  46   1        _Nop();
  47   1        _Nop();
  48   1        SCL = 0;    //Ç¯×¡I2C×ÜÏß£¬×¼±¸·¢ËÍ»ò½ÓÊÕÊý¾Ý
  49   1        _Nop();
  50   1        _Nop();
  51   1      }
  52          /*------------------------------------------------
  53          ½áÊø×ÜÏß
  54          ------------------------------------------------*/
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 2   

  55          void Stop_I2c()
  56          {
  57   1        SDA = 0;    //·¢ËÍ½áÊøÌõ¼þµÄÊý¾ÝÐÅºÅ
  58   1        _Nop();   //·¢ËÍ½áÊøÌõ¼þµÄÊ±ÖÓÐÅºÅ
  59   1        SCL = 1;    //½áÊøÌõ¼þ½¨Á¢Ê±¼ä´óÓÚ4¦Ì
  60   1        _Nop();
  61   1        _Nop();
  62   1        _Nop();
  63   1        _Nop();
  64   1        _Nop();
  65   1        SDA = 1;    //·¢ËÍI2C×ÜÏß½áÊøÐÅºÅ
  66   1        _Nop();
  67   1        _Nop();
  68   1        _Nop();
  69   1        _Nop();
  70   1      }
  71          
  72          /*----------------------------------------------------------------
  73          ×Ö½ÚÊý¾Ý´«ËÍº¯Êý
  74          º¯ÊýÔ­ÐÍ: void  SendByte(unsigned char c);
  75          ¹¦ÄÜ:  ½«Êý¾Ýc·¢ËÍ³öÈ¥,¿ÉÒÔÊÇµØÖ·,Ò²¿ÉÒÔÊÇÊý¾Ý,·¢ÍêºóµÈ´ýÓ¦´ð,²¢¶Ô
  76          ´Ë×´Ì¬Î»½øÐÐ²Ù×÷.(²»Ó¦´ð»ò·ÇÓ¦´ð¶¼Ê¹ack=0 ¼Ù)
  77          ·¢ËÍÊý¾ÝÕý³££¬ack=1; ack=0±íÊ¾±»¿ØÆ÷ÎÞÓ¦´ð»òËð»µ¡£
  78          ------------------------------------------------------------------*/
  79          void  SendByte(unsigned char c)
  80          {
  81   1        unsigned char BitCnt;
  82   1        for (BitCnt = 0; BitCnt<8; BitCnt++)  //Òª´«ËÍµÄÊý¾Ý³¤¶ÈÎª8Î»
  83   1        {
  84   2          if ((c << BitCnt) & 0x80)
  85   2            SDA = 1;   //ÅÐ¶Ï·¢ËÍÎ»
  86   2          else
  87   2            SDA = 0;
  88   2          _Nop();
  89   2          SCL = 1;               //ÖÃÊ±ÖÓÏßÎª¸ß£¬Í¨Öª±»¿ØÆ÷¿ªÊ¼½ÓÊÕÊý¾ÝÎ»
  90   2          _Nop();
  91   2          _Nop();             //±£Ö¤Ê±ÖÓ¸ßµçÆ½ÖÜÆÚ´óÓÚ4¦Ì
  92   2          _Nop();
  93   2          _Nop();
  94   2          _Nop();
  95   2          SCL = 0;
  96   2        }
  97   1        _Nop();
  98   1        _Nop();
  99   1        SDA = 1;               //8Î»·¢ËÍÍêºóÊÍ·ÅÊý¾ÝÏß£¬×¼±¸½ÓÊÕÓ¦´ðÎ»
 100   1        _Nop();
 101   1        _Nop();
 102   1        SCL = 1;
 103   1        _Nop();
 104   1        _Nop();
 105   1        _Nop();
 106   1        if (SDA == 1)ack = 0;
 107   1        else ack = 1;        //ÅÐ¶ÏÊÇ·ñ½ÓÊÕµ½Ó¦´ðÐÅºÅ
 108   1        SCL = 0;
 109   1        _Nop();
 110   1        _Nop();
 111   1      }
 112          
 113          /*----------------------------------------------------------------
 114          ×Ö½ÚÊý¾Ý´«ËÍº¯Êý
 115          º¯ÊýÔ­ÐÍ: unsigned char  RcvByte();
 116          ¹¦ÄÜ:  ÓÃÀ´½ÓÊÕ´ÓÆ÷¼þ´«À´µÄÊý¾Ý,²¢ÅÐ¶Ï×ÜÏß´íÎó(²»·¢Ó¦´ðÐÅºÅ)£¬
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 3   

 117          ·¢ÍêºóÇëÓÃÓ¦´ðº¯Êý¡£
 118          ------------------------------------------------------------------*/
 119          unsigned char  RcvByte()
 120          {
 121   1        unsigned char retc;
 122   1        unsigned char BitCnt;
 123   1        retc = 0;
 124   1        SDA = 1;             //ÖÃÊý¾ÝÏßÎªÊäÈë·½Ê½
 125   1        for (BitCnt = 0; BitCnt<8; BitCnt++)
 126   1        {
 127   2          _Nop();
 128   2          SCL = 0;       //ÖÃÊ±ÖÓÏßÎªµÍ£¬×¼±¸½ÓÊÕÊý¾ÝÎ»
 129   2          _Nop();
 130   2          _Nop();      //Ê±ÖÓµÍµçÆ½ÖÜÆÚ´óÓÚ4.7us
 131   2          _Nop();
 132   2          _Nop();
 133   2          _Nop();
 134   2          SCL = 1;       //ÖÃÊ±ÖÓÏßÎª¸ßÊ¹Êý¾ÝÏßÉÏÊý¾ÝÓÐÐ§
 135   2          _Nop();
 136   2          _Nop();
 137   2          retc = retc << 1;
 138   2          if (SDA == 1)retc = retc + 1; //¶ÁÊý¾ÝÎ»,½ÓÊÕµÄÊý¾ÝÎ»·ÅÈëretcÖÐ
 139   2          _Nop();
 140   2          _Nop();
 141   2        }
 142   1        SCL = 0;
 143   1        _Nop();
 144   1        _Nop();
 145   1        return(retc);
 146   1      }
 147          
 148          
 149          /*----------------------------------------------------------------
 150          Ó¦´ð×Óº¯Êý
 151          Ô­ÐÍ:  void Ack_I2c(void);
 152          
 153          ----------------------------------------------------------------*/
 154          void Ack_I2c(void)
 155          {
 156   1        SDA = 0;
 157   1        _Nop();
 158   1        _Nop();
 159   1        _Nop();
 160   1        SCL = 1;
 161   1        _Nop();
 162   1        _Nop();              //Ê±ÖÓµÍµçÆ½ÖÜÆÚ´óÓÚ4¦Ì
 163   1        _Nop();
 164   1        _Nop();
 165   1        _Nop();
 166   1        SCL = 0;               //ÇåÊ±ÖÓÏß£¬Ç¯×¡I2C×ÜÏßÒÔ±ã¼ÌÐø½ÓÊÕ
 167   1        _Nop();
 168   1        _Nop();
 169   1      }
 170          
 171          /*----------------------------------------------------------------
 172          ·ÇÓ¦´ð×Óº¯Êý
 173          Ô­ÐÍ:  void NoAck_I2c(void);
 174          
 175          ----------------------------------------------------------------*/
 176          void NoAck_I2c(void)
 177          {
 178   1        SDA = 1;
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 4   

 179   1        _Nop();
 180   1        _Nop();
 181   1        _Nop();
 182   1        SCL = 1;
 183   1        _Nop();
 184   1        _Nop();              //Ê±ÖÓµÍµçÆ½ÖÜÆÚ´óÓÚ4¦Ì
 185   1        _Nop();
 186   1        _Nop();
 187   1        _Nop();
 188   1        SCL = 0;                //ÇåÊ±ÖÓÏß£¬Ç¯×¡I2C×ÜÏßÒÔ±ã¼ÌÐø½ÓÊÕ
 189   1        _Nop();
 190   1        _Nop();
 191   1      }
 192          
 193          /*----------------------------------------------------------------
 194          ÏòÓÐ×ÓµØÖ·Æ÷¼þ·¢ËÍ¶à×Ö½ÚÊý¾Ýº¯Êý
 195          º¯ÊýÔ­ÐÍ: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 196          ¹¦ÄÜ:     ´ÓÆô¶¯×ÜÏßµ½·¢ËÍµØÖ·£¬×ÓµØÖ·,Êý¾Ý£¬½áÊø×ÜÏßµÄÈ«¹ý³Ì,´ÓÆ÷¼þ
 197          µØÖ·sla£¬×ÓµØÖ·suba£¬·¢ËÍÄÚÈÝÊÇsÖ¸ÏòµÄÄÚÈÝ£¬·¢ËÍno¸ö×Ö½Ú¡£
 198          Èç¹û·µ»Ø1±íÊ¾²Ù×÷³É¹¦£¬·ñÔò²Ù×÷ÓÐÎó¡£
 199          ×¢Òâ£º    Ê¹ÓÃÇ°±ØÐëÒÑ½áÊø×ÜÏß¡£
 200          ----------------------------------------------------------------*/
 201          bit ISendStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 202          {
 203   1        unsigned char i;
 204   1        Start_I2c();               //Æô¶¯×ÜÏß
 205   1        SendByte(sla);             //·¢ËÍÆ÷¼þµØÖ·
 206   1        if (ack == 0)return(0);
 207   1        SendByte(suba >> 8);            //·¢ËÍÆ÷¼þ×ÓµØÖ·
 208   1        if (ack == 0)return(0);
 209   1        SendByte(suba);
 210   1        if (ack == 0)return(0);
 211   1        for (i = 0; i<no; i++)
 212   1        {
 213   2          SendByte(*s);            //·¢ËÍÊý¾Ý
 214   2          if (ack == 0)return(0);
 215   2          s++;
 216   2        }
 217   1        Stop_I2c();                  //½áÊø×ÜÏß
 218   1        return(1);
 219   1      }
 220          
 221          
 222          /*----------------------------------------------------------------
 223          ÏòÓÐ×ÓµØÖ·Æ÷¼þ¶ÁÈ¡¶à×Ö½ÚÊý¾Ýº¯Êý
 224          º¯ÊýÔ­ÐÍ: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 225          ¹¦ÄÜ:     ´ÓÆô¶¯×ÜÏßµ½·¢ËÍµØÖ·£¬×ÓµØÖ·,¶ÁÊý¾Ý£¬½áÊø×ÜÏßµÄÈ«¹ý³Ì,´ÓÆ÷¼þ
 226          µØÖ·sla£¬×ÓµØÖ·suba£¬¶Á³öµÄÄÚÈÝ·ÅÈësÖ¸ÏòµÄ´æ´¢Çø£¬¶Áno¸ö×Ö½Ú¡£
 227          Èç¹û·µ»Ø1±íÊ¾²Ù×÷³É¹¦£¬·ñÔò²Ù×÷ÓÐÎó¡£
 228          ×¢Òâ£º    Ê¹ÓÃÇ°±ØÐëÒÑ½áÊø×ÜÏß¡£
 229          ----------------------------------------------------------------*/
 230          bit IRcvStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 231          {
 232   1        unsigned char i;
 233   1        Start_I2c();               //Æô¶¯×ÜÏß
 234   1        SendByte(sla);             //·¢ËÍÆ÷¼þµØÖ·
 235   1        if (ack == 0)return(0);
 236   1        SendByte(suba >> 8);            //·¢ËÍÆ÷¼þ×ÓµØÖ·
 237   1        if (ack == 0)return(0);
 238   1        SendByte(suba);            //·¢ËÍÆ÷¼þ×ÓµØÖ·
 239   1        if (ack == 0)return(0);
 240   1        Start_I2c();
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 5   

 241   1        SendByte(sla + 1);
 242   1        if (ack == 0)return(0);
 243   1        for (i = 0; i<no - 1; i++)
 244   1        {
 245   2          *s = RcvByte();              //·¢ËÍÊý¾Ý
 246   2          Ack_I2c();                //·¢ËÍ¾Í´ðÎ» 
 247   2          s++;
 248   2        }
 249   1        *s = RcvByte();
 250   1        NoAck_I2c();                 //·¢ËÍ·ÇÓ¦Î»
 251   1        Stop_I2c();                    //½áÊø×ÜÏß
 252   1        return(1);
 253   1      }
 254          
 255          bit register_call_function(unsigned char *buf)
 256          {
 257   1          unsigned char base_address = 0;//»ù×¼µØÖ·   
 258   1          unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 259   1          //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 260   1          /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 261   1          for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)  //32*32 =1024¸ö±êÖ¾
             -Î»
 262   1          {
 263   2            IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½Úµ
             -Ä±êÖ¾Î»
 264   2            delay10ms();
 265   2            for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾Í
             -OK
 266   2            {
 267   3              if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 268   3              {
 269   4                IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff
             -, 8);
 270   4                delay10ms();
 271   4      
 272   4                if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) =
             -= *(buf + 7)))
 273   4                {
 274   5                  //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 275   5                  Two_Menu_F1_E1[0] = *(eeprom_buff + 1);
 276   5                  Two_Menu_F1_E1[1] = *(eeprom_buff + 2);
 277   5                  Two_Menu_F1_E1[2] = *(eeprom_buff + 3);
 278   5                  Two_Menu_F1_E1[3] = *(eeprom_buff + 4);
 279   5      #ifdef DEBUG
 280   5                  uart_printf("caller register is old! \n\r"); 
 281   5      #endif
 282   5      
 283   5      //            if (sound_table == 1)
 284   5      //            {
 285   5      //#if SOUND
 286   5      //              GD5800_select_chapter(SETERROR_POSITION);
 287   5      //#endif
 288   5      //              sound_table = 0;
 289   5      //            }
 290   5                  return 0;
 291   5                }
 292   4              }
 293   3            }
 294   2          }
 295   1          //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 296   1          for (base_address = CALL_TABLE_START; base_address<CALL_TABLE_NUMBER; base_address++)
 297   1          {
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 6   

 298   2            IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C64ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
 299   2            delay10ms();
 300   2            for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾Í
             -OK
 301   2            {
 302   3              if (at24c64_buff[offset_address] != 0)
 303   3              {
 304   4                ISendStr(I2C_ADDRESS, (CALL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8);
 305   4                delay10ms();
 306   4                at24c64_buff[offset_address] = 0;
 307   4                ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 308   4                delay10ms();
 309   4                //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 310   4      #ifdef DEBUG
 311   4                uart_printf("caller register is new! \n\r");
 312   4      #endif
 313   4      //          if (sound_table == 1)
 314   4      //          {
 315   4      //#if SOUND
 316   4      //            GD5800_select_chapter(SETSUCCESS_POSITION);
 317   4      //#endif
 318   4      //            sound_table = 0;
 319   4      //          }
 320   4                return 1;
 321   4                //ÌáÊ¾³É¹¦        
 322   4              }
 323   3            }
 324   2          }
 325   1          return 0;
 326   1      }
 327          
 328          bit register_host_function(unsigned char *buf)
 329          {
 330   1        unsigned char base_address = 0;//»ù×¼µØÖ·   
 331   1        unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 332   1        //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 333   1        /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 334   1        for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)  //32*32 =1024¸ö±êÖ¾Î
             -»
 335   1        {
 336   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
 337   2          delay10ms();
 338   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 339   2          {
 340   3            if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 341   3            {
 342   4              IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);
 343   4              delay10ms();
 344   4      
 345   4              if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) ==
             - *(buf + 7)))
 346   4              {
 347   5                //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 348   5                Two_Menu_F1_E2[0] = *(eeprom_buff + 1);
 349   5                Two_Menu_F1_E2[1] = *(eeprom_buff + 2);
 350   5                Two_Menu_F1_E2[2] = *(eeprom_buff + 3);
 351   5                Two_Menu_F1_E2[3] = *(eeprom_buff + 4);
 352   5      #ifdef DEBUG
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 7   

 353   5                uart_printf("host register is old! \n\r");
 354   5      #endif
 355   5      
 356   5                //            if (sound_table == 1)
 357   5                //            {
 358   5                //#if SOUND
 359   5                //              GD5800_select_chapter(SETERROR_POSITION);
 360   5                //#endif
 361   5                //              sound_table = 0;
 362   5                //            }
 363   5                return 0;
 364   5              }
 365   4            }
 366   3          }
 367   2        }
 368   1        //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 369   1        for (base_address = HOST_TABLE_START; base_address<HOST_TABLE_NUMBER; base_address++)
 370   1        {
 371   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C64ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±
             -êÖ¾Î»
 372   2          delay10ms();
 373   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 374   2          {
 375   3            if (at24c64_buff[offset_address] != 0)
 376   3            {
 377   4              ISendStr(I2C_ADDRESS, (HOST_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8);
 378   4              delay10ms();
 379   4              at24c64_buff[offset_address] = 0;
 380   4              ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 381   4              delay10ms();
 382   4              //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 383   4      #ifdef DEBUG
 384   4              uart_printf("host register is new! \n\r");
 385   4      #endif
 386   4              //          if (sound_table == 1)
 387   4              //          {
 388   4              //#if SOUND
 389   4              //            GD5800_select_chapter(SETSUCCESS_POSITION);
 390   4              //#endif
 391   4              //            sound_table = 0;
 392   4              //          }
 393   4              return 1;
 394   4              //ÌáÊ¾³É¹¦        
 395   4            }
 396   3          }
 397   2        }
 398   1        return 0;
 399   1      }
 400          
 401          bit register_alarm_function(unsigned char *buf)
 402          {
 403   1        unsigned char base_address = 0;//»ù×¼µØÖ·   
 404   1        unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 405   1        //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 406   1        /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 407   1        for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)  //32*32 =1024¸ö±êÖ¾Î
             -»
 408   1        {
 409   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
 410   2          delay10ms();
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 8   

 411   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 412   2          {
 413   3            if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 414   3            {
 415   4              IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);
 416   4              delay10ms();
 417   4      
 418   4              if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) ==
             - *(buf + 7)))
 419   4              {
 420   5                //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 421   5                Two_Menu_F1_E3[0] = *(eeprom_buff + 1);
 422   5                Two_Menu_F1_E3[1] = *(eeprom_buff + 2);
 423   5                Two_Menu_F1_E3[2] = *(eeprom_buff + 3);
 424   5                Two_Menu_F1_E3[3] = *(eeprom_buff + 4);
 425   5      #ifdef DEBUG
 426   5                uart_printf("alarmer register is old! \n\r");
 427   5      #endif
 428   5      
 429   5                //            if (sound_table == 1)
 430   5                //            {
 431   5                //#if SOUND
 432   5                //              GD5800_select_chapter(SETERROR_POSITION);
 433   5                //#endif
 434   5                //              sound_table = 0;
 435   5                //            }
 436   5                return 0;
 437   5              }
 438   4            }
 439   3          }
 440   2        }
 441   1        //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 442   1        for (base_address = ALARM_TABLE_START; base_address<ALARM_TABLE_NUMBER; base_address++)
 443   1        {
 444   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C64ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±
             -êÖ¾Î»
 445   2          delay10ms();
 446   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 447   2          {
 448   3            if (at24c64_buff[offset_address] != 0)
 449   3            {
 450   4              ISendStr(I2C_ADDRESS, (ALARM_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8);
 451   4              delay10ms();
 452   4              at24c64_buff[offset_address] = 0;
 453   4              ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 454   4              delay10ms();
 455   4              //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 456   4      #ifdef DEBUG
 457   4              uart_printf("alarmer register is new! \n\r");
 458   4      #endif
 459   4              //          if (sound_table == 1)
 460   4              //          {
 461   4              //#if SOUND
 462   4              //            GD5800_select_chapter(SETSUCCESS_POSITION);
 463   4              //#endif
 464   4              //            sound_table = 0;
 465   4              //          }
 466   4              return 1;
 467   4              //ÌáÊ¾³É¹¦        
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 9   

 468   4            }
 469   3          }
 470   2        }
 471   1        return 0;
 472   1      }
 473          
 474          bit register_cancel_function(unsigned char *buf)
 475          {
 476   1        unsigned char base_address = 0;//»ù×¼µØÖ·   
 477   1        unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 478   1        //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 479   1        /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 480   1        for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)  //32*32 =1024¸ö±êÖ¾Î
             -»
 481   1        {
 482   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
 483   2          delay10ms();
 484   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 485   2          {
 486   3            if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 487   3            {
 488   4              IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);
 489   4              delay10ms();
 490   4      
 491   4              if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) ==
             - *(buf + 7)))
 492   4              {
 493   5                //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 494   5                Two_Menu_F1_E4[0] = *(eeprom_buff + 1);
 495   5                Two_Menu_F1_E4[1] = *(eeprom_buff + 2);
 496   5                Two_Menu_F1_E4[2] = *(eeprom_buff + 3);
 497   5                Two_Menu_F1_E4[3] = *(eeprom_buff + 4);
 498   5      #ifdef DEBUG
 499   5                uart_printf("canceler register is old! \n\r");
 500   5      #endif
 501   5      
 502   5                //            if (sound_table == 1)
 503   5                //            {
 504   5                //#if SOUND
 505   5                //              GD5800_select_chapter(SETERROR_POSITION);
 506   5                //#endif
 507   5                //              sound_table = 0;
 508   5                //            }
 509   5                return 0;
 510   5              }
 511   4            }
 512   3          }
 513   2        }
 514   1        //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 515   1        for (base_address = CANCEL_TABLE_START; base_address<CANCEL_TABLE_NUMBER; base_address++)
 516   1        {
 517   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C64ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±
             -êÖ¾Î»
 518   2          delay10ms();
 519   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 520   2          {
 521   3            if (at24c64_buff[offset_address] != 0)
 522   3            {
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 10  

 523   4              ISendStr(I2C_ADDRESS, (CANCEL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8)
             -;
 524   4              delay10ms();
 525   4              at24c64_buff[offset_address] = 0;
 526   4              ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 527   4              delay10ms();
 528   4              //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 529   4      #ifdef DEBUG
 530   4              uart_printf("canceler register is new! \n\r");
 531   4      #endif
 532   4              //          if (sound_table == 1)
 533   4              //          {
 534   4              //#if SOUND
 535   4              //            GD5800_select_chapter(SETSUCCESS_POSITION);
 536   4              //#endif
 537   4              //            sound_table = 0;
 538   4              //          }
 539   4              return 1;
 540   4              //ÌáÊ¾³É¹¦        
 541   4            }
 542   3          }
 543   2        }
 544   1        return 0;
 545   1      }
 546          
 547          bit delete_call_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 548          {
 549   1        unsigned char base_address = 0;
 550   1        unsigned char offset_address = 0;
 551   1      
 552   1        for (base_address = CALL_TABLE_START; base_address<CALL_TABLE_NUMBER; base_address++)
 553   1        {
 554   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸ö±êÖ¾Î»
 555   2          delay10ms();
 556   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 557   2          {
 558   3            if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 559   3            {
 560   4              at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 561   4      #ifdef DEBUG
 562   4              uart_printf("caller is delete success \r\n");
 563   4      #endif    
 564   4            }
 565   3            else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 566   3            {
 567   4              IRcvStr(I2C_ADDRESS, ( CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff
             -, 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 568   4              delay10ms();
 569   4              if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 570   4              {
 571   5                at24c64_buff[offset_address] = 0xff;
 572   5                ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 573   5                delay10ms();
 574   5                //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 575   5      #ifdef DEBUG
 576   5                uart_printf("call is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(eepr
             -om_buff + 6)), (unsigned int)(*(eeprom_buff + 7)) ); //
 577   5                uart_printf("call is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(*(
             -eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)) );
 578   5                uart_printf("caller is delete success \r\n");
 579   5      #endif    
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 11  

 580   5              }
 581   4      
 582   4            }
 583   3          }
 584   2          ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 585   2          //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 586   2          delay10ms();
 587   2        }
 588   1        return 1;
 589   1      }
 590          
 591          bit delete_host_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 592          {
 593   1        unsigned char base_address = 0;
 594   1        unsigned char offset_address = 0;
 595   1      
 596   1        for (base_address = HOST_TABLE_START; base_address<HOST_TABLE_NUMBER; base_address++)
 597   1        {
 598   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸ö±êÖ¾Î»
 599   2          delay10ms();
 600   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 601   2          {
 602   3            if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 603   3            {
 604   4              at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 605   4      #ifdef DEBUG
 606   4              uart_printf("hoster is delete success \r\n");
 607   4      #endif    
 608   4            }
 609   3            else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 610   3            {
 611   4              IRcvStr(I2C_ADDRESS, (HOST_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 612   4              delay10ms();
 613   4              if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 614   4              {
 615   5                at24c64_buff[offset_address] = 0xff;
 616   5                ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 617   5                delay10ms();
 618   5                //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 619   5      #ifdef DEBUG
 620   5                uart_printf("host is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(eepr
             -om_buff + 6)), (unsigned int)(*(eeprom_buff + 7))); //
 621   5                uart_printf("host is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(*(
             -eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)));
 622   5                uart_printf("host is delete success \r\n");
 623   5      #endif    
 624   5              }
 625   4      
 626   4            }
 627   3          }
 628   2          ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 629   2          //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 630   2          delay10ms();
 631   2        }
 632   1        return 1;
 633   1      }
 634          
 635          bit delete_alarm_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 636          {
 637   1        unsigned char base_address = 0;
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 12  

 638   1        unsigned char offset_address = 0;
 639   1      
 640   1        for (base_address = ALARM_TABLE_START; base_address<ALARM_TABLE_NUMBER; base_address++)
 641   1        {
 642   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸ö±êÖ¾Î»
 643   2          delay10ms();
 644   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 645   2          {
 646   3            if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 647   3            {
 648   4              at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 649   4      #ifdef DEBUG
 650   4              uart_printf("alarmer is delete success \r\n");
 651   4      #endif    
 652   4            }
 653   3            else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 654   3            {
 655   4              IRcvStr(I2C_ADDRESS, (ALARM_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff
             -, 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 656   4              delay10ms();
 657   4              if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 658   4              {
 659   5                at24c64_buff[offset_address] = 0xff;
 660   5                ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 661   5                delay10ms();
 662   5                //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 663   5      #ifdef DEBUG
 664   5                uart_printf("alarm is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(eep
             -rom_buff + 6)), (unsigned int)(*(eeprom_buff + 7))); //
 665   5                uart_printf("alarm is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(*
             -(eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)));
 666   5                uart_printf("alarm is delete success \r\n");
 667   5      #endif    
 668   5              }
 669   4      
 670   4            }
 671   3          }
 672   2          ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 673   2          //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 674   2          delay10ms();
 675   2        }
 676   1        return 1;
 677   1      }
 678          
 679          bit delete_cancel_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 680          {
 681   1        unsigned char base_address = 0;
 682   1        unsigned char offset_address = 0;
 683   1      
 684   1        for (base_address = CANCEL_TABLE_START; base_address<CANCEL_TABLE_NUMBER; base_address++)
 685   1        {
 686   2          IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸ö±êÖ¾Î»
 687   2          delay10ms();
 688   2          for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 689   2          {
 690   3            if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 691   3            {
 692   4              at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 693   4      #ifdef DEBUG
 694   4              uart_printf("canceler is delete success \r\n");
 695   4      #endif    
C51 COMPILER V9.00   AT24C256                                                              09/24/2015 12:29:34 PAGE 13  

 696   4            }
 697   3            else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 698   3            {
 699   4              IRcvStr(I2C_ADDRESS, (CANCEL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buf
             -f, 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 700   4              delay10ms();
 701   4              if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 702   4              {
 703   5                at24c64_buff[offset_address] = 0xff;
 704   5                ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 705   5                delay10ms();
 706   5                //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 707   5      #ifdef DEBUG
 708   5                uart_printf("cancel is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(ee
             -prom_buff + 6)), (unsigned int)(*(eeprom_buff + 7))); //
 709   5                uart_printf("cancel is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(
             -*(eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)));
 710   5                uart_printf("cancel is delete success \r\n");
 711   5      #endif    
 712   5              }
 713   4      
 714   4            }
 715   3          }
 716   2          ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 717   2          //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 718   2          delay10ms();
 719   2        }
 720   1        return 1;
 721   1      }
 722          
 723          void Delete_all_data(void)
 724          {
 725   1        unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 726   1        unsigned int k;
 727   1        for (k = CALL_TABLE_START ; k<ALL_TABLE_NUMBER; k++)
 728   1        {
 729   2          ISendStr(I2C_ADDRESS, k * 32, dofly, PAGE_LENGTH);                   //Ð´Èë24c02
 730   2          delay10ms();
 731   2        }
 732   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3872    ----
   CONSTANT SIZE    =    684    ----
   XDATA SIZE       =     40      88
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
