C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE AT24C256
OBJECT MODULE PLACED IN at24c256.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\at24c256.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRIN
                    -T(.\at24c256.lst) OBJECT(at24c256.obj)

line level    source

   1          #include "at24c256.h"
   2          #include "key.h"
   3          #include "usart.h"
   4          #include "menu.h"
   5          #include "gd5800.h"
   6          
   7          bit ack;                      //Ó¦´ð±êÖ¾Î»
   8          unsigned char xdata at24c64_buff[PAGE_LENGTH] = { 0 }; //24C256Ò³Ãæ´æ´¢»º´æ
   9          unsigned char xdata eeprom_buff[8] = { 0 };                        //×¢²áÊý×é»º´æ
  10          
  11          void DelayUs2x(unsigned char t)
  12          {
  13   1              while (--t);
  14   1      }
  15          /*------------------------------------------------
  16          mSÑÓÊ±º¯Êý£¬º¬ÓÐÊäÈë²ÎÊý unsigned char t£¬ÎÞ·µ»ØÖµ
  17          unsigned char ÊÇ¶¨ÒåÎÞ·ûºÅ×Ö·û±äÁ¿£¬ÆäÖµµÄ·¶Î§ÊÇ
  18          0~255 ÕâÀïÊ¹ÓÃ¾§Õñ12M£¬¾«È·ÑÓÊ±ÇëÊ¹ÓÃ»ã±à
  19          ------------------------------------------------*/
  20          void DelayMs(unsigned char t)
  21          {
  22   1              while (t--)
  23   1              {
  24   2                      //´óÖÂÑÓÊ±1mS
  25   2                      DelayUs2x(245);
  26   2                      DelayUs2x(245);
  27   2              }
  28   1      }
  29          
  30          
  31          /*------------------------------------------------
  32          Æô¶¯×ÜÏß
  33          ------------------------------------------------*/
  34          void Start_I2c()
  35          {
  36   1              SDA = 1;   //·¢ËÍÆðÊ¼Ìõ¼þµÄÊý¾ÝÐÅºÅ
  37   1              _Nop();
  38   1              SCL = 1;
  39   1              _Nop();    //ÆðÊ¼Ìõ¼þ½¨Á¢Ê±¼ä´óÓÚ4.7us,ÑÓÊ±
  40   1              _Nop();
  41   1              _Nop();
  42   1              _Nop();
  43   1              _Nop();
  44   1              SDA = 0;     //·¢ËÍÆðÊ¼ÐÅºÅ
  45   1              _Nop();    //ÆðÊ¼Ìõ¼þËø¶¨Ê±¼ä´óÓÚ4¦Ì
  46   1              _Nop();
  47   1              _Nop();
  48   1              _Nop();
  49   1              _Nop();
  50   1              SCL = 0;    //Ç¯×¡I2C×ÜÏß£¬×¼±¸·¢ËÍ»ò½ÓÊÕÊý¾Ý
  51   1              _Nop();
  52   1              _Nop();
  53   1      }
  54          /*------------------------------------------------
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 2   

  55          ½áÊø×ÜÏß
  56          ------------------------------------------------*/
  57          void Stop_I2c()
  58          {
  59   1              SDA = 0;    //·¢ËÍ½áÊøÌõ¼þµÄÊý¾ÝÐÅºÅ
  60   1              _Nop();   //·¢ËÍ½áÊøÌõ¼þµÄÊ±ÖÓÐÅºÅ
  61   1              SCL = 1;    //½áÊøÌõ¼þ½¨Á¢Ê±¼ä´óÓÚ4¦Ì
  62   1              _Nop();
  63   1              _Nop();
  64   1              _Nop();
  65   1              _Nop();
  66   1              _Nop();
  67   1              SDA = 1;    //·¢ËÍI2C×ÜÏß½áÊøÐÅºÅ
  68   1              _Nop();
  69   1              _Nop();
  70   1              _Nop();
  71   1              _Nop();
  72   1      }
  73          
  74          /*----------------------------------------------------------------
  75          ×Ö½ÚÊý¾Ý´«ËÍº¯Êý
  76          º¯ÊýÔ­ÐÍ: void  SendByte(unsigned char c);
  77          ¹¦ÄÜ:  ½«Êý¾Ýc·¢ËÍ³öÈ¥,¿ÉÒÔÊÇµØÖ·,Ò²¿ÉÒÔÊÇÊý¾Ý,·¢ÍêºóµÈ´ýÓ¦´ð,²¢¶Ô
  78          ´Ë×´Ì¬Î»½øÐÐ²Ù×÷.(²»Ó¦´ð»ò·ÇÓ¦´ð¶¼Ê¹ack=0 ¼Ù)
  79          ·¢ËÍÊý¾ÝÕý³££¬ack=1; ack=0±íÊ¾±»¿ØÆ÷ÎÞÓ¦´ð»òËð»µ¡£
  80          ------------------------------------------------------------------*/
  81          void  SendByte(unsigned char c)
  82          {
  83   1              unsigned char BitCnt;
  84   1              for (BitCnt = 0; BitCnt<8; BitCnt++)  //Òª´«ËÍµÄÊý¾Ý³¤¶ÈÎª8Î»
  85   1              {
  86   2                      if ((c << BitCnt) & 0x80)
  87   2                              SDA = 1;   //ÅÐ¶Ï·¢ËÍÎ»
  88   2                      else
  89   2                              SDA = 0;
  90   2                      _Nop();
  91   2                      SCL = 1;               //ÖÃÊ±ÖÓÏßÎª¸ß£¬Í¨Öª±»¿ØÆ÷¿ªÊ¼½ÓÊÕÊý¾ÝÎ»
  92   2                      _Nop();
  93   2                      _Nop();             //±£Ö¤Ê±ÖÓ¸ßµçÆ½ÖÜÆÚ´óÓÚ4¦Ì
  94   2                      _Nop();
  95   2                      _Nop();
  96   2                      _Nop();
  97   2                      SCL = 0;
  98   2              }
  99   1              _Nop();
 100   1              _Nop();
 101   1              SDA = 1;               //8Î»·¢ËÍÍêºóÊÍ·ÅÊý¾ÝÏß£¬×¼±¸½ÓÊÕÓ¦´ðÎ»
 102   1              _Nop();
 103   1              _Nop();
 104   1              SCL = 1;
 105   1              _Nop();
 106   1              _Nop();
 107   1              _Nop();
 108   1              if (SDA == 1)ack = 0;
 109   1              else ack = 1;        //ÅÐ¶ÏÊÇ·ñ½ÓÊÕµ½Ó¦´ðÐÅºÅ
 110   1              SCL = 0;
 111   1              _Nop();
 112   1              _Nop();
 113   1      }
 114          
 115          /*----------------------------------------------------------------
 116          ×Ö½ÚÊý¾Ý´«ËÍº¯Êý
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 3   

 117          º¯ÊýÔ­ÐÍ: unsigned char  RcvByte();
 118          ¹¦ÄÜ:  ÓÃÀ´½ÓÊÕ´ÓÆ÷¼þ´«À´µÄÊý¾Ý,²¢ÅÐ¶Ï×ÜÏß´íÎó(²»·¢Ó¦´ðÐÅºÅ)£¬
 119          ·¢ÍêºóÇëÓÃÓ¦´ðº¯Êý¡£
 120          ------------------------------------------------------------------*/
 121          unsigned char  RcvByte()
 122          {
 123   1              unsigned char retc;
 124   1              unsigned char BitCnt;
 125   1              retc = 0;
 126   1              SDA = 1;             //ÖÃÊý¾ÝÏßÎªÊäÈë·½Ê½
 127   1              for (BitCnt = 0; BitCnt<8; BitCnt++)
 128   1              {
 129   2                      _Nop();
 130   2                      SCL = 0;       //ÖÃÊ±ÖÓÏßÎªµÍ£¬×¼±¸½ÓÊÕÊý¾ÝÎ»
 131   2                      _Nop();
 132   2                      _Nop();      //Ê±ÖÓµÍµçÆ½ÖÜÆÚ´óÓÚ4.7us
 133   2                      _Nop();
 134   2                      _Nop();
 135   2                      _Nop();
 136   2                      SCL = 1;       //ÖÃÊ±ÖÓÏßÎª¸ßÊ¹Êý¾ÝÏßÉÏÊý¾ÝÓÐÐ§
 137   2                      _Nop();
 138   2                      _Nop();
 139   2                      retc = retc << 1;
 140   2                      if (SDA == 1)retc = retc + 1; //¶ÁÊý¾ÝÎ»,½ÓÊÕµÄÊý¾ÝÎ»·ÅÈëretcÖÐ
 141   2                      _Nop();
 142   2                      _Nop();
 143   2              }
 144   1              SCL = 0;
 145   1              _Nop();
 146   1              _Nop();
 147   1              return(retc);
 148   1      }
 149          
 150          
 151          /*----------------------------------------------------------------
 152          Ó¦´ð×Óº¯Êý
 153          Ô­ÐÍ:  void Ack_I2c(void);
 154          
 155          ----------------------------------------------------------------*/
 156          void Ack_I2c(void)
 157          {
 158   1              SDA = 0;
 159   1              _Nop();
 160   1              _Nop();
 161   1              _Nop();
 162   1              SCL = 1;
 163   1              _Nop();
 164   1              _Nop();              //Ê±ÖÓµÍµçÆ½ÖÜÆÚ´óÓÚ4¦Ì
 165   1              _Nop();
 166   1              _Nop();
 167   1              _Nop();
 168   1              SCL = 0;               //ÇåÊ±ÖÓÏß£¬Ç¯×¡I2C×ÜÏßÒÔ±ã¼ÌÐø½ÓÊÕ
 169   1              _Nop();
 170   1              _Nop();
 171   1      }
 172          
 173          /*----------------------------------------------------------------
 174          ·ÇÓ¦´ð×Óº¯Êý
 175          Ô­ÐÍ:  void NoAck_I2c(void);
 176          
 177          ----------------------------------------------------------------*/
 178          void NoAck_I2c(void)
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 4   

 179          {
 180   1              SDA = 1;
 181   1              _Nop();
 182   1              _Nop();
 183   1              _Nop();
 184   1              SCL = 1;
 185   1              _Nop();
 186   1              _Nop();              //Ê±ÖÓµÍµçÆ½ÖÜÆÚ´óÓÚ4¦Ì
 187   1              _Nop();
 188   1              _Nop();
 189   1              _Nop();
 190   1              SCL = 0;                //ÇåÊ±ÖÓÏß£¬Ç¯×¡I2C×ÜÏßÒÔ±ã¼ÌÐø½ÓÊÕ
 191   1              _Nop();
 192   1              _Nop();
 193   1      }
 194          
 195          /*----------------------------------------------------------------
 196          ÏòÓÐ×ÓµØÖ·Æ÷¼þ·¢ËÍ¶à×Ö½ÚÊý¾Ýº¯Êý
 197          º¯ÊýÔ­ÐÍ: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 198          ¹¦ÄÜ:     ´ÓÆô¶¯×ÜÏßµ½·¢ËÍµØÖ·£¬×ÓµØÖ·,Êý¾Ý£¬½áÊø×ÜÏßµÄÈ«¹ý³Ì,´ÓÆ÷¼þ
 199          µØÖ·sla£¬×ÓµØÖ·suba£¬·¢ËÍÄÚÈÝÊÇsÖ¸ÏòµÄÄÚÈÝ£¬·¢ËÍno¸ö×Ö½Ú¡£
 200          Èç¹û·µ»Ø1±íÊ¾²Ù×÷³É¹¦£¬·ñÔò²Ù×÷ÓÐÎó¡£
 201          ×¢Òâ£º    Ê¹ÓÃÇ°±ØÐëÒÑ½áÊø×ÜÏß¡£
 202          ----------------------------------------------------------------*/
 203          bit ISendStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 204          {
 205   1              unsigned char i;
 206   1              Start_I2c();               //Æô¶¯×ÜÏß
 207   1              SendByte(sla);             //·¢ËÍÆ÷¼þµØÖ·
 208   1              if (ack == 0)return(0);
 209   1              SendByte(suba >> 8);            //·¢ËÍÆ÷¼þ×ÓµØÖ·
 210   1              if (ack == 0)return(0);
 211   1              SendByte(suba);
 212   1              if (ack == 0)return(0);
 213   1              for (i = 0; i<no; i++)
 214   1              {
 215   2                      SendByte(*s);            //·¢ËÍÊý¾Ý
 216   2                      if (ack == 0)return(0);
 217   2                      s++;
 218   2              }
 219   1              Stop_I2c();                  //½áÊø×ÜÏß
 220   1              return(1);
 221   1      }
 222          
 223          
 224          /*----------------------------------------------------------------
 225          ÏòÓÐ×ÓµØÖ·Æ÷¼þ¶ÁÈ¡¶à×Ö½ÚÊý¾Ýº¯Êý
 226          º¯ÊýÔ­ÐÍ: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 227          ¹¦ÄÜ:     ´ÓÆô¶¯×ÜÏßµ½·¢ËÍµØÖ·£¬×ÓµØÖ·,¶ÁÊý¾Ý£¬½áÊø×ÜÏßµÄÈ«¹ý³Ì,´ÓÆ÷¼þ
 228          µØÖ·sla£¬×ÓµØÖ·suba£¬¶Á³öµÄÄÚÈÝ·ÅÈësÖ¸ÏòµÄ´æ´¢Çø£¬¶Áno¸ö×Ö½Ú¡£
 229          Èç¹û·µ»Ø1±íÊ¾²Ù×÷³É¹¦£¬·ñÔò²Ù×÷ÓÐÎó¡£
 230          ×¢Òâ£º    Ê¹ÓÃÇ°±ØÐëÒÑ½áÊø×ÜÏß¡£
 231          ----------------------------------------------------------------*/
 232          bit IRcvStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 233          {
 234   1              unsigned char i;
 235   1              Start_I2c();               //Æô¶¯×ÜÏß
 236   1              SendByte(sla);             //·¢ËÍÆ÷¼þµØÖ·
 237   1              if (ack == 0)return(0);
 238   1              SendByte(suba >> 8);            //·¢ËÍÆ÷¼þ×ÓµØÖ·
 239   1              if (ack == 0)return(0);
 240   1              SendByte(suba);            //·¢ËÍÆ÷¼þ×ÓµØÖ·
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 5   

 241   1              if (ack == 0)return(0);
 242   1              Start_I2c();
 243   1              SendByte(sla + 1);
 244   1              if (ack == 0)return(0);
 245   1              for (i = 0; i<no - 1; i++)
 246   1              {
 247   2                      *s = RcvByte();              //·¢ËÍÊý¾Ý
 248   2                      Ack_I2c();                //·¢ËÍ¾Í´ðÎ» 
 249   2                      s++;
 250   2              }
 251   1              *s = RcvByte();
 252   1              NoAck_I2c();                 //·¢ËÍ·ÇÓ¦Î»
 253   1              Stop_I2c();                    //½áÊø×ÜÏß
 254   1              return(1);
 255   1      }
 256          
 257          bit register_call_function(unsigned char *buf)
 258          {
 259   1                      unsigned char base_address = 0;//»ù×¼µØÖ·   
 260   1                      unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 261   1                      //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 262   1                      /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 263   1                      for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)    //32*32 =1024¸ö±êÖ¾
             -Î»
 264   1                      {
 265   2                              IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½Úµ
             -Ä±êÖ¾Î»
 266   2                              delay10ms();
 267   2                              for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾Í
             -OK
 268   2                              {
 269   3                                      if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 270   3                                      {
 271   4                                              IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff
             -, 8);
 272   4                                              delay10ms();
 273   4      
 274   4                                              if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) =
             -= *(buf + 7)))
 275   4                                              {
 276   5                                                      //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 277   5                                                      Two_Menu_F1_E1[0] = *(eeprom_buff + 1);
 278   5                                                      Two_Menu_F1_E1[1] = *(eeprom_buff + 2);
 279   5                                                      Two_Menu_F1_E1[2] = *(eeprom_buff + 3);
 280   5                                                      Two_Menu_F1_E1[3] = *(eeprom_buff + 4);
 281   5      #ifdef DEBUG
                                                              uart_printf("caller register is old! \n\r"); 
              #endif
 284   5      
 285   5                                                      if (return_sound_table() == 1)
 286   5                                                      {
 287   6                                                              GD5800_select_chapter(SHIBAI);
 288   6      
 289   6                                                              set_sound_table(0);
 290   6                                                      }
 291   5                                                      return 0;
 292   5                                              }
 293   4                                      }
 294   3                              }
 295   2                      }
 296   1                      //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 297   1                      for (base_address = 0; base_address<CALL_TABLE_NUMBER; base_address++)
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 6   

 298   1                      {
 299   2                              IRcvStr(I2C_ADDRESS, CALL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C6
             -4ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±êÖ¾Î»
 300   2                              delay10ms();
 301   2                              for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾Í
             -OK
 302   2                              {
 303   3                                      if (at24c64_buff[offset_address] != 0)
 304   3                                      {
 305   4                                              ISendStr(I2C_ADDRESS, (CALL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8);
 306   4                                              delay10ms();
 307   4                                              at24c64_buff[offset_address] = 0;
 308   4                                              ISendStr(I2C_ADDRESS, CALL_TABLE_START+base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 309   4                                              delay10ms();
 310   4                                              //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 311   4      #ifdef DEBUG
                                                      uart_printf("caller register is new! \n\r");
                                                      uart_printf("±êÖ¾µØÖ·Îª %x ! \n\r", (unsigned int)(CALL_TABLE_START + base_address*PAGE_LENGTH) );
                                                      uart_printf("´æ´¢µØÖ·Îª %x ! \n\r", CALL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) *
             - 8);
              #endif
 316   4                                              if (return_sound_table() == 1)
 317   4                                              {
 318   5                                                      GD5800_select_chapter(CHENGGONG);
 319   5      
 320   5                                                      set_sound_table(0);
 321   5                                              }
 322   4                                              return 1;
 323   4                                              //ÌáÊ¾³É¹¦                              
 324   4                                      }
 325   3                              }
 326   2                      }
 327   1                      return 0;
 328   1      }
 329          
 330          bit register_host_function(unsigned char *buf)
 331          {
 332   1              unsigned char base_address = 0;//»ù×¼µØÖ·   
 333   1              unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 334   1              //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 335   1              /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 336   1              for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)    //32*32 =1024¸ö±êÖ¾Î
             -»
 337   1              {
 338   2                      IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
 339   2                      delay10ms();
 340   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 341   2                      {
 342   3                              if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 343   3                              {
 344   4                                      IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);
 345   4                                      delay10ms();
 346   4      
 347   4                                      if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) ==
             - *(buf + 7)))
 348   4                                      {
 349   5                                              //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 350   5                                              Two_Menu_F1_E2[0] = *(eeprom_buff + 1);
 351   5                                              Two_Menu_F1_E2[1] = *(eeprom_buff + 2);
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 7   

 352   5                                              Two_Menu_F1_E2[2] = *(eeprom_buff + 3);
 353   5                                              Two_Menu_F1_E2[3] = *(eeprom_buff + 4);
 354   5      #ifdef DEBUG
                                                      uart_printf("host register is old! \n\r");
              #endif
 357   5      
 358   5                                              if (return_sound_table() == 1)
 359   5                                              {
 360   6                                                      GD5800_select_chapter(SHIBAI);
 361   6      
 362   6                                                      set_sound_table(0);
 363   6                                              }
 364   5                                              return 0;
 365   5                                      }
 366   4                              }
 367   3                      }
 368   2              }
 369   1              //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 370   1              for (base_address = 0; base_address<HOST_TABLE_NUMBER; base_address++)
 371   1              {
 372   2                      IRcvStr(I2C_ADDRESS, HOST_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C64
             -ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±êÖ¾Î»
 373   2                      delay10ms();
 374   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 375   2                      {
 376   3                              if (at24c64_buff[offset_address] != 0)
 377   3                              {
 378   4                                      ISendStr(I2C_ADDRESS, (HOST_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8);
 379   4                                      delay10ms();
 380   4                                      at24c64_buff[offset_address] = 0;
 381   4                                      ISendStr(I2C_ADDRESS,HOST_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 382   4                                      delay10ms();
 383   4                                      //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 384   4      #ifdef DEBUG
                                              uart_printf("host register is new! \n\r");
              #endif
 387   4                                      if (return_sound_table() == 1)
 388   4                                      {
 389   5                                              GD5800_select_chapter(CHENGGONG);
 390   5      
 391   5                                              set_sound_table(0);
 392   5                                      }
 393   4                                      return 1;
 394   4                                      //ÌáÊ¾³É¹¦                              
 395   4                              }
 396   3                      }
 397   2              }
 398   1              return 0;
 399   1      }
 400          
 401          bit register_alarm_function(unsigned char *buf)
 402          {
 403   1              unsigned char base_address = 0;//»ù×¼µØÖ·   
 404   1              unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 405   1              //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 406   1              /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 407   1              for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)    //32*32 =1024¸ö±êÖ¾Î
             -»
 408   1              {
 409   2                      IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 8   

 410   2                      delay10ms();
 411   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 412   2                      {
 413   3                              if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 414   3                              {
 415   4                                      IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);
 416   4                                      delay10ms();
 417   4      
 418   4                                      if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) ==
             - *(buf + 7)))
 419   4                                      {
 420   5                                              //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 421   5                                              Two_Menu_F1_E3[0] = *(eeprom_buff + 1);
 422   5                                              Two_Menu_F1_E3[1] = *(eeprom_buff + 2);
 423   5                                              Two_Menu_F1_E3[2] = *(eeprom_buff + 3);
 424   5                                              Two_Menu_F1_E3[3] = *(eeprom_buff + 4);
 425   5      #ifdef DEBUG
                                                      uart_printf("alarmer register is old! \n\r");
              #endif
 428   5      
 429   5                                              if (return_sound_table() == 1)
 430   5                                              {
 431   6                                                      GD5800_select_chapter(SHIBAI);
 432   6      
 433   6                                                      set_sound_table(0);
 434   6                                              }
 435   5                                              return 0;
 436   5                                      }
 437   4                              }
 438   3                      }
 439   2              }
 440   1              //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 441   1              for (base_address = 0; base_address<ALARM_TABLE_NUMBER; base_address++)
 442   1              {
 443   2                      IRcvStr(I2C_ADDRESS, ALARM_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C6
             -4ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±êÖ¾Î»
 444   2                      delay10ms();
 445   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 446   2                      {
 447   3                              if (at24c64_buff[offset_address] != 0)
 448   3                              {
 449   4                                      ISendStr(I2C_ADDRESS, (ALARM_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8);
 450   4                                      delay10ms();
 451   4                                      at24c64_buff[offset_address] = 0;
 452   4                                      ISendStr(I2C_ADDRESS,ALARM_TABLE_START+base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 453   4                                      delay10ms();
 454   4                                      //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 455   4      #ifdef DEBUG
                                              uart_printf("alarmer register is new! \n\r");
                                              uart_printf("±êÖ¾µØÖ·Îª %x ! \n\r", ALARM_TABLE_START + base_address*PAGE_LENGTH);
                                              uart_printf("´æ´¢µØÖ·Îª %x ! \n\r", ALARM_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) *
             - 8);
              #endif
 460   4                                      if (return_sound_table() == 1)
 461   4                                      {
 462   5                                              GD5800_select_chapter(CHENGGONG);
 463   5      
 464   5                                              set_sound_table(0);
 465   5                                      }
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 9   

 466   4                                      return 1;
 467   4                                      //ÌáÊ¾³É¹¦                              
 468   4                              }
 469   3                      }
 470   2              }
 471   1              return 0;
 472   1      }
 473          
 474          bit register_cancel_function(unsigned char *buf)
 475          {
 476   1              unsigned char base_address = 0;//»ù×¼µØÖ·   
 477   1              unsigned char offset_address = 0;//Æ«ÒÆµØÖ·
 478   1              //µØÖ·=  »ù×¼µØÖ·*32 +Æ«ÒÆµØÖ·
 479   1              /*ÏÈÑ°ÕÒÕâ¸öIDÂëÊÇ·ñ´æÔÚ*/
 480   1              for (base_address = CALL_TABLE_START; base_address<ALL_TABLE_NUMBER; base_address++)    //32*32 =1024¸ö±êÖ¾Î
             -»
 481   1              {
 482   2                      IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C256ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ
             -±êÖ¾Î»
 483   2                      delay10ms();
 484   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 485   2                      {
 486   3                              if (at24c64_buff[offset_address] == 0) //Èç¹û±êÖ¾Î»µÈÓÚ0  ÔòÕÒÕÒ¿´ Õâ¸öIDÂëÊÇ·ñ×¢²á¹ý
 487   3                              {
 488   4                                      IRcvStr(I2C_ADDRESS, (CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);
 489   4                                      delay10ms();
 490   4      
 491   4                                      if ((*(eeprom_buff + 5) == *(buf + 5)) && (*(eeprom_buff + 6) == *(buf + 6)) && (*(eeprom_buff + 7) ==
             - *(buf + 7)))
 492   4                                      {
 493   5                                              //IFÌõ¼þ³ÉÁ¢ ÔòÕâ¸öIDÂë×¢²á¹ý
 494   5                                              Two_Menu_F1_E4[0] = *(eeprom_buff + 1);
 495   5                                              Two_Menu_F1_E4[1] = *(eeprom_buff + 2);
 496   5                                              Two_Menu_F1_E4[2] = *(eeprom_buff + 3);
 497   5                                              Two_Menu_F1_E4[3] = *(eeprom_buff + 4);
 498   5      #ifdef DEBUG
                                                      uart_printf("canceler register is old! \n\r");
              #endif
 501   5      
 502   5                                              if (return_sound_table() == 1)
 503   5                                              {
 504   6                                                      GD5800_select_chapter(SHIBAI);
 505   6      
 506   6                                                      set_sound_table(0);
 507   6                                              }
 508   5                                              return 0;
 509   5                                      }
 510   4                              }
 511   3                      }
 512   2              }
 513   1              //Èç¹û³ÌÐòÖ´ÐÐµ½ÕâÀï£¬Ôò´ú±íIDÂëÃ»ÓÐ×¢²á¹ý
 514   1              for (base_address = 0; base_address<CANCEL_TABLE_NUMBER; base_address++)
 515   1              {
 516   2                      IRcvStr(I2C_ADDRESS, CANCEL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);//´ÓAT24C
             -64ÀïÃæ¶Á³ö32¸ö×Ö½ÚµÄ±êÖ¾Î»
 517   2                      delay10ms();
 518   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½Ú±êÖ¾Î»ÀïÃæÃ»ÓÐ0µÄ¾ÍO
             -K
 519   2                      {
 520   3                              if (at24c64_buff[offset_address] != 0)
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 10  

 521   3                              {
 522   4                                      ISendStr(I2C_ADDRESS, (CANCEL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) * 8), buf, 8)
             -;
 523   4                                      delay10ms();
 524   4                                      at24c64_buff[offset_address] = 0;
 525   4                                      ISendStr(I2C_ADDRESS,CANCEL_TABLE_START+base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 526   4                                      delay10ms();
 527   4                                      //½«±êÖ¾Î»ÒÔ¼°Êý¾Ý·Ö±ðÐ´µ½±êÖ¾Çø¸úÊý¾ÝÇø
 528   4      #ifdef DEBUG
                                              uart_printf("canceler register is new! \n\r");
                                              uart_printf("±êÖ¾µØÖ·Îª %x ! \n\r", CANCEL_TABLE_START + base_address*PAGE_LENGTH);
                                              uart_printf("´æ´¢µØÖ·Îª %x ! \n\r", CANCEL_DATA_START + ((base_address*PAGE_LENGTH) + offset_address) 
             -* 8);
              #endif
 533   4                                      if (return_sound_table() == 1)
 534   4                                      {
 535   5                                              GD5800_select_chapter(CHENGGONG);
 536   5      
 537   5                                              set_sound_table(0);
 538   5                                      }
 539   4                                      return 1;
 540   4                                      //ÌáÊ¾³É¹¦                              
 541   4                              }
 542   3                      }
 543   2              }
 544   1              return 0;
 545   1      }
 546          
 547          bit delete_call_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 548          {
 549   1              unsigned char base_address = 0;
 550   1              unsigned char offset_address = 0;
 551   1      
 552   1              for (base_address = 0; base_address<CALL_TABLE_NUMBER; base_address++)
 553   1              {
 554   2                      IRcvStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸ö±êÖ¾Î»
 555   2                      delay10ms();
 556   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 557   2                      {
 558   3                              if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 559   3                              {
 560   4                                      at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 561   4      #ifdef DEBUG
                                              uart_printf("caller is delete success \r\n");
              #endif          
 564   4                              }
 565   3                              else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 566   3                              {
 567   4                                      IRcvStr(I2C_ADDRESS, ( CALL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff
             -, 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 568   4                                      delay10ms();
 569   4                                      if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 570   4                                      {
 571   5                                              at24c64_buff[offset_address] = 0xff;
 572   5                                              ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 573   5                                              delay10ms();
 574   5                                              //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 575   5      #ifdef DEBUG
                                                      uart_printf("call is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(eepr
             -om_buff + 6)), (unsigned int)(*(eeprom_buff + 7)) ); //
                                                      uart_printf("call is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(*(
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 11  

             -eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)) );
                                                      uart_printf("caller is delete success \r\n");
              #endif          
 580   5                                      }
 581   4      
 582   4                              }
 583   3                      }
 584   2                      ISendStr(I2C_ADDRESS, base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 585   2                      //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 586   2                      delay10ms();
 587   2              }
 588   1              return 1;
 589   1      }
 590          
 591          bit delete_host_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 592          {
 593   1              unsigned char base_address = 0;
 594   1              unsigned char offset_address = 0;
 595   1      
 596   1              for (base_address = 0 ; base_address< HOST_TABLE_NUMBER ; base_address++)
 597   1              {
 598   2                      IRcvStr(I2C_ADDRESS, HOST_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸ö
             -±êÖ¾Î»
 599   2                      delay10ms();
 600   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 601   2                      {
 602   3                              if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 603   3                              {
 604   4                                      at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 605   4      #ifdef DEBUG
                                              uart_printf("hoster is delete success \r\n");
              #endif          
 608   4                              }
 609   3                              else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 610   3                              {
 611   4                                      IRcvStr(I2C_ADDRESS, (HOST_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff,
             - 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 612   4                                      delay10ms();
 613   4                                      if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 614   4                                      {
 615   5                                              at24c64_buff[offset_address] = 0xff;
 616   5                                              ISendStr(I2C_ADDRESS, HOST_TABLE_START+base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 617   5                                              delay10ms();
 618   5                                              //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 619   5      #ifdef DEBUG
                                                      uart_printf("host is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(eepr
             -om_buff + 6)), (unsigned int)(*(eeprom_buff + 7))); //
                                                      uart_printf("host is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(*(
             -eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)));
                                                      uart_printf("host is delete success \r\n");
              #endif          
 624   5                                      }
 625   4      
 626   4                              }
 627   3                      }
 628   2                      ISendStr(I2C_ADDRESS, HOST_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 629   2                      //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 630   2                      delay10ms();
 631   2              }
 632   1              return 1;
 633   1      }
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 12  

 634          
 635          bit delete_alarm_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 636          {
 637   1              unsigned char base_address = 0;
 638   1              unsigned char offset_address = 0;
 639   1      
 640   1              for (base_address = 0; base_address<ALARM_TABLE_NUMBER; base_address++)
 641   1              {
 642   2                      IRcvStr(I2C_ADDRESS, ALARM_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32¸
             -ö±êÖ¾Î»
 643   2                      delay10ms();
 644   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 645   2                      {
 646   3                              if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 647   3                              {
 648   4                                      at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 649   4      #ifdef DEBUG
                                              uart_printf("alarmer is delete success \r\n");
              #endif          
 652   4                              }
 653   3                              else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 654   3                              {
 655   4                                      IRcvStr(I2C_ADDRESS, (ALARM_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buff
             -, 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 656   4                                      delay10ms();
 657   4                                      if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 658   4                                      {
 659   5                                              at24c64_buff[offset_address] = 0xff;
 660   5                                              ISendStr(I2C_ADDRESS, ALARM_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 661   5                                              delay10ms();
 662   5                                              //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 663   5      #ifdef DEBUG
                                                      uart_printf("alarm is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(eep
             -rom_buff + 6)), (unsigned int)(*(eeprom_buff + 7))); //
                                                      uart_printf("alarm is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(*
             -(eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)));
                                                      uart_printf("alarm is delete success \r\n");
              #endif          
 668   5                                      }
 669   4      
 670   4                              }
 671   3                      }
 672   2                      ISendStr(I2C_ADDRESS, ALARM_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 673   2                      //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 674   2                      delay10ms();
 675   2              }
 676   1              return 1;
 677   1      }
 678          
 679          bit delete_cancel_function(unsigned char *buf)//bufÎª×éÂëÊý×éµÄÖ¸Õë
 680          {
 681   1              unsigned char base_address = 0;
 682   1              unsigned char offset_address = 0;
 683   1      
 684   1              for (base_address = 0; base_address<CANCEL_TABLE_NUMBER; base_address++)
 685   1              {
 686   2                      IRcvStr(I2C_ADDRESS, CANCEL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH); //È¡³ö32
             -¸ö±êÖ¾Î»
 687   2                      delay10ms();
 688   2                      for (offset_address = 0; offset_address<PAGE_LENGTH; offset_address++)//Ö÷Òª32¸ö×Ö½ÚÀïÃæÃ»ÓÐ0µÄ¾ÍOK
 689   2                      {
C51 COMPILER V9.00   AT24C256                                                              10/16/2015 16:55:00 PAGE 13  

 690   3                              if (*(buf) == 0 && *(buf + 1) == 0 && *(buf + 2) == 0 && *(buf + 3) == 0) //È«²¿É¾³ý
 691   3                              {
 692   4                                      at24c64_buff[offset_address] = 0xff;//±êÖ¾Î»ÉèÖÃÎª·Ç0
 693   4      #ifdef DEBUG
                                              uart_printf("canceler is delete success \r\n");
              #endif          
 696   4                              }
 697   3                              else if (at24c64_buff[offset_address] == 0)//Èç¹û²»ÊÇ0000 ÔòÎÞÐèÈ«²¿É¾³ý
 698   3                              {
 699   4                                      IRcvStr(I2C_ADDRESS, (CANCEL_DATA_START + (base_address*PAGE_LENGTH + offset_address) * 8), eeprom_buf
             -f, 8);//È¡³ö¶ÔÓ¦±êÖ¾Î»Ëù¶ÔÓ¦µÄÊý¾ÝÇøµÄÊý¾Ý
 700   4                                      delay10ms();
 701   4                                      if ((*(eeprom_buff + 1) == *(buf + 0)) && (*(eeprom_buff + 2) == *(buf + 1)) && (*(eeprom_buff + 3) ==
             - *(buf + 2)) && (*(eeprom_buff + 4) == *(buf + 3)))
 702   4                                      {
 703   5                                              at24c64_buff[offset_address] = 0xff;
 704   5                                              ISendStr(I2C_ADDRESS, CANCEL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 705   5                                              delay10ms();
 706   5                                              //Çå³ý¶ÔÓ¦µÄ±êÖ¾Î» È»ºóÔÙ½«±êÖ¾Î»Ð´Èë±êÖ¾Çø
 707   5      #ifdef DEBUG
                                                      uart_printf("cancel is %02x %02x %02x .\r\n", (unsigned int)(*(eeprom_buff + 5)), (unsigned int)(*(ee
             -prom_buff + 6)), (unsigned int)(*(eeprom_buff + 7))); //
                                                      uart_printf("cancel is %02x %02x %02x %02x.\r\n", (unsigned int)(*(eeprom_buff + 1)), (unsigned int)(
             -*(eeprom_buff + 2)), (unsigned int)(*(eeprom_buff + 3)), (unsigned int)(*(eeprom_buff + 4)));
                                                      uart_printf("cancel is delete success \r\n");
              #endif          
 712   5                                      }
 713   4      
 714   4                              }
 715   3                      }
 716   2                      ISendStr(I2C_ADDRESS, CANCEL_TABLE_START + base_address*PAGE_LENGTH, at24c64_buff, PAGE_LENGTH);
 717   2                      //×îºó½«32¸ö±êÖ¾Î»Ð´Èë±êÖ¾Çø
 718   2                      delay10ms();
 719   2              }
 720   1              return 1;
 721   1      }
 722          
 723          void Delete_all_data(void)
 724          {
 725   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 726   1              unsigned int k;
 727   1              for (k = CALL_TABLE_START ; k<ALL_TABLE_NUMBER; k++)
 728   1              {
 729   2                      ISendStr(I2C_ADDRESS, k * 32, dofly, PAGE_LENGTH);                   //Ð´Èë24c02
 730   2                      delay10ms();
 731   2              }
 732   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3600    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =     40      88
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
