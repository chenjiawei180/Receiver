C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE AT24C256
OBJECT MODULE PLACED IN at24c256.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\at24c256.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRIN
                    -T(.\at24c256.lst) OBJECT(at24c256.obj)

line level    source

   1          #include "at24c256.h"
   2          #include "key.h"
   3          #include "usart.h"
   4          #include "menu.h"
   5          #include "gd5800.h"
   6          
   7          bit ack;                      //应答标志位
   8          Env_t   EEPROM;
   9          void DelayUs2x(unsigned char t)
  10          {
  11   1              while (--t);
  12   1      }
  13          /*------------------------------------------------
  14          mS延时函数，含有输入参数 unsigned char t，无返回值
  15          unsigned char 是定义无符号字符变量，其值的范围是
  16          0~255 这里使用晶振12M，精确延时请使用汇编
  17          ------------------------------------------------*/
  18          void DelayMs(unsigned char t)
  19          {
  20   1              while (t--)
  21   1              {
  22   2                      //大致延时1mS
  23   2                      DelayUs2x(245);
  24   2                      DelayUs2x(245);
  25   2              }
  26   1      }
  27          
  28          
  29          /*------------------------------------------------
  30          启动总线
  31          ------------------------------------------------*/
  32          void Start_I2c()
  33          {
  34   1              SDA = 1;   //发送起始条件的数据信号
  35   1              _Nop();
  36   1              SCL = 1;
  37   1              _Nop();    //起始条件建立时间大于4.7us,延时
  38   1              _Nop();
  39   1              _Nop();
  40   1              _Nop();
  41   1              _Nop();
  42   1              SDA = 0;     //发送起始信号
  43   1              _Nop();    //起始条件锁定时间大于4μ
  44   1              _Nop();
  45   1              _Nop();
  46   1              _Nop();
  47   1              _Nop();
  48   1              SCL = 0;    //钳住I2C总线，准备发送或接收数据
  49   1              _Nop();
  50   1              _Nop();
  51   1      }
  52          /*------------------------------------------------
  53          结束总线
  54          ------------------------------------------------*/
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 2   

  55          void Stop_I2c()
  56          {
  57   1              SDA = 0;    //发送结束条件的数据信号
  58   1              _Nop();   //发送结束条件的时钟信号
  59   1              SCL = 1;    //结束条件建立时间大于4μ
  60   1              _Nop();
  61   1              _Nop();
  62   1              _Nop();
  63   1              _Nop();
  64   1              _Nop();
  65   1              SDA = 1;    //发送I2C总线结束信号
  66   1              _Nop();
  67   1              _Nop();
  68   1              _Nop();
  69   1              _Nop();
  70   1      }
  71          
  72          /*----------------------------------------------------------------
  73          字节数据传送函数
  74          函数原型: void  SendByte(unsigned char c);
  75          功能:  将数据c发送出去,可以是地址,也可以是数据,发完后等待应答,并对
  76          此状态位进行操作.(不应答或非应答都使ack=0 假)
  77          发送数据正常，ack=1; ack=0表示被控器无应答或损坏。
  78          ------------------------------------------------------------------*/
  79          void  SendByte(unsigned char c)
  80          {
  81   1              unsigned char BitCnt;
  82   1              for (BitCnt = 0; BitCnt<8; BitCnt++)  //要传送的数据长度为8位
  83   1              {
  84   2                      if ((c << BitCnt) & 0x80)
  85   2                              SDA = 1;   //判断发送位
  86   2                      else
  87   2                              SDA = 0;
  88   2                      _Nop();
  89   2                      SCL = 1;               //置时钟线为高，通知被控器开始接收数据位
  90   2                      _Nop();
  91   2                      _Nop();             //保证时钟高电平周期大于4μ
  92   2                      _Nop();
  93   2                      _Nop();
  94   2                      _Nop();
  95   2                      SCL = 0;
  96   2              }
  97   1              _Nop();
  98   1              _Nop();
  99   1              SDA = 1;               //8位发送完后释放数据线，准备接收应答位
 100   1              _Nop();
 101   1              _Nop();
 102   1              SCL = 1;
 103   1              _Nop();
 104   1              _Nop();
 105   1              _Nop();
 106   1              if (SDA == 1)ack = 0;
 107   1              else ack = 1;        //判断是否接收到应答信号
 108   1              SCL = 0;
 109   1              _Nop();
 110   1              _Nop();
 111   1      }
 112          
 113          /*----------------------------------------------------------------
 114          字节数据传送函数
 115          函数原型: unsigned char  RcvByte();
 116          功能:  用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 3   

 117          发完后请用应答函数。
 118          ------------------------------------------------------------------*/
 119          unsigned char  RcvByte()
 120          {
 121   1              unsigned char retc;
 122   1              unsigned char BitCnt;
 123   1              retc = 0;
 124   1              SDA = 1;             //置数据线为输入方式
 125   1              for (BitCnt = 0; BitCnt<8; BitCnt++)
 126   1              {
 127   2                      _Nop();
 128   2                      SCL = 0;       //置时钟线为低，准备接收数据位
 129   2                      _Nop();
 130   2                      _Nop();      //时钟低电平周期大于4.7us
 131   2                      _Nop();
 132   2                      _Nop();
 133   2                      _Nop();
 134   2                      SCL = 1;       //置时钟线为高使数据线上数据有效
 135   2                      _Nop();
 136   2                      _Nop();
 137   2                      retc = retc << 1;
 138   2                      if (SDA == 1)retc = retc + 1; //读数据位,接收的数据位放入retc中
 139   2                      _Nop();
 140   2                      _Nop();
 141   2              }
 142   1              SCL = 0;
 143   1              _Nop();
 144   1              _Nop();
 145   1              return(retc);
 146   1      }
 147          
 148          
 149          /*----------------------------------------------------------------
 150          应答子函数
 151          原型:  void Ack_I2c(void);
 152          
 153          ----------------------------------------------------------------*/
 154          void Ack_I2c(void)
 155          {
 156   1              SDA = 0;
 157   1              _Nop();
 158   1              _Nop();
 159   1              _Nop();
 160   1              SCL = 1;
 161   1              _Nop();
 162   1              _Nop();              //时钟低电平周期大于4μ
 163   1              _Nop();
 164   1              _Nop();
 165   1              _Nop();
 166   1              SCL = 0;               //清时钟线，钳住I2C总线以便继续接收
 167   1              _Nop();
 168   1              _Nop();
 169   1      }
 170          
 171          /*----------------------------------------------------------------
 172          非应答子函数
 173          原型:  void NoAck_I2c(void);
 174          
 175          ----------------------------------------------------------------*/
 176          void NoAck_I2c(void)
 177          {
 178   1              SDA = 1;
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 4   

 179   1              _Nop();
 180   1              _Nop();
 181   1              _Nop();
 182   1              SCL = 1;
 183   1              _Nop();
 184   1              _Nop();              //时钟低电平周期大于4μ
 185   1              _Nop();
 186   1              _Nop();
 187   1              _Nop();
 188   1              SCL = 0;                //清时钟线，钳住I2C总线以便继续接收
 189   1              _Nop();
 190   1              _Nop();
 191   1      }
 192          
 193          /*----------------------------------------------------------------
 194          向有子地址器件发送多字节数据函数
 195          函数原型: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 196          功能:     从启动总线到发送地址，子地址,数据，结束总线的全过程,从器件
 197          地址sla，子地址suba，发送内容是s指向的内容，发送no个字节。
 198          如果返回1表示操作成功，否则操作有误。
 199          注意：    使用前必须已结束总线。
 200          ----------------------------------------------------------------*/
 201          bit ISendStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 202          {
 203   1              unsigned char i;
 204   1              Start_I2c();               //启动总线
 205   1              SendByte(sla);             //发送器件地址
 206   1              if (ack == 0)return(0);
 207   1              SendByte(suba >> 8);            //发送器件子地址
 208   1              if (ack == 0)return(0);
 209   1              SendByte(suba);
 210   1              if (ack == 0)return(0);
 211   1              for (i = 0; i<no; i++)
 212   1              {
 213   2                      SendByte(*s);            //发送数据
 214   2                      if (ack == 0)return(0);
 215   2                      s++;
 216   2              }
 217   1              Stop_I2c();                  //结束总线
 218   1              return(1);
 219   1      }
 220          
 221          
 222          /*----------------------------------------------------------------
 223          向有子地址器件读取多字节数据函数
 224          函数原型: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 225          功能:     从启动总线到发送地址，子地址,读数据，结束总线的全过程,从器件
 226          地址sla，子地址suba，读出的内容放入s指向的存储区，读no个字节。
 227          如果返回1表示操作成功，否则操作有误。
 228          注意：    使用前必须已结束总线。
 229          ----------------------------------------------------------------*/
 230          bit IRcvStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 231          {
 232   1              unsigned char i;
 233   1              Start_I2c();               //启动总线
 234   1              SendByte(sla);             //发送器件地址
 235   1              if (ack == 0)return(0);
 236   1              SendByte(suba >> 8);            //发送器件子地址
 237   1              if (ack == 0)return(0);
 238   1              SendByte(suba);            //发送器件子地址
 239   1              if (ack == 0)return(0);
 240   1              Start_I2c();
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 5   

 241   1              SendByte(sla + 1);
 242   1              if (ack == 0)return(0);
 243   1              for (i = 0; i<no - 1; i++)
 244   1              {
 245   2                      *s = RcvByte();              //发送数据
 246   2                      Ack_I2c();                //发送就答位 
 247   2                      s++;
 248   2              }
 249   1              *s = RcvByte();
 250   1              NoAck_I2c();                 //发送非应位
 251   1              Stop_I2c();                    //结束总线
 252   1              return(1);
 253   1      }
 254          
 255          bit register_call_function(RF_def *pRF)
 256          {
 257   1              uint16_t addr;
 258   1              uint16_t i;
 259   1              RF_def RFtmp;
 260   1              uint16_t tmp = 0;
 261   1              addr = CALL_DATA_START;
 262   1      
 263   1              for (i = 0; i < CALL_NUMBER; i++)
 264   1              {
 265   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 266   2      
 267   2                      if (!(RFtmp.rf & 0xff000000))
 268   2                      {
 269   3      
 270   3                              if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 271   3                              {
 272   4                                      RFtmp.rf &= 0x00fffff0;
 273   4                                      pRF->rf &= 0x00fffff0;
 274   4                              }
 275   3      
 276   3                              if (RFtmp.rf == pRF->rf)    //有相等RF在里面，重新覆盖
 277   3                              {
 278   4                                      memcpy(Two_Menu_F1_E1, RFtmp.region, 4);
 279   4                                      Two_Menu_F1_E1[4] = 0;
 280   4                                      if (return_sound_table() == 1)
 281   4                                      {
 282   5                                              GD5800_select_chapter(SHIBAI);
 283   5      
 284   5                                              set_sound_table(0);
 285   5                                      }
 286   4                                      return 1;
 287   4                              }
 288   3                      }
 289   2                      else
 290   2                      {
 291   3                              if (!tmp) tmp = addr;
 292   3                      }
 293   2                      addr += sizeof(RF_def);
 294   2              }
 295   1              ISendStr(I2C_ADDRESS, tmp, (uint8_t *)pRF, sizeof(RF_def));
 296   1              if (return_sound_table() == 1)
 297   1              {
 298   2                      GD5800_select_chapter(CHENGGONG);
 299   2      
 300   2                      set_sound_table(0);
 301   2              }
 302   1              //EEP_WriteBytes(tmp, (uint8_t *)pRF, sizeof(RF_def));
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 6   

 303   1              return 0;
 304   1      }
 305          
 306          
 307          bit register_host_function(RF_def *pRF)
 308          {
 309   1              uint16_t addr;
 310   1              uint16_t i;
 311   1              RF_def RFtmp;
 312   1              uint16_t tmp = 0;
 313   1              addr = HOST_DATA_START;
 314   1      
 315   1              for (i = 0; i < HOST_NUMBER; i++)
 316   1              {
 317   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 318   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 319   2      
 320   2                      if (!(RFtmp.rf & 0xff000000))
 321   2                      {
 322   3      
 323   3                              if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 324   3                              {
 325   4                                      RFtmp.rf &= 0x00fffff0;
 326   4                                      pRF->rf &= 0x00fffff0;
 327   4                              }
 328   3      
 329   3                              if (RFtmp.rf == pRF->rf)    //有相等RF在里面，重新覆盖
 330   3                              {
 331   4                                      memcpy(Two_Menu_F1_E2, RFtmp.region, 4);
 332   4                                      Two_Menu_F1_E2[4] = 0;
 333   4                                      if (return_sound_table() == 1)
 334   4                                      {
 335   5                                              GD5800_select_chapter(SHIBAI);
 336   5      
 337   5                                              set_sound_table(0);
 338   5                                      }
 339   4                                      return 1;
 340   4                              }
 341   3                      }
 342   2                      else
 343   2                      {
 344   3                              if (!tmp) tmp = addr;
 345   3                      }
 346   2                      addr += sizeof(RF_def);
 347   2              }
 348   1              ISendStr(I2C_ADDRESS, tmp, (uint8_t *)pRF, sizeof(RF_def));
 349   1              //EEP_WriteBytes(tmp, (uint8_t *)pRF, sizeof(RF_def));
 350   1              if (return_sound_table() == 1)
 351   1              {
 352   2                      GD5800_select_chapter(CHENGGONG);
 353   2      
 354   2                      set_sound_table(0);
 355   2              }
 356   1              return 0;
 357   1      }
 358          
 359          bit register_alarm_function(RF_def *pRF)
 360          {
 361   1              uint16_t addr;
 362   1              uint16_t i;
 363   1              RF_def RFtmp;
 364   1              uint16_t tmp = 0;
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 7   

 365   1              addr = ALARM_DATA_START;
 366   1      
 367   1              for (i = 0; i < ALARM_NUMBER; i++)
 368   1              {
 369   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 370   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 371   2      
 372   2                      if (!(RFtmp.rf & 0xff000000))
 373   2                      {
 374   3      
 375   3                              if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 376   3                              {
 377   4                                      RFtmp.rf &= 0x00fffff0;
 378   4                                      pRF->rf &= 0x00fffff0;
 379   4                              }
 380   3      
 381   3                              if (RFtmp.rf == pRF->rf)    //有相等RF在里面，重新覆盖
 382   3                              {
 383   4                                      memcpy(Two_Menu_F1_E3, RFtmp.region, 4);
 384   4                                      Two_Menu_F1_E3[4] = 0;
 385   4                                      if (return_sound_table() == 1)
 386   4                                      {
 387   5                                              GD5800_select_chapter(SHIBAI);
 388   5      
 389   5                                              set_sound_table(0);
 390   5                                      }
 391   4                                      return 1;
 392   4                              }
 393   3                      }
 394   2                      else
 395   2                      {
 396   3                              if (!tmp) tmp = addr;
 397   3                      }
 398   2                      addr += sizeof(RF_def);
 399   2              }
 400   1              ISendStr(I2C_ADDRESS, tmp, (uint8_t *)pRF, sizeof(RF_def));
 401   1              //EEP_WriteBytes(tmp, (uint8_t *)pRF, sizeof(RF_def));
 402   1              if (return_sound_table() == 1)
 403   1              {
 404   2                      GD5800_select_chapter(CHENGGONG);
 405   2      
 406   2                      set_sound_table(0);
 407   2              }
 408   1              return 0;
 409   1      }
 410          
 411          bit register_cancel_function(RF_def *pRF)
 412          {
 413   1              uint16_t addr;
 414   1              uint16_t i;
 415   1              RF_def RFtmp;
 416   1              uint16_t tmp = 0;
 417   1              addr = CANCEL_DATA_START;
 418   1      
 419   1              for (i = 0; i < CANCEL_NUMBER; i++)
 420   1              {
 421   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 422   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 423   2      
 424   2                      if (!(RFtmp.rf & 0xff000000))
 425   2                      {
 426   3      
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 8   

 427   3                              if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 428   3                              {
 429   4                                      RFtmp.rf &= 0x00fffff0;
 430   4                                      pRF->rf &= 0x00fffff0;
 431   4                              }
 432   3      
 433   3                              if (RFtmp.rf == pRF->rf)    //有相等RF在里面，重新覆盖
 434   3                              {
 435   4                                      memcpy(Two_Menu_F1_E4, RFtmp.region, 4);
 436   4                                      Two_Menu_F1_E4[4] = 0;
 437   4                                      if (return_sound_table() == 1)
 438   4                                      {
 439   5                                              GD5800_select_chapter(SHIBAI);
 440   5      
 441   5                                              set_sound_table(0);
 442   5                                      }
 443   4                                      return 1;
 444   4                              }
 445   3                      }
 446   2                      else
 447   2                      {
 448   3                              if (!tmp) tmp = addr;
 449   3                      }
 450   2                      addr += sizeof(RF_def);
 451   2              }
 452   1              ISendStr(I2C_ADDRESS, tmp, (uint8_t *)pRF, sizeof(RF_def));
 453   1              //EEP_WriteBytes(tmp, (uint8_t *)pRF, sizeof(RF_def));
 454   1              if (return_sound_table() == 1)
 455   1              {
 456   2                      GD5800_select_chapter(CHENGGONG);
 457   2      
 458   2                      set_sound_table(0);
 459   2              }
 460   1              return 0;
 461   1      }
 462          
 463          bit delete_call_function(unsigned char *buf)//buf为组码数组的指针
 464          {
 465   1              RF_def RFtmp;
 466   1              uint16_t addr = CALL_DATA_START;
 467   1              uint16_t i;
 468   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 469   1              if (*(volatile uint32_t*)buf == 0x00000000ul)
 470   1              {
 471   2                      for (i = 0; i<128; i++)
 472   2                      {
 473   3                              ISendStr(I2C_ADDRESS, i << 5, dofly, 32);                   //写入24c02
 474   3                              delay10ms();
 475   3                      }
 476   2      
 477   2              }
 478   1              else
 479   1              {
 480   2                      for (i = 0; i < CALL_NUMBER; i++)
 481   2                      {
 482   3                              IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 483   3                              //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 484   3                              if (!(RFtmp.rf & 0xff000000ul))
 485   3                              {
 486   4                                      if (*(volatile uint32_t*)buf == *(volatile uint32_t*)(RFtmp.region))
 487   4                                      {
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 9   

 488   5                                              memset(&RFtmp, 0xff, sizeof(RF_def));
 489   5                                              ISendStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 490   5                                              //EEP_WriteBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 491   5                                              break;
 492   5                                      }
 493   4                              }
 494   3                              addr += sizeof(RF_def);
 495   3                      }
 496   2              }
 497   1              return 0;
 498   1      }
 499          
 500          bit delete_host_function(unsigned char *buf)//buf为组码数组的指针
 501          {
 502   1              RF_def RFtmp;
 503   1              uint16_t addr = HOST_DATA_START;
 504   1              uint16_t i;
 505   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 506   1              if (*(volatile uint32_t*)buf == 0x00000000ul)
 507   1              {
 508   2                      for (i = 0; i<8; i++)
 509   2                      {
 510   3                              ISendStr(I2C_ADDRESS, addr+( i << 5), dofly, 32);                   //写入24c02
 511   3                              delay10ms();
 512   3                      }
 513   2      
 514   2              }
 515   1              else
 516   1              {
 517   2                      for (i = 0; i < HOST_NUMBER; i++)
 518   2                      {
 519   3                              IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 520   3                              //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 521   3                              if (!(RFtmp.rf & 0xff000000ul))
 522   3                              {
 523   4                                      if (*(volatile uint32_t*)buf == *(volatile uint32_t*)(RFtmp.region))
 524   4                                      {
 525   5                                              memset(&RFtmp, 0xff, sizeof(RF_def));
 526   5                                              ISendStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 527   5                                              //EEP_WriteBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 528   5                                              break;
 529   5                                      }
 530   4                              }
 531   3                              addr += sizeof(RF_def);
 532   3                      }
 533   2              }
 534   1              return 0;
 535   1      }
 536          
 537          bit delete_alarm_function(unsigned char *buf)//buf为组码数组的指针
 538          {
 539   1              RF_def RFtmp;
 540   1              uint16_t addr = ALARM_DATA_START;
 541   1              uint16_t i;
 542   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 543   1              if (*(volatile uint32_t*)buf == 0x00000000ul)
 544   1              {
 545   2                      for (i = 0; i<16; i++)
 546   2                      {
 547   3                              ISendStr(I2C_ADDRESS, addr + (i << 5), dofly, 32);                   //写入24c02
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 10  

 548   3                              delay10ms();
 549   3                      }
 550   2      
 551   2              }
 552   1              else
 553   1              {
 554   2                      for (i = 0; i < ALARM_NUMBER; i++)
 555   2                      {
 556   3                              IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 557   3                              //      EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 558   3                              if (!(RFtmp.rf & 0xff000000ul))
 559   3                              {
 560   4                                      if (*(volatile uint32_t*)buf == *(volatile uint32_t*)(RFtmp.region))
 561   4                                      {
 562   5                                              memset(&RFtmp, 0xff, sizeof(RF_def));
 563   5                                              ISendStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 564   5                                              //EEP_WriteBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 565   5                                              break;
 566   5                                      }
 567   4                              }
 568   3                              addr += sizeof(RF_def);
 569   3                      }
 570   2              }
 571   1              return 0;
 572   1      }
 573          
 574          bit delete_cancel_function(unsigned char *buf)//buf为组码数组的指针
 575          {
 576   1              RF_def RFtmp;
 577   1              uint16_t addr = CANCEL_DATA_START;
 578   1              uint16_t i;
 579   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 580   1              if (*(volatile uint32_t*)buf == 0x00000000ul)
 581   1              {
 582   2                      for (i = 0; i<16; i++)
 583   2                      {
 584   3                              ISendStr(I2C_ADDRESS, addr + (i << 5), dofly, 32);                   //写入24c02
 585   3                              delay10ms();
 586   3                      }
 587   2      
 588   2              }
 589   1              else
 590   1              {
 591   2                      for (i = 0; i < CANCEL_NUMBER; i++)
 592   2                      {
 593   3                              IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 594   3                              //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 595   3                              if (!(RFtmp.rf & 0xff000000ul))
 596   3                              {
 597   4                                      if (*(volatile uint32_t*)buf == *(volatile uint32_t*)(RFtmp.region))
 598   4                                      {
 599   5                                              memset(&RFtmp, 0xff, sizeof(RF_def));
 600   5                                              ISendStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 601   5                                              //EEP_WriteBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 602   5                                              break;
 603   5                                      }
 604   4                              }
 605   3                              addr += sizeof(RF_def);
 606   3                      }
 607   2              }
 608   1              return 0;
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 11  

 609   1      }
 610          
 611          void Delete_all_data(void)
 612          {
 613   1      //      uint8_t i,j;
 614   1      //      int8_t buf[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
             -0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 615   1      //      uint16_t addr = 0;
 616   1      //      int8_t buf1[32];
 617   1      ////    memset(buf, 0xff, sizeof(buf));
 618   1      //      addr = 0;
 619   1      //      for (i = 0; i<168; i++)
 620   1      //      {       
 621   1      //              addr = i << 5;
 622   1      //              ISendStr(I2C_ADDRESS, addr, buf, 32);
 623   1      //              delay10ms();
 624   1      //              //EEP_WriteBytes(addr, buf, sizeof(buf));
 625   1      //              //addr += 32;
 626   1      //      }
 627   1      //      uart_printf("24c read:");
 628   1      //      for (i = 0; i<168; i++)
 629   1      //      {
 630   1      //              IRcvStr(I2C_ADDRESS, addr, buf, 32);
 631   1      //              delay10ms();
 632   1      //              for (j = 0; j < 32; j++)
 633   1      //              {
 634   1      //                      uart_printf("%02x ", (unsigned int)buf[j]);
 635   1      //              }
 636   1      //              uart_printf("\n\r");
 637   1      //              //EEP_WriteBytes(addr, buf, sizeof(buf));
 638   1      //              addr += sizeof(buf);
 639   1      //      }
 640   1      
 641   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 642   1              unsigned int k;
 643   1              for (k = 0; k<168; k++)
 644   1              {
 645   2                      ISendStr(I2C_ADDRESS, k << 5, dofly, 32);                   //写入24c02
 646   2                      delay10ms();
 647   2              }
 648   1      }
 649          
 650          
 651          int8_t Find_RF_EEPROM_Call(RF_def *p, uint32_t dat)
 652          {
 653   1              RF_def RFtmp;
 654   1              uint16_t addr;
 655   1              uint16_t i;
 656   1              addr = CALL_DATA_START;
 657   1      
 658   1              for (i = 0; i<CALL_NUMBER; i++)
 659   1              {
 660   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 661   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 662   2      
 663   2                      if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 664   2                      {
 665   3                              RFtmp.rf &= 0x00fffff0;
 666   3                              dat &= 0x00fffff0;
 667   3                      }
 668   2      
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 12  

 669   2                      if (RFtmp.rf == dat)
 670   2                      {
 671   3                              memcpy(p, &RFtmp, sizeof(RF_def));
 672   3                              return 1;
 673   3                      }
 674   2                      addr += sizeof(RF_def);
 675   2              }
 676   1              return 0;
 677   1      }
 678          
 679          int8_t Find_RF_EEPROM_Host(RF_def *p, uint32_t dat)
 680          {
 681   1              RF_def RFtmp;
 682   1              uint16_t addr;
 683   1              uint16_t i;
 684   1              addr = HOST_DATA_START;
 685   1      
 686   1              for (i = 0; i<HOST_NUMBER; i++)
 687   1              {
 688   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 689   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 690   2      
 691   2                      if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 692   2                      {
 693   3                              RFtmp.rf &= 0x00fffff0;
 694   3                              dat &= 0x00fffff0;
 695   3                      }
 696   2      
 697   2                      if (RFtmp.rf == dat)
 698   2                      {
 699   3                              memcpy(p, &RFtmp, sizeof(RF_def));
 700   3                              return 1;
 701   3                      }
 702   2                      addr += sizeof(RF_def);
 703   2              }
 704   1              return 0;
 705   1      }
 706          
 707          int8_t Find_RF_EEPROM_Alarm(RF_def *p, uint32_t dat)
 708          {
 709   1              RF_def RFtmp;
 710   1              uint16_t addr;
 711   1              uint16_t i;
 712   1              addr = ALARM_DATA_START;
 713   1      
 714   1              for (i = 0; i<ALARM_NUMBER; i++)
 715   1              {
 716   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 717   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 718   2      
 719   2                      if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 720   2                      {
 721   3                              RFtmp.rf &= 0x00fffff0;
 722   3                              dat &= 0x00fffff0;
 723   3                      }
 724   2      
 725   2                      if (RFtmp.rf == dat)
 726   2                      {
 727   3                              memcpy(p, &RFtmp, sizeof(RF_def));
 728   3                              return 1;
 729   3                      }
 730   2                      addr += sizeof(RF_def);
C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 13  

 731   2              }
 732   1              return 0;
 733   1      }
 734          
 735          int8_t Find_RF_EEPROM_Cancel(RF_def *p, uint32_t dat)
 736          {
 737   1              RF_def RFtmp;
 738   1              uint16_t addr;
 739   1              uint16_t i;
 740   1              addr = CANCEL_DATA_START;
 741   1      
 742   1              for (i = 0; i<CANCEL_NUMBER; i++)
 743   1              {
 744   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 745   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 746   2      
 747   2                      if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 748   2                      {
 749   3                              RFtmp.rf &= 0x00fffff0;
 750   3                              dat &= 0x00fffff0;
 751   3                      }
 752   2      
 753   2                      if (RFtmp.rf == dat)
 754   2                      {
 755   3                              memcpy(p, &RFtmp, sizeof(RF_def));
 756   3                              return 1;
 757   3                      }
 758   2                      addr += sizeof(RF_def);
 759   2              }
 760   1              return 0;
 761   1      }
 762          
 763          int8_t Find_RF_EEPROM(RF_def *p, uint32_t dat)
 764          {
 765   1              if (Find_RF_EEPROM_Cancel(p, dat))
 766   1              {
 767   2                      return 1;
 768   2              }
 769   1              else if (Find_RF_EEPROM_Alarm(p, dat))
 770   1              {
 771   2                      return 2;
 772   2              }
 773   1              else if (Find_RF_EEPROM_Call(p, dat))
 774   1              {
 775   2                      return 3;
 776   2              }
 777   1              else
 778   1              {
 779   2                      return 0;
 780   2              }
 781   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3811    ----
   CONSTANT SIZE    =    160    ----
   XDATA SIZE       =     15     387
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.00   AT24C256                                                              10/30/2015 16:53:24 PAGE 14  


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
