C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE AT24C256
OBJECT MODULE PLACED IN at24c256.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\at24c256.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRIN
                    -T(.\at24c256.lst) OBJECT(at24c256.obj)

line level    source

   1          #include "at24c256.h"
   2          #include "key.h"
   3          #include "usart.h"
   4          #include "menu.h"
   5          #include "gd5800.h"
   6          
   7          bit ack;                      //应答标志位
   8          Env_t   EEPROM;
   9          void DelayUs2x(unsigned char t)
  10          {
  11   1              while (--t);
  12   1      }
  13          /*------------------------------------------------
  14          mS延时函数，含有输入参数 unsigned char t，无返回值
  15          unsigned char 是定义无符号字符变量，其值的范围是
  16          0~255 这里使用晶振12M，精确延时请使用汇编
  17          ------------------------------------------------*/
  18          void DelayMs(unsigned char t)
  19          {
  20   1              while (t--)
  21   1              {
  22   2                      //大致延时1mS
  23   2                      DelayUs2x(245);
  24   2                      DelayUs2x(245);
  25   2              }
  26   1      }
  27          
  28          
  29          /*------------------------------------------------
  30          启动总线
  31          ------------------------------------------------*/
  32          void Start_I2c()
  33          {
  34   1              SDA = 1;   //发送起始条件的数据信号
  35   1              _Nop();
  36   1              SCL = 1;
  37   1              _Nop();    //起始条件建立时间大于4.7us,延时
  38   1              _Nop();
  39   1              _Nop();
  40   1              _Nop();
  41   1              _Nop();
  42   1              SDA = 0;     //发送起始信号
  43   1              _Nop();    //起始条件锁定时间大于4μ
  44   1              _Nop();
  45   1              _Nop();
  46   1              _Nop();
  47   1              _Nop();
  48   1              SCL = 0;    //钳住I2C总线，准备发送或接收数据
  49   1              _Nop();
  50   1              _Nop();
  51   1      }
  52          /*------------------------------------------------
  53          结束总线
  54          ------------------------------------------------*/
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 2   

  55          void Stop_I2c()
  56          {
  57   1              SDA = 0;    //发送结束条件的数据信号
  58   1              _Nop();   //发送结束条件的时钟信号
  59   1              SCL = 1;    //结束条件建立时间大于4μ
  60   1              _Nop();
  61   1              _Nop();
  62   1              _Nop();
  63   1              _Nop();
  64   1              _Nop();
  65   1              SDA = 1;    //发送I2C总线结束信号
  66   1              _Nop();
  67   1              _Nop();
  68   1              _Nop();
  69   1              _Nop();
  70   1      }
  71          
  72          /*----------------------------------------------------------------
  73          字节数据传送函数
  74          函数原型: void  SendByte(unsigned char c);
  75          功能:  将数据c发送出去,可以是地址,也可以是数据,发完后等待应答,并对
  76          此状态位进行操作.(不应答或非应答都使ack=0 假)
  77          发送数据正常，ack=1; ack=0表示被控器无应答或损坏。
  78          ------------------------------------------------------------------*/
  79          void  SendByte(unsigned char c)
  80          {
  81   1              unsigned char BitCnt;
  82   1              for (BitCnt = 0; BitCnt<8; BitCnt++)  //要传送的数据长度为8位
  83   1              {
  84   2                      if ((c << BitCnt) & 0x80)
  85   2                              SDA = 1;   //判断发送位
  86   2                      else
  87   2                              SDA = 0;
  88   2                      _Nop();
  89   2                      SCL = 1;               //置时钟线为高，通知被控器开始接收数据位
  90   2                      _Nop();
  91   2                      _Nop();             //保证时钟高电平周期大于4μ
  92   2                      _Nop();
  93   2                      _Nop();
  94   2                      _Nop();
  95   2                      SCL = 0;
  96   2              }
  97   1              _Nop();
  98   1              _Nop();
  99   1              SDA = 1;               //8位发送完后释放数据线，准备接收应答位
 100   1              _Nop();
 101   1              _Nop();
 102   1              SCL = 1;
 103   1              _Nop();
 104   1              _Nop();
 105   1              _Nop();
 106   1              if (SDA == 1)ack = 0;
 107   1              else ack = 1;        //判断是否接收到应答信号
 108   1              SCL = 0;
 109   1              _Nop();
 110   1              _Nop();
 111   1      }
 112          
 113          /*----------------------------------------------------------------
 114          字节数据传送函数
 115          函数原型: unsigned char  RcvByte();
 116          功能:  用来接收从器件传来的数据,并判断总线错误(不发应答信号)，
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 3   

 117          发完后请用应答函数。
 118          ------------------------------------------------------------------*/
 119          unsigned char  RcvByte()
 120          {
 121   1              unsigned char retc;
 122   1              unsigned char BitCnt;
 123   1              retc = 0;
 124   1              SDA = 1;             //置数据线为输入方式
 125   1              for (BitCnt = 0; BitCnt<8; BitCnt++)
 126   1              {
 127   2                      _Nop();
 128   2                      SCL = 0;       //置时钟线为低，准备接收数据位
 129   2                      _Nop();
 130   2                      _Nop();      //时钟低电平周期大于4.7us
 131   2                      _Nop();
 132   2                      _Nop();
 133   2                      _Nop();
 134   2                      SCL = 1;       //置时钟线为高使数据线上数据有效
 135   2                      _Nop();
 136   2                      _Nop();
 137   2                      retc = retc << 1;
 138   2                      if (SDA == 1)retc = retc + 1; //读数据位,接收的数据位放入retc中
 139   2                      _Nop();
 140   2                      _Nop();
 141   2              }
 142   1              SCL = 0;
 143   1              _Nop();
 144   1              _Nop();
 145   1              return(retc);
 146   1      }
 147          
 148          
 149          /*----------------------------------------------------------------
 150          应答子函数
 151          原型:  void Ack_I2c(void);
 152          
 153          ----------------------------------------------------------------*/
 154          void Ack_I2c(void)
 155          {
 156   1              SDA = 0;
 157   1              _Nop();
 158   1              _Nop();
 159   1              _Nop();
 160   1              SCL = 1;
 161   1              _Nop();
 162   1              _Nop();              //时钟低电平周期大于4μ
 163   1              _Nop();
 164   1              _Nop();
 165   1              _Nop();
 166   1              SCL = 0;               //清时钟线，钳住I2C总线以便继续接收
 167   1              _Nop();
 168   1              _Nop();
 169   1      }
 170          
 171          /*----------------------------------------------------------------
 172          非应答子函数
 173          原型:  void NoAck_I2c(void);
 174          
 175          ----------------------------------------------------------------*/
 176          void NoAck_I2c(void)
 177          {
 178   1              SDA = 1;
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 4   

 179   1              _Nop();
 180   1              _Nop();
 181   1              _Nop();
 182   1              SCL = 1;
 183   1              _Nop();
 184   1              _Nop();              //时钟低电平周期大于4μ
 185   1              _Nop();
 186   1              _Nop();
 187   1              _Nop();
 188   1              SCL = 0;                //清时钟线，钳住I2C总线以便继续接收
 189   1              _Nop();
 190   1              _Nop();
 191   1      }
 192          
 193          /*----------------------------------------------------------------
 194          向有子地址器件发送多字节数据函数
 195          函数原型: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 196          功能:     从启动总线到发送地址，子地址,数据，结束总线的全过程,从器件
 197          地址sla，子地址suba，发送内容是s指向的内容，发送no个字节。
 198          如果返回1表示操作成功，否则操作有误。
 199          注意：    使用前必须已结束总线。
 200          ----------------------------------------------------------------*/
 201          bit ISendStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 202          {
 203   1              unsigned char i;
 204   1              Start_I2c();               //启动总线
 205   1              SendByte(sla);             //发送器件地址
 206   1              if (ack == 0)return(0);
 207   1              SendByte(suba >> 8);            //发送器件子地址
 208   1              if (ack == 0)return(0);
 209   1              SendByte(suba);
 210   1              if (ack == 0)return(0);
 211   1              for (i = 0; i<no; i++)
 212   1              {
 213   2                      SendByte(*s);            //发送数据
 214   2                      if (ack == 0)return(0);
 215   2                      s++;
 216   2              }
 217   1              Stop_I2c();                  //结束总线
 218   1              return(1);
 219   1      }
 220          
 221          
 222          /*----------------------------------------------------------------
 223          向有子地址器件读取多字节数据函数
 224          函数原型: bit  ISendStr(unsigned char sla,unsigned char suba,ucahr *s,unsigned char no);
 225          功能:     从启动总线到发送地址，子地址,读数据，结束总线的全过程,从器件
 226          地址sla，子地址suba，读出的内容放入s指向的存储区，读no个字节。
 227          如果返回1表示操作成功，否则操作有误。
 228          注意：    使用前必须已结束总线。
 229          ----------------------------------------------------------------*/
 230          bit IRcvStr(unsigned char sla, unsigned int suba, unsigned char *s, unsigned char no)
 231          {
 232   1              unsigned char i;
 233   1              Start_I2c();               //启动总线
 234   1              SendByte(sla);             //发送器件地址
 235   1              if (ack == 0)return(0);
 236   1              SendByte(suba >> 8);            //发送器件子地址
 237   1              if (ack == 0)return(0);
 238   1              SendByte(suba);            //发送器件子地址
 239   1              if (ack == 0)return(0);
 240   1              Start_I2c();
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 5   

 241   1              SendByte(sla + 1);
 242   1              if (ack == 0)return(0);
 243   1              for (i = 0; i<no - 1; i++)
 244   1              {
 245   2                      *s = RcvByte();              //发送数据
 246   2                      Ack_I2c();                //发送就答位 
 247   2                      s++;
 248   2              }
 249   1              *s = RcvByte();
 250   1              NoAck_I2c();                 //发送非应位
 251   1              Stop_I2c();                    //结束总线
 252   1              return(1);
 253   1      }
 254          
 255          bit register_call_function(RF_def *pRF)
 256          {
 257   1              uint16_t addr;
 258   1              uint16_t i;
 259   1              RF_def RFtmp;
 260   1              uint16_t tmp = 0;
 261   1              addr = CALL_DATA_START;
 262   1      
 263   1              for (i = 0; i < CALL_NUMBER; i++)
 264   1              {
 265   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 266   2      
 267   2                      if (!(RFtmp.rf & 0xff000000))
 268   2                      {
 269   3      
 270   3                              if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 271   3                              {
 272   4                                      RFtmp.rf &= 0x00fffff0;
 273   4                                      pRF->rf &= 0x00fffff0;
 274   4                              }
 275   3      
 276   3                              if (RFtmp.rf == pRF->rf)    //有相等RF在里面，重新覆盖
 277   3                              {
 278   4                                      memcpy(Two_Menu_F1_E1, RFtmp.region, 4);
 279   4                                      Two_Menu_F1_E1[4] = 0;
 280   4                                      GD5800_select_chapter(SHIBAI);
 281   4                                      return 1;
 282   4                              }
 283   3                      }
 284   2                      else
 285   2                      {
 286   3                              if (!tmp) tmp = addr;
 287   3                      }
 288   2                      addr += sizeof(RF_def);
 289   2              }
 290   1              ISendStr(I2C_ADDRESS, tmp, (uint8_t *)pRF, sizeof(RF_def));
 291   1              GD5800_select_chapter(CHENGGONG);
 292   1      
 293   1              //EEP_WriteBytes(tmp, (uint8_t *)pRF, sizeof(RF_def));
 294   1              return 0;
 295   1      }
 296          
 297          
 298          bit register_host_function(RF_def *pRF)
 299          {
 300   1              uint16_t addr;
 301   1              uint16_t i;
 302   1              RF_def RFtmp;
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 6   

 303   1              uint16_t tmp = 0;
 304   1              addr = HOST_DATA_START;
 305   1      
 306   1              for (i = 0; i < HOST_NUMBER; i++)
 307   1              {
 308   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 309   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 310   2      
 311   2                      if (!(RFtmp.rf & 0xff000000))
 312   2                      {
 313   3      
 314   3                              if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 315   3                              {
 316   4                                      RFtmp.rf &= 0x00fffff0;
 317   4                                      pRF->rf &= 0x00fffff0;
 318   4                              }
 319   3      
 320   3                              if (RFtmp.rf == pRF->rf)    //有相等RF在里面，重新覆盖
 321   3                              {
 322   4                                      memcpy(Two_Menu_F1_E2, RFtmp.region, 4);
 323   4                                      Two_Menu_F1_E2[4] = 0;
 324   4                                      GD5800_select_chapter(SHIBAI);
 325   4                                      return 1;
 326   4                              }
 327   3                      }
 328   2                      else
 329   2                      {
 330   3                              if (!tmp) tmp = addr;
 331   3                      }
 332   2                      addr += sizeof(RF_def);
 333   2              }
 334   1              ISendStr(I2C_ADDRESS, tmp, (uint8_t *)pRF, sizeof(RF_def));
 335   1              //EEP_WriteBytes(tmp, (uint8_t *)pRF, sizeof(RF_def));
 336   1              GD5800_select_chapter(CHENGGONG);
 337   1              return 0;
 338   1      }
 339          
 340          bit register_alarm_function(RF_def *pRF)
 341          {
 342   1              uint16_t addr;
 343   1              uint16_t i;
 344   1              RF_def RFtmp;
 345   1              uint16_t tmp = 0;
 346   1              addr = ALARM_DATA_START;
 347   1      
 348   1              for (i = 0; i < ALARM_NUMBER; i++)
 349   1              {
 350   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 351   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 352   2      
 353   2                      if (!(RFtmp.rf & 0xff000000))
 354   2                      {
 355   3      
 356   3                              if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 357   3                              {
 358   4                                      RFtmp.rf &= 0x00fffff0;
 359   4                                      pRF->rf &= 0x00fffff0;
 360   4                              }
 361   3      
 362   3                              if (RFtmp.rf == pRF->rf)    //有相等RF在里面，重新覆盖
 363   3                              {
 364   4                                      memcpy(Two_Menu_F1_E3, RFtmp.region, 4);
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 7   

 365   4                                      Two_Menu_F1_E3[4] = 0;
 366   4                                      GD5800_select_chapter(SHIBAI);
 367   4                                      return 1;
 368   4                              }
 369   3                      }
 370   2                      else
 371   2                      {
 372   3                              if (!tmp) tmp = addr;
 373   3                      }
 374   2                      addr += sizeof(RF_def);
 375   2              }
 376   1              ISendStr(I2C_ADDRESS, tmp, (uint8_t *)pRF, sizeof(RF_def));
 377   1              //EEP_WriteBytes(tmp, (uint8_t *)pRF, sizeof(RF_def));
 378   1              GD5800_select_chapter(CHENGGONG);
 379   1              return 0;
 380   1      }
 381          
 382          bit register_cancel_function(RF_def *pRF)
 383          {
 384   1              uint16_t addr;
 385   1              uint16_t i;
 386   1              RF_def RFtmp;
 387   1              uint16_t tmp = 0;
 388   1              addr = CANCEL_DATA_START;
 389   1      
 390   1              for (i = 0; i < CANCEL_NUMBER; i++)
 391   1              {
 392   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 393   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 394   2      
 395   2                      if (!(RFtmp.rf & 0xff000000))
 396   2                      {
 397   3      
 398   3                              if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 399   3                              {
 400   4                                      RFtmp.rf &= 0x00fffff0;
 401   4                                      pRF->rf &= 0x00fffff0;
 402   4                              }
 403   3      
 404   3                              if (RFtmp.rf == pRF->rf)    //有相等RF在里面，重新覆盖
 405   3                              {
 406   4                                      memcpy(Two_Menu_F1_E4, RFtmp.region, 4);
 407   4                                      Two_Menu_F1_E4[4] = 0;
 408   4                                      GD5800_select_chapter(SHIBAI);
 409   4                                      return 1;
 410   4                              }
 411   3                      }
 412   2                      else
 413   2                      {
 414   3                              if (!tmp) tmp = addr;
 415   3                      }
 416   2                      addr += sizeof(RF_def);
 417   2              }
 418   1              ISendStr(I2C_ADDRESS, tmp, (uint8_t *)pRF, sizeof(RF_def));
 419   1              //EEP_WriteBytes(tmp, (uint8_t *)pRF, sizeof(RF_def));
 420   1              GD5800_select_chapter(CHENGGONG);
 421   1              return 0;
 422   1      }
 423          
 424          bit delete_call_function(unsigned char *buf)//buf为组码数组的指针
 425          {
 426   1              RF_def RFtmp;
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 8   

 427   1              uint16_t addr = CALL_DATA_START;
 428   1              uint16_t i;
 429   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 430   1              if (*(volatile uint32_t*)buf == 0x00000000ul)
 431   1              {
 432   2                      for (i = 0; i<128; i++)
 433   2                      {
 434   3                              ISendStr(I2C_ADDRESS, i << 5, dofly, 32);                   //写入24c02
 435   3                              delay10ms();
 436   3                      }
 437   2      
 438   2              }
 439   1              else
 440   1              {
 441   2                      for (i = 0; i < CALL_NUMBER; i++)
 442   2                      {
 443   3                              IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 444   3                              //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 445   3                              if (!(RFtmp.rf & 0xff000000ul))
 446   3                              {
 447   4                                      if (*(volatile uint32_t*)buf == *(volatile uint32_t*)(RFtmp.region))
 448   4                                      {
 449   5                                              memset(&RFtmp, 0xff, sizeof(RF_def));
 450   5                                              ISendStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 451   5                                              //EEP_WriteBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 452   5                                              break;
 453   5                                      }
 454   4                              }
 455   3                              addr += sizeof(RF_def);
 456   3                      }
 457   2              }
 458   1              return 0;
 459   1      }
 460          
 461          bit delete_host_function(unsigned char *buf)//buf为组码数组的指针
 462          {
 463   1              RF_def RFtmp;
 464   1              uint16_t addr = HOST_DATA_START;
 465   1              uint16_t i;
 466   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 467   1              if (*(volatile uint32_t*)buf == 0x00000000ul)
 468   1              {
 469   2                      for (i = 0; i<8; i++)
 470   2                      {
 471   3                              ISendStr(I2C_ADDRESS, addr+( i << 5), dofly, 32);                   //写入24c02
 472   3                              delay10ms();
 473   3                      }
 474   2      
 475   2              }
 476   1              else
 477   1              {
 478   2                      for (i = 0; i < HOST_NUMBER; i++)
 479   2                      {
 480   3                              IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 481   3                              //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 482   3                              if (!(RFtmp.rf & 0xff000000ul))
 483   3                              {
 484   4                                      if (*(volatile uint32_t*)buf == *(volatile uint32_t*)(RFtmp.region))
 485   4                                      {
 486   5                                              memset(&RFtmp, 0xff, sizeof(RF_def));
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 9   

 487   5                                              ISendStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 488   5                                              //EEP_WriteBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 489   5                                              break;
 490   5                                      }
 491   4                              }
 492   3                              addr += sizeof(RF_def);
 493   3                      }
 494   2              }
 495   1              return 0;
 496   1      }
 497          
 498          bit delete_alarm_function(unsigned char *buf)//buf为组码数组的指针
 499          {
 500   1              RF_def RFtmp;
 501   1              uint16_t addr = ALARM_DATA_START;
 502   1              uint16_t i;
 503   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 504   1              if (*(volatile uint32_t*)buf == 0x00000000ul)
 505   1              {
 506   2                      for (i = 0; i<16; i++)
 507   2                      {
 508   3                              ISendStr(I2C_ADDRESS, addr + (i << 5), dofly, 32);                   //写入24c02
 509   3                              delay10ms();
 510   3                      }
 511   2      
 512   2              }
 513   1              else
 514   1              {
 515   2                      for (i = 0; i < ALARM_NUMBER; i++)
 516   2                      {
 517   3                              IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 518   3                              //      EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 519   3                              if (!(RFtmp.rf & 0xff000000ul))
 520   3                              {
 521   4                                      if (*(volatile uint32_t*)buf == *(volatile uint32_t*)(RFtmp.region))
 522   4                                      {
 523   5                                              memset(&RFtmp, 0xff, sizeof(RF_def));
 524   5                                              ISendStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 525   5                                              //EEP_WriteBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 526   5                                              break;
 527   5                                      }
 528   4                              }
 529   3                              addr += sizeof(RF_def);
 530   3                      }
 531   2              }
 532   1              return 0;
 533   1      }
 534          
 535          bit delete_cancel_function(unsigned char *buf)//buf为组码数组的指针
 536          {
 537   1              RF_def RFtmp;
 538   1              uint16_t addr = CANCEL_DATA_START;
 539   1              uint16_t i;
 540   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 541   1              if (*(volatile uint32_t*)buf == 0x00000000ul)
 542   1              {
 543   2                      for (i = 0; i<16; i++)
 544   2                      {
 545   3                              ISendStr(I2C_ADDRESS, addr + (i << 5), dofly, 32);                   //写入24c02
 546   3                              delay10ms();
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 10  

 547   3                      }
 548   2      
 549   2              }
 550   1              else
 551   1              {
 552   2                      for (i = 0; i < CANCEL_NUMBER; i++)
 553   2                      {
 554   3                              IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 555   3                              //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 556   3                              if (!(RFtmp.rf & 0xff000000ul))
 557   3                              {
 558   4                                      if (*(volatile uint32_t*)buf == *(volatile uint32_t*)(RFtmp.region))
 559   4                                      {
 560   5                                              memset(&RFtmp, 0xff, sizeof(RF_def));
 561   5                                              ISendStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 562   5                                              //EEP_WriteBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 563   5                                              break;
 564   5                                      }
 565   4                              }
 566   3                              addr += sizeof(RF_def);
 567   3                      }
 568   2              }
 569   1              return 0;
 570   1      }
 571          
 572          void Delete_all_data(void)
 573          {
 574   1      //      uint8_t i,j;
 575   1      //      int8_t buf[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
             -0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 576   1      //      uint16_t addr = 0;
 577   1      //      int8_t buf1[32];
 578   1      ////    memset(buf, 0xff, sizeof(buf));
 579   1      //      addr = 0;
 580   1      //      for (i = 0; i<168; i++)
 581   1      //      {       
 582   1      //              addr = i << 5;
 583   1      //              ISendStr(I2C_ADDRESS, addr, buf, 32);
 584   1      //              delay10ms();
 585   1      //              //EEP_WriteBytes(addr, buf, sizeof(buf));
 586   1      //              //addr += 32;
 587   1      //      }
 588   1      //      uart_printf("24c read:");
 589   1      //      for (i = 0; i<168; i++)
 590   1      //      {
 591   1      //              IRcvStr(I2C_ADDRESS, addr, buf, 32);
 592   1      //              delay10ms();
 593   1      //              for (j = 0; j < 32; j++)
 594   1      //              {
 595   1      //                      uart_printf("%02x ", (unsigned int)buf[j]);
 596   1      //              }
 597   1      //              uart_printf("\n\r");
 598   1      //              //EEP_WriteBytes(addr, buf, sizeof(buf));
 599   1      //              addr += sizeof(buf);
 600   1      //      }
 601   1      
 602   1              unsigned char dofly[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
             - 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 603   1              unsigned int k;
 604   1              for (k = 0; k<168; k++)
 605   1              {
 606   2                      ISendStr(I2C_ADDRESS, k << 5, dofly, 32);                   //写入24c02
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 11  

 607   2                      delay10ms();
 608   2              }
 609   1      }
 610          
 611          
 612          int8_t Find_RF_EEPROM_Call(RF_def *p, uint32_t dat)
 613          {
 614   1              RF_def RFtmp;
 615   1              uint16_t addr;
 616   1              uint16_t i;
 617   1              addr = CALL_DATA_START;
 618   1      
 619   1              for (i = 0; i<CALL_NUMBER; i++)
 620   1              {
 621   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 622   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 623   2      
 624   2                      if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 625   2                      {
 626   3                              RFtmp.rf &= 0x00fffff0;
 627   3                              dat &= 0x00fffff0;
 628   3                      }
 629   2      
 630   2                      if (RFtmp.rf == dat)
 631   2                      {
 632   3                              memcpy(p, &RFtmp, sizeof(RF_def));
 633   3                              return 1;
 634   3                      }
 635   2                      addr += sizeof(RF_def);
 636   2              }
 637   1              return 0;
 638   1      }
 639          
 640          int8_t Find_RF_EEPROM_Host(RF_def *p, uint32_t dat)
 641          {
 642   1              RF_def RFtmp;
 643   1              uint16_t addr;
 644   1              uint16_t i;
 645   1              addr = HOST_DATA_START;
 646   1      
 647   1              for (i = 0; i<HOST_NUMBER; i++)
 648   1              {
 649   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 650   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 651   2      
 652   2                      if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 653   2                      {
 654   3                              RFtmp.rf &= 0x00fffff0;
 655   3                              dat &= 0x00fffff0;
 656   3                      }
 657   2      
 658   2                      if (RFtmp.rf == dat)
 659   2                      {
 660   3                              memcpy(p, &RFtmp, sizeof(RF_def));
 661   3                              return 1;
 662   3                      }
 663   2                      addr += sizeof(RF_def);
 664   2              }
 665   1              return 0;
 666   1      }
 667          
 668          int8_t Find_RF_EEPROM_Alarm(RF_def *p, uint32_t dat)
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 12  

 669          {
 670   1              RF_def RFtmp;
 671   1              uint16_t addr;
 672   1              uint16_t i;
 673   1              addr = ALARM_DATA_START;
 674   1      
 675   1              for (i = 0; i<ALARM_NUMBER; i++)
 676   1              {
 677   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 678   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 679   2      
 680   2                      if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 681   2                      {
 682   3                              RFtmp.rf &= 0x00fffff0;
 683   3                              dat &= 0x00fffff0;
 684   3                      }
 685   2      
 686   2                      if (RFtmp.rf == dat)
 687   2                      {
 688   3                              memcpy(p, &RFtmp, sizeof(RF_def));
 689   3                              return 1;
 690   3                      }
 691   2                      addr += sizeof(RF_def);
 692   2              }
 693   1              return 0;
 694   1      }
 695          
 696          int8_t Find_RF_EEPROM_Cancel(RF_def *p, uint32_t dat)
 697          {
 698   1              RF_def RFtmp;
 699   1              uint16_t addr;
 700   1              uint16_t i;
 701   1              addr = CANCEL_DATA_START;
 702   1      
 703   1              for (i = 0; i<CANCEL_NUMBER; i++)
 704   1              {
 705   2                      IRcvStr(I2C_ADDRESS, addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 706   2                      //EEP_ReadBytes(addr, (uint8_t *)&RFtmp, sizeof(RF_def));
 707   2      
 708   2                      if (return_Two_Menu_F8_E1() == 2)      //多键模式低位为0
 709   2                      {
 710   3                              RFtmp.rf &= 0x00fffff0;
 711   3                              dat &= 0x00fffff0;
 712   3                      }
 713   2      
 714   2                      if (RFtmp.rf == dat)
 715   2                      {
 716   3                              memcpy(p, &RFtmp, sizeof(RF_def));
 717   3                              return 1;
 718   3                      }
 719   2                      addr += sizeof(RF_def);
 720   2              }
 721   1              return 0;
 722   1      }
 723          
 724          int8_t Find_RF_EEPROM(RF_def *p, uint32_t dat)
 725          {
 726   1              if (Find_RF_EEPROM_Cancel(p, dat))
 727   1              {
 728   2                      return 1;
 729   2              }
 730   1              else if (Find_RF_EEPROM_Alarm(p, dat))
C51 COMPILER V9.00   AT24C256                                                              11/06/2015 11:59:03 PAGE 13  

 731   1              {
 732   2                      return 2;
 733   2              }
 734   1              else if (Find_RF_EEPROM_Call(p, dat))
 735   1              {
 736   2                      return 3;
 737   2              }
 738   1              else
 739   1              {
 740   2                      return 0;
 741   2              }
 742   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3707    ----
   CONSTANT SIZE    =    160    ----
   XDATA SIZE       =     15     387
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
