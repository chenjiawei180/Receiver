C51 COMPILER V9.00   KEY                                                                   09/03/2015 16:06:51 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN key.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\key.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRINT(.\k
                    -ey.lst) TABS(2) OBJECT(key.obj)

line level    source

   1          #include "key.h"
   2          #include "usart.h"
   3          #include "tm1629.h"
   4          #include "menu.h"
   5          
   6          unsigned char func_index = 0; //多级菜单索引变量
   7          void(*current_operation_index)();// 多级菜单函数指针
   8          
   9          key_table code table[100] =
  10          { // 目标索引       上        下          确认     退出         函数
  11            { MENU_STANDBY, MENU_STANDBY, MENU_STANDBY, MENU_STANDBY, MENU_STANDBY, (*fun0) }, //待机
  12          
  13            { ONE_MENU_F0, ONE_MENU_F9, ONE_MENU_F1, 0, MENU_STANDBY, (*fun1) }, //F0-F9
  14            { ONE_MENU_F1, ONE_MENU_F0, ONE_MENU_F2, 0, MENU_STANDBY, (*fun2) },
  15            { ONE_MENU_F2, ONE_MENU_F1, ONE_MENU_F3, 0, MENU_STANDBY, (*fun3) },
  16            { ONE_MENU_F3, ONE_MENU_F2, ONE_MENU_F4, 0, MENU_STANDBY, (*fun4) },
  17            { ONE_MENU_F4, ONE_MENU_F3, ONE_MENU_F5, 0, MENU_STANDBY, (*fun5) },
  18            { ONE_MENU_F5, ONE_MENU_F4, ONE_MENU_F6, 0, MENU_STANDBY, (*fun6) },
  19            { ONE_MENU_F6, ONE_MENU_F5, ONE_MENU_F7, 0, MENU_STANDBY, (*fun7) },
  20            { ONE_MENU_F7, ONE_MENU_F6, ONE_MENU_F8, 0, MENU_STANDBY, (*fun8) },
  21            { ONE_MENU_F8, ONE_MENU_F7, ONE_MENU_F9, 0, MENU_STANDBY, (*fun9) },
  22            { ONE_MENU_F9, ONE_MENU_F8, ONE_MENU_F0, 0, MENU_STANDBY, (*fun10) },
  23          
  24            { ONE_MENU_FH, ONE_MENU_FH, ONE_MENU_FH, 0, MENU_STANDBY, (*fun2) }, //FH
  25          
  26          
  27          };
  28          
  29          unsigned int KeyScan(void)  //Keyboard scan function
  30          {
  31   1        unsigned int Val = 0;
  32   1        HKeyPort |= 0x1f;//Row height
  33   1        LKeyPort &= 0x07;
  34   1        if ((HKeyPort & 0x1f) != 0x1f)//Press button
  35   1        {
  36   2          delay10ms();  //Remove jitter
  37   2          if ((HKeyPort & 0x1f) != 0x1f)   //Press button
  38   2          {
  39   3            HKeyPort |= 0x1f; //检测第一列
  40   3            LKeyPort |= 0xf8;
  41   3            LKeyPort &= 0x7f;
  42   3            if ((HKeyPort & 0x1f) != 0x1f)
  43   3            {
  44   4              //  return_standby_time=0;
  45   4              //  sound_table=1;
  46   4              Val = HKeyPort & 0x1f;
  47   4              Val <<= 8;
  48   4              Val += (LKeyPort & 0xf8);
  49   4              if (Val == 0x1e78)
  50   4              {
  51   5                //    main_press_time=0;
  52   5                //    main_press_time_table=1;
  53   5              }
  54   4              while ((HKeyPort & 0x1f) != 0x1f);
C51 COMPILER V9.00   KEY                                                                   09/03/2015 16:06:51 PAGE 2   

  55   4              delay10ms();
  56   4              while ((HKeyPort & 0x1f) != 0x1f);
  57   4              //  main_press_time_table=0;
  58   4              return Val;
  59   4            }
  60   3          }
  61   2        }
  62   1        return 0x0fff;
  63   1      }
  64          
  65          unsigned char KeyDecoder(void)
  66          {
  67   1        unsigned int key_val = 0;
  68   1      
  69   1        key_val = KeyScan();
  70   1      #if 0   
                if (key_val == 0x0fff) /*do not key press*/
                {
                  /*sjz 有注册管理器标志*/
                  if (register_manager == 1)
                  {
              
                    if (func_index == FUNC_STANDBY)
                    {
                      if ((old2_RF_RECE_REG[2] & 0x0f) == 0x01)
                      {
                        accumulate_decoder++;
                      }
                      else
                      {
                        accumulate_decoder = 0;
                      }
                      if (accumulate_decoder>10)
                      {
                        accumulate_50ms = 20;
                        accumulate_decoder = 0;
                      }
                    }
                    register_manager = 0;
                    switch (old2_RF_RECE_REG[2] & 0x0f)
                    {
                    case 0x01:key_val = 0x1778; break;
                    case 0x02:key_val = 0x1b78; break;
                    case 0x04:key_val = 0x1d78; break;
                    case 0x08:key_val = 0x1e78; break;
                    default:break;
                    }
                  }
                }
              #endif   
 105   1      
 106   1      #ifdef DEBUG
 107   1        if (key_val != 0x0fff)
 108   1        uart_printf("key_val is %x .\r\n", key_val); //测试按键键值
 109   1      #endif
 110   1        switch (key_val)
 111   1        {
 112   2        case 0x1778:return KEY_RETURN; break;//1 按下相应的键显示相对应的码值
 113   2        case 0x1d78:return KEY_DOWN; break;//2  
 114   2        case 0x1b78:return KEY_UP; break;//4
 115   2        case 0x1e78:return KEY_FUNC; break;//5 按下相应的键显示相对应的码值
 116   2        default:return 0xff; break;
C51 COMPILER V9.00   KEY                                                                   09/03/2015 16:06:51 PAGE 3   

 117   2        }
 118   1      }
 119          
 120          void KeyProcess(void)
 121          {
 122   1        unsigned char key_value;
 123   1        key_value = KeyDecoder();
 124   1        switch (key_value)
 125   1        {
 126   2          case KEY_FUNC:    func_index = table[func_index].enter; break;
 127   2          case KEY_RETURN:  func_index = table[func_index].esc; break;
 128   2          case KEY_UP:    func_index = table[func_index].up; break;
 129   2          case KEY_DOWN:    func_index = table[func_index].down; break;
 130   2          default:break;
 131   2        }
 132   1        current_operation_index = table[func_index].index_operation;
 133   1        (*current_operation_index)();//执行当前操作函数
 134   1      }
 135          
 136          void delay10ms(void)   //误差 -0.054253472222us
 137          {
 138   1        unsigned char a, b, c;
 139   1        for (c = 4; c>0; c--)
 140   1        for (b = 52; b>0; b--)
 141   1        for (a = 220; a>0; a--);
 142   1        _nop_();  //if Keil,require use intrins.h
 143   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    369    ----
   CONSTANT SIZE    =    818    ----
   XDATA SIZE       =      4       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
