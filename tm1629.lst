C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TM1629
OBJECT MODULE PLACED IN tm1629.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\tm1629.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRINT(
                    -.\tm1629.lst) TABS(2) OBJECT(tm1629.obj)

line level    source

   1          #include "tm1629.h"
   2          #include "timer.h"
   3          #include "usart.h"
   4          #include "ds1302.h"
   5          #include "key.h"
   6          #include "menu.h"
   7          
   8          unsigned char const CODE[] = { 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x3
             -9, 0x5E, 0x79, 0x71, 0x76, 0x38, 0x5c, 0x73, 0x3e };//0-9 abcdef 显示器码数组
   9          unsigned char const INIT_CODE[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };//逐段点亮数码管数组
  10          unsigned char const SHANGSHUO[] = { 0x40, 0x00 }; // 点亮数码管中间段以及灭
  11          unsigned char buf_display[6][8] = { 0 }; //3个TM1629显存数组
  12          unsigned char display_ram[240] = { 0 }; //程序运行时记录显示数据的内存 
  13          unsigned char await_time_table= 0 ;//用于记录待机显示横杠数码管次数 
  14          
  15          void writeDataTo1629(unsigned char p) //写数据给第一个TM1629
  16          {
  17   1        unsigned int i;
  18   1        TM1629_STB = 0;
  19   1        for (i = 0; i<8; i++)
  20   1        {
  21   2          TM1629_CLK = 0;
  22   2          if (p & 0x01)
  23   2            TM1629_DIO = 1;
  24   2          else
  25   2            TM1629_DIO = 0;
  26   2          _nop_();
  27   2          _nop_();
  28   2          _nop_();
  29   2          _nop_();
  30   2          TM1629_CLK = 1;
  31   2          p = p >> 1;
  32   2        }
  33   1        TM1629_CLK = 0;
  34   1        TM1629_DIO = 0;
  35   1      }
  36          
  37          void writeDataTo1629_2(unsigned char p) //写数据给第二个TM1629
  38          {
  39   1        unsigned int i;
  40   1        TM1629_STB2 = 0;
  41   1        for (i = 0; i<8; i++)
  42   1        {
  43   2          TM1629_CLK = 0;
  44   2          if (p & 0x01)
  45   2            TM1629_DIO = 1;
  46   2          else
  47   2            TM1629_DIO = 0;
  48   2          _nop_();
  49   2          _nop_();
  50   2          _nop_();
  51   2          _nop_();
  52   2          TM1629_CLK = 1;
  53   2          p = p >> 1;
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 2   

  54   2        }
  55   1        TM1629_CLK = 0;
  56   1        TM1629_DIO = 0;
  57   1      }
  58          
  59          void writeDataTo1629_3(unsigned char p) //写数据给第三个TM1629
  60          {
  61   1        unsigned int i;
  62   1        TM1629_STB3 = 0;
  63   1        for (i = 0; i<8; i++)
  64   1        {
  65   2          TM1629_CLK = 0;
  66   2          if (p & 0x01)
  67   2            TM1629_DIO = 1;
  68   2          else
  69   2            TM1629_DIO = 0;
  70   2          _nop_();
  71   2          _nop_();
  72   2          _nop_();
  73   2          _nop_();
  74   2          TM1629_CLK = 1;
  75   2          p = p >> 1;
  76   2        }
  77   1        TM1629_CLK = 0;
  78   1        TM1629_DIO = 0;
  79   1      }
  80          
  81          void send_command(unsigned char word) //写命令给第一个TM1629
  82          {
  83   1        TM1629_STB = 1;
  84   1        nop;
  85   1        TM1629_STB = 0;
  86   1        writeDataTo1629(word);
  87   1      }
  88          
  89          void send_command_2(unsigned char word) //写命令给第二个TM1629
  90          {
  91   1        TM1629_STB2 = 1;
  92   1        nop;
  93   1        TM1629_STB2 = 0;
  94   1        writeDataTo1629_2(word);
  95   1      }
  96          
  97          void send_command_3(unsigned char word) //写命令给第三个TM1629
  98          {
  99   1        TM1629_STB3 = 1;
 100   1        nop;
 101   1        TM1629_STB3 = 0;
 102   1        writeDataTo1629_3(word);
 103   1      }
 104          
 105          void display(void) //3个TM1629显示函数
 106          {
 107   1        unsigned char i,temp;
 108   1        temp = return_Two_Menu_F6_E5();
 109   1        send_command(0x40); //设置数据命令:普通模式、地址自增1，写数据到显存
 110   1        send_command(0xc0); //设置显示地址命令：从00H开始
 111   1        for (i = 0; i<8; i++) //发送16字节的显存数据
 112   1        {
 113   2          writeDataTo1629(buf_display[0][i]);
 114   2          writeDataTo1629(buf_display[1][i]);
 115   2        }
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 3   

 116   1        send_command(0x88 + temp);  //设置显示控制命令：打开显示，并设置为11/16.
 117   1        TM1629_STB = 1;
 118   1      
 119   1        send_command_2(0x40); //设置数据命令:普通模式、地址自增1，写数据到显存
 120   1        send_command_2(0xc0); //设置显示地址命令：从00H开始
 121   1        for (i = 0; i<8; i++) //发送16字节的显存数据
 122   1        {
 123   2          writeDataTo1629_2(buf_display[2][i]);
 124   2          writeDataTo1629_2(buf_display[3][i]);
 125   2        }
 126   1        send_command_2(0x88 + temp);  //设置显示控制命令：打开显示，并设置为11/16.
 127   1        TM1629_STB2 = 1;
 128   1      
 129   1        send_command_3(0x40); //设置数据命令:普通模式、地址自增1，写数据到显存
 130   1        send_command_3(0xc0); //设置显示地址命令：从00H开始
 131   1        for (i = 0; i<8; i++) //发送16字节的显存数据
 132   1        {
 133   2          writeDataTo1629_3(buf_display[4][i]);
 134   2          writeDataTo1629_3(buf_display[5][i]);
 135   2        }
 136   1        send_command_3(0x88 + temp);  //设置显示控制命令：打开显示，并设置为11/16.
 137   1        TM1629_STB3 = 1;
 138   1      }
 139          
 140          
 141          void tm1629_init(void) //TM1629开机初始化函数
 142          {
 143   1        unsigned char i, j, k;    //k控制显示的具体数字，i和j控制buf_display的刷新
 144   1        for (k = 0; k<8; k++)
 145   1        {
 146   2          for (i = 0; i<6; i++)
 147   2          {
 148   3            for (j = 0; j<8; j++)
 149   3            {
 150   4              buf_display[i][j] = INIT_CODE[k];
 151   4            }
 152   3          }
 153   2          display();
 154   2          Tm1629_delay(30);
 155   2        }
 156   1      }
 157          
 158          
 159          void Tm1629_delay(unsigned char k) //延时函数
 160          {
 161   1        unsigned char i, j;
 162   1        for (; k>0; k--)
 163   1        {
 164   2          for (i = 255; i>0; i--)
 165   2          {
 166   3            for (j = 255; j>0; j--)
 167   3            {
 168   4              ;
 169   4      
 170   4            }
 171   3          }
 172   2        }
 173   1      }
 174          
 175          void tm1629_clear(void)//全部归零
 176          {
 177   1        unsigned char i, j;
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 4   

 178   1        for (i = 0; i<6; i++)
 179   1        {
 180   2          for (j = 0; j<8; j++)
 181   2          {
 182   3            buf_display[i][j] = 0x00;
 183   3          }
 184   2        }
 185   1      }
 186          
 187          void tm1629_await(void)
 188          {
 189   1        unsigned char i;  //k控制显示的具体数字，i和j控制buf_display的刷新
 190   1        unsigned char await_number_table_temp = 0;
 191   1        await_number_table_temp = return_await_number_table();
 192   1        if (await_number_table_temp == 1)
 193   1        {
 194   2          //GD5800_select_chapter(0x0008) ;
 195   2          tm1629_clear();
 196   2          i = await_time_table & 0x03;
 197   2          buf_display[0][i] = 0x40;
 198   2          display();
 199   2          set_await_number_table(0);
 200   2          await_time_table++;
 201   2          if (await_time_table == 4)
 202   2            await_time_table = 0;
 203   2        }
 204   1      }
 205          
 206          void Display_time(void)
 207          {
 208   1        tm1629_clear();
 209   1        Ds1302_Read_Time(); 
 210   1        buf_display[1][7] = CODE[2];        //年
 211   1        buf_display[1][6] = CODE[0];
 212   1        buf_display[1][5] = CODE[time_buf1[1] / 10];
 213   1        buf_display[1][4] = CODE[time_buf1[1] % 10];
 214   1      
 215   1        buf_display[1][3] = 0x40;          // -
 216   1        
 217   1        buf_display[1][2] = CODE[time_buf1[2] / 10]; //月
 218   1        buf_display[1][1] = CODE[time_buf1[2] % 10];
 219   1      
 220   1        buf_display[1][0] = 0x40;          // -
 221   1      
 222   1        buf_display[0][7] = CODE[time_buf1[3] / 10];
 223   1        buf_display[0][6] = CODE[time_buf1[3] % 10];//日
 224   1      
 225   1        buf_display[0][5] = CODE[time_buf1[7]];   //星期
 226   1      
 227   1        buf_display[0][3] = CODE[time_buf1[4] / 10]; //小时
 228   1        buf_display[0][2] = CODE[time_buf1[4] % 10];
 229   1        buf_display[0][1] = CODE[time_buf1[5] / 10]; //小时
 230   1        buf_display[0][0] = CODE[time_buf1[5] % 10];
 231   1      
 232   1        display();
 233   1      
 234   1      }
 235          
 236          void tm1629_f(unsigned char f_number) //第一行倒数二个显示F,倒数第一个显示f_number
 237          {
 238   1        tm1629_clear();
 239   1        buf_display[0][1] = CODE[0x0f];
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 5   

 240   1        buf_display[0][0] = CODE[f_number];
 241   1        display();
 242   1      }
 243          
 244          void tm1629_E(unsigned char f_number) //第一行倒数二个显示F,倒数第一个显示f_number
 245          {
 246   1        tm1629_clear();
 247   1        buf_display[0][1] = CODE[0x0E];
 248   1        buf_display[0][0] = CODE[f_number];
 249   1        display();
 250   1      }
 251          
 252          void Show_one_number(unsigned char f_number) //显示一个数字
 253          {
 254   1        tm1629_clear();
 255   1        //buf_display[0][1] = CODE[0x0E];
 256   1        buf_display[0][0] = CODE[f_number];
 257   1        display();
 258   1      }
 259          
 260          void Show_two_number(unsigned char f_number) //显示两个数字
 261          {
 262   1        tm1629_clear();
 263   1        buf_display[0][1] = CODE[f_number / 10];
 264   1        buf_display[0][0] = CODE[f_number % 10];
 265   1        display();
 266   1      }
 267          
 268          void Show_four_number(unsigned char* temp)
 269          {
 270   1        tm1629_clear();
 271   1        buf_display[0][3] = CODE[*(temp)];
 272   1        buf_display[0][2] = CODE[*(temp+1)];
 273   1        buf_display[0][1] = CODE[*(temp+2)];
 274   1        buf_display[0][0] = CODE[*(temp+3)];
 275   1        display();
 276   1      }
 277          
 278          void tm1629_load(void)
 279          {
 280   1        tm1629_clear();
 281   1        if (*(display_ram + 66) != 0)
 282   1          mcuram_to_displayram(buf_display[5] + 7, display_ram + 66);
 283   1        if (*(display_ram + 60) != 0)
 284   1          mcuram_to_displayram(buf_display[5] + 3, display_ram + 60);
 285   1        if (*(display_ram + 54) != 0)
 286   1          mcuram_to_displayram(buf_display[4] + 7, display_ram + 54);
 287   1        if (*(display_ram + 48) != 0)
 288   1          mcuram_to_displayram(buf_display[4] + 3, display_ram + 48);
 289   1        if (*(display_ram + 42) != 0)
 290   1          mcuram_to_displayram(buf_display[3] + 7, display_ram + 42);
 291   1        if (*(display_ram + 36) != 0)
 292   1          mcuram_to_displayram(buf_display[3] + 3, display_ram + 36);
 293   1        if (*(display_ram + 30) != 0)
 294   1          mcuram_to_displayram(buf_display[2] + 7, display_ram + 30);
 295   1        if (*(display_ram + 24) != 0)
 296   1          mcuram_to_displayram(buf_display[2] + 3, display_ram + 24);
 297   1        if (*(display_ram + 18) != 0)
 298   1          mcuram_to_displayram(buf_display[1] + 7, display_ram + 18);
 299   1        if (*(display_ram + 12) != 0)
 300   1          mcuram_to_displayram(buf_display[1] + 3, display_ram + 12);
 301   1        if (*(display_ram + 6) != 0)
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 6   

 302   1          mcuram_to_displayram(buf_display[0] + 7, display_ram + 6);
 303   1        if (*(display_ram + 0) != 0)
 304   1          mcuram_to_displayram(buf_display[0] + 3, display_ram);
 305   1      }
 306          
 307          void mcuram_to_displayram(unsigned char a[48], unsigned char* b)  //从RAM区域移到显存区域,顺带翻译成数码管
             -显示的码
 308          {
 309   1        /*
 310   1        A// 类别、区号、接收号
 311   1        B// 类别、区号、接收号
 312   1        */
 313   1        *(a) = CODE[*(b + 1)];
 314   1        *(a - 1) = CODE[*(b + 2)];
 315   1        *(a - 2) = CODE[*(b + 3)];
 316   1        *(a - 3) = CODE[*(b + 4)];
 317   1      }
 318          
 319          void decoder_temp_to_mcuram(unsigned char* a, unsigned char* index)//a为MCU缓存区   index为解码后取出的8字
             -节临时数组
 320          {
 321   1        *(a + 0) = *(index);
 322   1        *(a + 1) = *(index + 1);
 323   1        *(a + 2) = *(index + 2);
 324   1        *(a + 3) = *(index + 3);
 325   1        *(a + 4) = *(index + 4);
 326   1        *(a + 5) = *(index + 5);
 327   1      }
 328          
 329          void mcuram_to_mcuram_down(unsigned char* a) //a为MCURAM缓存区区   向下压一组数据
 330          {
 331   1        *(a + 6) = *(a);    //ram区元素下移6个
 332   1        *(a + 7) = *(a + 1);
 333   1        *(a + 8) = *(a + 2);
 334   1        *(a + 9) = *(a + 3);
 335   1        *(a + 10) = *(a + 4);
 336   1        *(a + 11) = *(a + 5);
 337   1      
 338   1      }
 339          
 340          void mcuram_to_mcuram_up(unsigned char* a) //a为MCURAM缓存区区   向上压一组数据
 341          {
 342   1        *(a) = *(a + 6);   //ram区元素上移6个
 343   1        *(a + 1) = *(a + 7);
 344   1        *(a + 2) = *(a + 8);
 345   1        *(a + 3) = *(a + 9);
 346   1        *(a + 4) = *(a + 10);
 347   1        *(a + 5) = *(a + 11);
 348   1      }
 349          
 350          void CycleProcess(void)
 351          {
 352   1        unsigned char i, index;
 353   1        unsigned char f5_xunhuan, f4_xiaohao, logout_cycle_table_temp;
 354   1        unsigned char temp[6] = { 0 };
 355   1        f5_xunhuan = return_Two_Menu_F5_E1();
 356   1        f4_xiaohao = return_Two_Menu_F4_E1();
 357   1        logout_cycle_table_temp = return_logout_cycle_table();
 358   1        /*循环处理函数*/
 359   1        if (f5_xunhuan<f4_xiaohao && logout_cycle_table_temp>f5_xunhuan&&f5_xunhuan != 0)
 360   1        {
 361   2          for (i = 0; i<10; i++)
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 7   

 362   2          {
 363   3            if (display_ram[i * 6 ] == 0)
 364   3            {
 365   4              index = i;
 366   4              break;
 367   4            }
 368   3          }
 369   2      
 370   2          for (i = 0; i<6; i++)
 371   2          {
 372   3            temp[i] = display_ram[i];
 373   3          }
 374   2          for (i = 0; i<index; i++)
 375   2          {
 376   3            mcuram_to_mcuram_up(display_ram + i * 6);
 377   3          }
 378   2          for (i = 0; i<6; i++)
 379   2          {
 380   3            display_ram[(index - 1) * 6 + i] = temp[i];
 381   3          }
 382   2          tm1629_load();
 383   2          display();
 384   2          set_logout_cycle_table(0);
 385   2        }
 386   1      }
 387          
 388          void LogoutProcess(void)
 389          {
 390   1        unsigned char i;
 391   1        unsigned char f5_xunhuan, f4_xiaohao, logout_cycle_table_temp, Two_Menu_F3_E2_temp;
 392   1        f5_xunhuan = return_Two_Menu_F5_E1();
 393   1        f4_xiaohao = return_Two_Menu_F4_E1();
 394   1        logout_cycle_table_temp = return_logout_cycle_table();
 395   1        Two_Menu_F3_E2_temp = return_Two_Menu_F3_E2();
 396   1        /*销号处理函数*/
 397   1        if (f4_xiaohao<f5_xunhuan&& logout_cycle_table_temp>f4_xiaohao&&f4_xiaohao != 0)
 398   1        {
 399   2          for (i = 0; i<(Two_Menu_F3_E2_temp - 1); i++)
 400   2          {
 401   3            mcuram_to_mcuram_up(display_ram + i * 6);
 402   3          }
 403   2          for (i = (Two_Menu_F3_E2_temp - 1) * 6; i<Two_Menu_F3_E2_temp * 6; i++)
 404   2          {
 405   3            display_ram[i] = 0;
 406   3          }
 407   2          tm1629_load();
 408   2          display();
 409   2          set_logout_cycle_table(0);
 410   2          if (display_ram[0] == 0)
 411   2          {
 412   3            set_func_index(MENU_STANDBY);
 413   3          }
 414   2        }
 415   1      }
 416          
 417          
 418          
 419          
 420          
 421          void Logout(void)
 422          {
 423   1        unsigned char i;
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 8   

 424   1        unsigned char Two_Menu_F3_E2_temp= 0;
 425   1        Two_Menu_F3_E2_temp = return_Two_Menu_F3_E2();
 426   1        /*销号处理函数*/
 427   1        for (i = 0; i<(Two_Menu_F3_E2_temp - 1); i++)
 428   1        {
 429   2          mcuram_to_mcuram_up(display_ram + i * 6);
 430   2        }
 431   1        for (i = (Two_Menu_F3_E2_temp - 1) * 6; i<Two_Menu_F3_E2_temp * 6; i++)
 432   1        {
 433   2          display_ram[i] = 0;
 434   2        }
 435   1        tm1629_load();
 436   1        display();
 437   1        if (display_ram[0] == 0)
 438   1        {
 439   2          set_func_index(MENU_STANDBY);
 440   2        }
 441   1      }
 442          
 443          void CycleUp(void)
 444          {
 445   1        unsigned char i, index, Two_Menu_F3_E2_temp;
 446   1        unsigned char temp[6] = { 0 };
 447   1        index = return_Two_Menu_F3_E2();
 448   1        Two_Menu_F3_E2_temp = return_Two_Menu_F3_E2();
 449   1        /*循环处理函数*/
 450   1        for (i = 0; i<Two_Menu_F3_E2_temp; i++)
 451   1        {
 452   2          if (display_ram[i * 6 ] == 0)
 453   2          {
 454   3            index = i;
 455   3            break;
 456   3          }
 457   2        }
 458   1        for (i = 0; i<6; i++)
 459   1        {
 460   2          temp[i] = display_ram[i];
 461   2        }
 462   1        for (i = 0; i<index; i++)
 463   1        {
 464   2          mcuram_to_mcuram_up(display_ram + i * 6);
 465   2        }
 466   1        for (i = 0; i<6; i++)
 467   1        {
 468   2          display_ram[(index - 1) * 6 + i] = temp[i];
 469   2        }
 470   1        tm1629_load();
 471   1        display();
 472   1      }
 473          
 474          void CycleDown(void)
 475          {
 476   1        unsigned char i, index, Two_Menu_F3_E2_temp;
 477   1        unsigned char temp[6] = { 0 };
 478   1        index = return_Two_Menu_F3_E2();
 479   1        Two_Menu_F3_E2_temp = return_Two_Menu_F3_E2();
 480   1        /*循环处理函数*/
 481   1        for (i = 0; i<Two_Menu_F3_E2_temp; i++)
 482   1        {
 483   2          if (display_ram[i * 6 ] == 0)
 484   2          {
 485   3            index = i;
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 9   

 486   3            break;
 487   3          }
 488   2        }
 489   1      
 490   1        for (i = 0; i<6; i++)
 491   1        {
 492   2          temp[i] = display_ram[(index - 1) * 6 + i];
 493   2        }
 494   1      
 495   1        for (i = index; i>1; i--)
 496   1        {
 497   2          mcuram_to_mcuram_down(display_ram + (i - 2) * 6);
 498   2        }
 499   1        for (i = 0; i<6; i++)
 500   1        {
 501   2          display_ram[i] = temp[i];
 502   2        }
 503   1        tm1629_load();
 504   1        display();
 505   1      }
 506          
 507          
 508          
 509          
 510          void fun0(void) //待机显示函数
 511          {
 512   1        //tm1629_await();
 513   1        Display_time();
 514   1      }
 515          
 516          void fun1(void) //一级菜单F0
 517          {
 518   1        tm1629_f(0x00);
 519   1      }
 520          
 521          void fun2(void) //一级菜单F1
 522          {
 523   1        tm1629_f(0x01);
 524   1      }
 525          
 526          void fun3(void) //一级菜单F2
 527          {
 528   1        tm1629_f(0x02);
 529   1      }
 530          
 531          void fun4(void) //一级菜单F3
 532          {
 533   1        tm1629_f(0x03);
 534   1      }
 535          
 536          void fun5(void) //一级菜单F4
 537          {
 538   1        tm1629_f(0x04);
 539   1      }
 540          
 541          void fun6(void) //一级菜单F5
 542          {
 543   1        tm1629_f(0x05);
 544   1      }
 545          
 546          void fun7(void) //一级菜单F6
 547          {
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 10  

 548   1        tm1629_f(0x06);
 549   1      }
 550          
 551          void fun8(void) //一级菜单F7
 552          {
 553   1        tm1629_f(0x07);
 554   1      }
 555          
 556          void fun9(void) //一级菜单F8
 557          {
 558   1        tm1629_f(0x08);
 559   1      }
 560          
 561          void fun10(void) //一级菜单F9
 562          {
 563   1        tm1629_f(0x09);
 564   1      }
 565          
 566          void fun11(void) //一级菜单FA
 567          {
 568   1        tm1629_f(0x0a);
 569   1      }
 570          
 571          void fun12(void) //一级菜单Fb
 572          {
 573   1        tm1629_f(0x0b);
 574   1      }
 575          
 576          void fun13(void) //一级菜单FC
 577          {
 578   1        tm1629_f(0x0c);
 579   1      }
 580          
 581          void fun14(void) //一级菜单Fd
 582          {
 583   1        tm1629_f(0x0d);
 584   1      }
 585          
 586          void fun15(void) //设置年份
 587          {
 588   1        if (return_await_number_table() == 1)
 589   1        {
 590   2          Display_time();
 591   2          set_await_number_table(2);
 592   2        }
 593   1        if (return_await_number_table() == 3)
 594   1        {
 595   2          buf_display[1][7] = 0;
 596   2          buf_display[1][6] = 0;
 597   2          buf_display[1][5] = 0;
 598   2          buf_display[1][4] = 0;
 599   2          display();
 600   2          set_await_number_table(0);
 601   2        }
 602   1        Ds1302_Write_Time();
 603   1      }
 604          
 605          void fun16(void) //设置月份
 606          {
 607   1        if (return_await_number_table() == 1)
 608   1        {
 609   2          Display_time();
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 11  

 610   2          set_await_number_table(2);
 611   2        }
 612   1        if (return_await_number_table() == 3)
 613   1        {
 614   2          buf_display[1][2] = 0;
 615   2          buf_display[1][1] = 0;
 616   2          display();
 617   2          set_await_number_table(0);
 618   2        }
 619   1        Ds1302_Write_Time();
 620   1      }
 621          
 622          void fun17(void) //设置日期
 623          {
 624   1        if (return_await_number_table() == 1)
 625   1        {
 626   2          Display_time();
 627   2          set_await_number_table(2);
 628   2        }
 629   1        if (return_await_number_table() == 3)
 630   1        {
 631   2          buf_display[0][7] = 0;
 632   2          buf_display[0][6] = 0;
 633   2          display();
 634   2          set_await_number_table(0);
 635   2        }
 636   1        Ds1302_Write_Time();
 637   1      }
 638          
 639          void fun18(void) //设置星期
 640          {
 641   1        if (return_await_number_table() == 1)
 642   1        {
 643   2          Display_time();
 644   2          set_await_number_table(2);
 645   2        }
 646   1        if (return_await_number_table() == 3)
 647   1        {
 648   2          buf_display[0][5] = 0;
 649   2          display();
 650   2          set_await_number_table(0);
 651   2        }
 652   1        Ds1302_Write_Time();
 653   1      }
 654          
 655          void fun19(void) //设置小时
 656          {
 657   1        if (return_await_number_table() == 1)
 658   1        {
 659   2          Display_time();
 660   2          set_await_number_table(2);
 661   2        }
 662   1        if (return_await_number_table() == 3)
 663   1        {
 664   2          buf_display[0][3] = 0;
 665   2          buf_display[0][2] = 0;
 666   2          display();
 667   2          set_await_number_table(0);
 668   2        }
 669   1        Ds1302_Write_Time();
 670   1      }
 671          
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 12  

 672          void fun20(void) //设置分钟
 673          {
 674   1        if (return_await_number_table() == 1)
 675   1        {
 676   2          Display_time();
 677   2          set_await_number_table(2);
 678   2        }
 679   1        if (return_await_number_table() == 3)
 680   1        {
 681   2          buf_display[0][1] = 0;
 682   2          buf_display[0][0] = 0;
 683   2          display();
 684   2          set_await_number_table(0);
 685   2        }
 686   1        Ds1302_Write_Time();
 687   1      }
 688          
 689          void fun21(void) //二级菜单F1-E1
 690          {
 691   1        tm1629_E(0x01);
 692   1        Two_Menu_F1_E1[0] = 0;
 693   1        Two_Menu_F1_E1[1] = 0;
 694   1        Two_Menu_F1_E1[2] = 0;
 695   1        Two_Menu_F1_E1[3] = 1;
 696   1      }
 697          
 698          void fun22(void) //二级菜单F1-E2
 699          {
 700   1        tm1629_E(0x02);
 701   1        Two_Menu_F1_E2[0] = 0;
 702   1        Two_Menu_F1_E2[1] = 0;
 703   1        Two_Menu_F1_E2[2] = 0;
 704   1        Two_Menu_F1_E2[3] = 1;
 705   1      }
 706          
 707          void fun23(void) //二级菜单F1-E3
 708          {
 709   1        tm1629_E(0x03);
 710   1        Two_Menu_F1_E3[0] = 0;
 711   1        Two_Menu_F1_E3[1] = 0;
 712   1        Two_Menu_F1_E3[2] = 0;
 713   1        Two_Menu_F1_E3[3] = 1;
 714   1      }
 715          
 716          void fun24(void) //二级菜单F1-E4
 717          {
 718   1        tm1629_E(0x04);
 719   1        Two_Menu_F1_E4[0] = 0;
 720   1        Two_Menu_F1_E4[1] = 0;
 721   1        Two_Menu_F1_E4[2] = 0;
 722   1        Two_Menu_F1_E4[3] = 1;
 723   1      }
 724          
 725          void fun25(void) //二级菜单F2-E1
 726          {
 727   1        tm1629_E(0x01);
 728   1        Two_Menu_F2_E1[0] = 0;
 729   1        Two_Menu_F2_E1[1] = 0;
 730   1        Two_Menu_F2_E1[2] = 0;
 731   1        Two_Menu_F2_E1[3] = 1;
 732   1      }
 733          
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 13  

 734          void fun26(void) //二级菜单F2-E2
 735          {
 736   1        tm1629_E(0x02);
 737   1        Two_Menu_F2_E2[0] = 0;
 738   1        Two_Menu_F2_E2[1] = 0;
 739   1        Two_Menu_F2_E2[2] = 0;
 740   1        Two_Menu_F2_E2[3] = 1;
 741   1      }
 742          
 743          void fun27(void) //二级菜单F2-E3
 744          {
 745   1        tm1629_E(0x03);
 746   1        Two_Menu_F2_E3[0] = 0;
 747   1        Two_Menu_F2_E3[1] = 0;
 748   1        Two_Menu_F2_E3[2] = 0;
 749   1        Two_Menu_F2_E3[3] = 1;
 750   1      }
 751          
 752          void fun28(void) //二级菜单F2-E4
 753          {
 754   1        tm1629_E(0x04);
 755   1        Two_Menu_F2_E4[0] = 0;
 756   1        Two_Menu_F2_E4[1] = 0;
 757   1        Two_Menu_F2_E4[2] = 0;
 758   1        Two_Menu_F2_E4[3] = 1;
 759   1      }
 760          
 761          void fun29(void) //二级菜单F3-E1
 762          {
 763   1        tm1629_E(0x01);
 764   1      }
 765          
 766          void fun30(void) //二级菜单F3-E2
 767          {
 768   1        tm1629_E(0x02);
 769   1      }
 770          
 771          void fun31(void) //二级菜单F4
 772          {
 773   1        unsigned char temp = 0;
 774   1        temp = return_Two_Menu_F4_E1();
 775   1        Show_two_number(temp);
 776   1      }
 777          
 778          void fun32(void) //二级菜单F5
 779          {
 780   1        unsigned char temp = 0;
 781   1        temp = return_Two_Menu_F5_E1();
 782   1        Show_two_number(temp);
 783   1      }
 784          
 785          void fun33(void) //二级菜单F6-E1
 786          {
 787   1        tm1629_E(0x01);
 788   1      }
 789          
 790          void fun34(void) //二级菜单F6-E2
 791          {
 792   1        tm1629_E(0x02);
 793   1      }
 794          
 795          void fun35(void) //二级菜单F6-E3
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 14  

 796          {
 797   1        tm1629_E(0x03);
 798   1      }
 799          
 800          void fun36(void) //二级菜单F6-E4
 801          {
 802   1        tm1629_E(0x04);
 803   1      }
 804          
 805          void fun37(void) //二级菜单F6-E5
 806          {
 807   1        tm1629_E(0x05);
 808   1      }
 809          
 810          void fun38(void) //二级菜单F7-E1
 811          {
 812   1        tm1629_E(0x01);
 813   1      }
 814          
 815          void fun39(void) //二级菜单F7-E2
 816          {
 817   1        tm1629_E(0x02);
 818   1      }
 819          
 820          void fun40(void) //二级菜单F7-E3
 821          {
 822   1        tm1629_E(0x03);
 823   1      }
 824          
 825          void fun41(void) //二级菜单F7-E4
 826          {
 827   1        tm1629_E(0x04);
 828   1      }
 829          
 830          void fun42(void) //二级菜单F8-E1
 831          {
 832   1        tm1629_E(0x01);
 833   1      }
 834          
 835          void fun43(void) //二级菜单F8-E2
 836          {
 837   1        tm1629_E(0x02);
 838   1      }
 839          
 840          void fun44(void) //二级菜单F9-E1
 841          {
 842   1        tm1629_E(0x01);
 843   1      }
 844          
 845          void fun45(void) //二级菜单F9-E2
 846          {
 847   1        tm1629_E(0x02);
 848   1      }
 849          
 850          void fun46(void) //二级菜单FA
 851          {
 852   1        tm1629_f(0x0f);
 853   1      }
 854          
 855          
 856          void fun47(void) //二级菜单Fb
 857          {
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 15  

 858   1        tm1629_f(0x0f);
 859   1      }
 860          
 861          void fun48(void) //二级菜单FC
 862          {
 863   1        tm1629_f(0x0f);
 864   1      }
 865          
 866          void fun49(void) //二级菜单Fd
 867          {
 868   1        tm1629_f(0x0f);
 869   1      }
 870          
 871          void fun50(void) //F1_E1 千位闪烁
 872          {
 873   1        if (return_await_number_table() == 1)
 874   1        {
 875   2          Show_four_number(Two_Menu_F1_E1);
 876   2          set_await_number_table(2);
 877   2        }
 878   1        if (return_await_number_table() == 3)
 879   1        {
 880   2          buf_display[0][3] = 0;
 881   2          display();
 882   2          set_await_number_table(0);
 883   2        }
 884   1      }
 885          
 886          void fun51(void) //F1_E1 百位闪烁
 887          {
 888   1        if (return_await_number_table() == 1)
 889   1        {
 890   2          Show_four_number(Two_Menu_F1_E1);
 891   2          set_await_number_table(2);
 892   2        }
 893   1        if (return_await_number_table() == 3)
 894   1        {
 895   2          buf_display[0][2] = 0;
 896   2          display();
 897   2          set_await_number_table(0);
 898   2        }
 899   1      }
 900          
 901          void fun52(void)  //F1_E1 十位闪烁
 902          {
 903   1        if (return_await_number_table() == 1)
 904   1        {
 905   2          Show_four_number(Two_Menu_F1_E1);
 906   2          set_await_number_table(2);
 907   2        }
 908   1        if (return_await_number_table() == 3)
 909   1        {
 910   2          buf_display[0][1] = 0;
 911   2          display();
 912   2          set_await_number_table(0);
 913   2        }
 914   1      }
 915          
 916          void fun53(void) //F1_E1 个位闪烁
 917          {
 918   1        if (return_await_number_table() == 1)
 919   1        {
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 16  

 920   2          Show_four_number(Two_Menu_F1_E1);
 921   2          set_await_number_table(2);
 922   2        }
 923   1        if (return_await_number_table() == 3)
 924   1        {
 925   2          buf_display[0][0] = 0;
 926   2          display();
 927   2          set_await_number_table(0);
 928   2        }
 929   1      }
 930          
 931          void fun54(void) //F1_E2 千位闪烁
 932          {
 933   1        if (return_await_number_table() == 1)
 934   1        {
 935   2          Show_four_number(Two_Menu_F1_E2);
 936   2          set_await_number_table(2);
 937   2        }
 938   1        if (return_await_number_table() == 3)
 939   1        {
 940   2          buf_display[0][3] = 0;
 941   2          display();
 942   2          set_await_number_table(0);
 943   2        }
 944   1      }
 945          
 946          void fun55(void) //F1_E2 百位闪烁
 947          {
 948   1        if (return_await_number_table() == 1)
 949   1        {
 950   2          Show_four_number(Two_Menu_F1_E2);
 951   2          set_await_number_table(2);
 952   2        }
 953   1        if (return_await_number_table() == 3)
 954   1        {
 955   2          buf_display[0][2] = 0;
 956   2          display();
 957   2          set_await_number_table(0);
 958   2        }
 959   1      }
 960          
 961          void fun56(void) //F1_E2 十位闪烁
 962          {
 963   1        if (return_await_number_table() == 1)
 964   1        {
 965   2          Show_four_number(Two_Menu_F1_E2);
 966   2          set_await_number_table(2);
 967   2        }
 968   1        if (return_await_number_table() == 3)
 969   1        {
 970   2          buf_display[0][1] = 0;
 971   2          display();
 972   2          set_await_number_table(0);
 973   2        }
 974   1      }
 975          
 976          void fun57(void) //F1_E2 个位闪烁
 977          {
 978   1        if (return_await_number_table() == 1)
 979   1        {
 980   2          Show_four_number(Two_Menu_F1_E2);
 981   2          set_await_number_table(2);
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 17  

 982   2        }
 983   1        if (return_await_number_table() == 3)
 984   1        {
 985   2          buf_display[0][0] = 0;
 986   2          display();
 987   2          set_await_number_table(0);
 988   2        }
 989   1      }
 990          
 991          void fun58(void) //F1_E3 千位闪烁
 992          {
 993   1        if (return_await_number_table() == 1)
 994   1        {
 995   2          Show_four_number(Two_Menu_F1_E3);
 996   2          set_await_number_table(2);
 997   2        }
 998   1        if (return_await_number_table() == 3)
 999   1        {
1000   2          buf_display[0][3] = 0;
1001   2          display();
1002   2          set_await_number_table(0);
1003   2        }
1004   1      }
1005          
1006          void fun59(void) //F1_E3 百位闪烁
1007          {
1008   1        if (return_await_number_table() == 1)
1009   1        {
1010   2          Show_four_number(Two_Menu_F1_E3);
1011   2          set_await_number_table(2);
1012   2        }
1013   1        if (return_await_number_table() == 3)
1014   1        {
1015   2          buf_display[0][2] = 0;
1016   2          display();
1017   2          set_await_number_table(0);
1018   2        }
1019   1      }
1020          
1021          void fun60(void) //F1_E3 十位闪烁
1022          {
1023   1        if (return_await_number_table() == 1)
1024   1        {
1025   2          Show_four_number(Two_Menu_F1_E3);
1026   2          set_await_number_table(2);
1027   2        }
1028   1        if (return_await_number_table() == 3)
1029   1        {
1030   2          buf_display[0][1] = 0;
1031   2          display();
1032   2          set_await_number_table(0);
1033   2        }
1034   1      }
1035          
1036          void fun61(void) //F1_E3 个位闪烁
1037          {
1038   1        if (return_await_number_table() == 1)
1039   1        {
1040   2          Show_four_number(Two_Menu_F1_E3);
1041   2          set_await_number_table(2);
1042   2        }
1043   1        if (return_await_number_table() == 3)
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 18  

1044   1        {
1045   2          buf_display[0][0] = 0;
1046   2          display();
1047   2          set_await_number_table(0);
1048   2        }
1049   1      }
1050          
1051          void fun62(void) //F1_E4 千位闪烁
1052          {
1053   1        if (return_await_number_table() == 1)
1054   1        {
1055   2          Show_four_number(Two_Menu_F1_E4);
1056   2          set_await_number_table(2);
1057   2        }
1058   1        if (return_await_number_table() == 3)
1059   1        {
1060   2          buf_display[0][3] = 0;
1061   2          display();
1062   2          set_await_number_table(0);
1063   2        }
1064   1      }
1065          
1066          void fun63(void) //F1_E4 百位闪烁
1067          {
1068   1        if (return_await_number_table() == 1)
1069   1        {
1070   2          Show_four_number(Two_Menu_F1_E4);
1071   2          set_await_number_table(2);
1072   2        }
1073   1        if (return_await_number_table() == 3)
1074   1        {
1075   2          buf_display[0][2] = 0;
1076   2          display();
1077   2          set_await_number_table(0);
1078   2        }
1079   1      }
1080          
1081          void fun64(void) //F1_E4 十位闪烁
1082          {
1083   1        if (return_await_number_table() == 1)
1084   1        {
1085   2          Show_four_number(Two_Menu_F1_E4);
1086   2          set_await_number_table(2);
1087   2        }
1088   1        if (return_await_number_table() == 3)
1089   1        {
1090   2          buf_display[0][1] = 0;
1091   2          display();
1092   2          set_await_number_table(0);
1093   2        }
1094   1      }
1095          
1096          void fun65(void) //F1_E4 个位闪烁
1097          {
1098   1        if (return_await_number_table() == 1)
1099   1        {
1100   2          Show_four_number(Two_Menu_F1_E4);
1101   2          set_await_number_table(2);
1102   2        }
1103   1        if (return_await_number_table() == 3)
1104   1        {
1105   2          buf_display[0][0] = 0;
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 19  

1106   2          display();
1107   2          set_await_number_table(0);
1108   2        }
1109   1      }
1110          
1111          void fun66(void) //F2_E1 千位闪烁
1112          {
1113   1        if (return_await_number_table() == 1)
1114   1        {
1115   2          Show_four_number(Two_Menu_F2_E1);
1116   2          set_await_number_table(2);
1117   2        }
1118   1        if (return_await_number_table() == 3)
1119   1        {
1120   2          buf_display[0][3] = 0;
1121   2          display();
1122   2          set_await_number_table(0);
1123   2        }
1124   1      }
1125          
1126          void fun67(void) //F2_E1 百位闪烁
1127          {
1128   1        if (return_await_number_table() == 1)
1129   1        {
1130   2          Show_four_number(Two_Menu_F2_E1);
1131   2          set_await_number_table(2);
1132   2        }
1133   1        if (return_await_number_table() == 3)
1134   1        {
1135   2          buf_display[0][2] = 0;
1136   2          display();
1137   2          set_await_number_table(0);
1138   2        }
1139   1      }
1140          
1141          void fun68(void) //F2_E1 十位闪烁
1142          {
1143   1        if (return_await_number_table() == 1)
1144   1        {
1145   2          Show_four_number(Two_Menu_F2_E1);
1146   2          set_await_number_table(2);
1147   2        }
1148   1        if (return_await_number_table() == 3)
1149   1        {
1150   2          buf_display[0][1] = 0;
1151   2          display();
1152   2          set_await_number_table(0);
1153   2        }
1154   1      }
1155          
1156          void fun69(void) //F2_E1 个位闪烁
1157          {
1158   1        if (return_await_number_table() == 1)
1159   1        {
1160   2          Show_four_number(Two_Menu_F2_E1);
1161   2          set_await_number_table(2);
1162   2        }
1163   1        if (return_await_number_table() == 3)
1164   1        {
1165   2          buf_display[0][0] = 0;
1166   2          display();
1167   2          set_await_number_table(0);
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 20  

1168   2        }
1169   1      }
1170          
1171          void fun70(void) //F2_E2 千位闪烁
1172          {
1173   1        if (return_await_number_table() == 1)
1174   1        {
1175   2          Show_four_number(Two_Menu_F2_E2);
1176   2          set_await_number_table(2);
1177   2        }
1178   1        if (return_await_number_table() == 3)
1179   1        {
1180   2          buf_display[0][3] = 0;
1181   2          display();
1182   2          set_await_number_table(0);
1183   2        }
1184   1      }
1185          
1186          void fun71(void) //F2_E2 百位闪烁
1187          {
1188   1        if (return_await_number_table() == 1)
1189   1        {
1190   2          Show_four_number(Two_Menu_F2_E2);
1191   2          set_await_number_table(2);
1192   2        }
1193   1        if (return_await_number_table() == 3)
1194   1        {
1195   2          buf_display[0][2] = 0;
1196   2          display();
1197   2          set_await_number_table(0);
1198   2        }
1199   1      }
1200          
1201          void fun72(void) //F2_E2 十位闪烁
1202          {
1203   1        if (return_await_number_table() == 1)
1204   1        {
1205   2          Show_four_number(Two_Menu_F2_E2);
1206   2          set_await_number_table(2);
1207   2        }
1208   1        if (return_await_number_table() == 3)
1209   1        {
1210   2          buf_display[0][1] = 0;
1211   2          display();
1212   2          set_await_number_table(0);
1213   2        }
1214   1      }
1215          
1216          void fun73(void) //F2_E2 个位闪烁
1217          {
1218   1        if (return_await_number_table() == 1)
1219   1        {
1220   2          Show_four_number(Two_Menu_F2_E2);
1221   2          set_await_number_table(2);
1222   2        }
1223   1        if (return_await_number_table() == 3)
1224   1        {
1225   2          buf_display[0][0] = 0;
1226   2          display();
1227   2          set_await_number_table(0);
1228   2        }
1229   1      }
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 21  

1230          
1231          void fun74(void) //F2_E3 千位闪烁
1232          {
1233   1        if (return_await_number_table() == 1)
1234   1        {
1235   2          Show_four_number(Two_Menu_F2_E3);
1236   2          set_await_number_table(2);
1237   2        }
1238   1        if (return_await_number_table() == 3)
1239   1        {
1240   2          buf_display[0][3] = 0;
1241   2          display();
1242   2          set_await_number_table(0);
1243   2        }
1244   1      }
1245          
1246          void fun75(void) //F2_E3 百位闪烁
1247          {
1248   1        if (return_await_number_table() == 1)
1249   1        {
1250   2          Show_four_number(Two_Menu_F2_E3);
1251   2          set_await_number_table(2);
1252   2        }
1253   1        if (return_await_number_table() == 3)
1254   1        {
1255   2          buf_display[0][2] = 0;
1256   2          display();
1257   2          set_await_number_table(0);
1258   2        }
1259   1      }
1260          
1261          void fun76(void) //F2_E3 十位闪烁
1262          {
1263   1        if (return_await_number_table() == 1)
1264   1        {
1265   2          Show_four_number(Two_Menu_F2_E3);
1266   2          set_await_number_table(2);
1267   2        }
1268   1        if (return_await_number_table() == 3)
1269   1        {
1270   2          buf_display[0][1] = 0;
1271   2          display();
1272   2          set_await_number_table(0);
1273   2        }
1274   1      }
1275          
1276          void fun77(void) //F2_E3 个位闪烁
1277          {
1278   1        if (return_await_number_table() == 1)
1279   1        {
1280   2          Show_four_number(Two_Menu_F2_E3);
1281   2          set_await_number_table(2);
1282   2        }
1283   1        if (return_await_number_table() == 3)
1284   1        {
1285   2          buf_display[0][0] = 0;
1286   2          display();
1287   2          set_await_number_table(0);
1288   2        }
1289   1      }
1290          
1291          void fun78(void) //F2_E4 千位闪烁
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 22  

1292          {
1293   1        if (return_await_number_table() == 1)
1294   1        {
1295   2          Show_four_number(Two_Menu_F2_E4);
1296   2          set_await_number_table(2);
1297   2        }
1298   1        if (return_await_number_table() == 3)
1299   1        {
1300   2          buf_display[0][3] = 0;
1301   2          display();
1302   2          set_await_number_table(0);
1303   2        }
1304   1      }
1305          
1306          void fun79(void) //F2_E4 百位闪烁
1307          {
1308   1        if (return_await_number_table() == 1)
1309   1        {
1310   2          Show_four_number(Two_Menu_F2_E4);
1311   2          set_await_number_table(2);
1312   2        }
1313   1        if (return_await_number_table() == 3)
1314   1        {
1315   2          buf_display[0][2] = 0;
1316   2          display();
1317   2          set_await_number_table(0);
1318   2        }
1319   1      }
1320          
1321          void fun80(void) //F2_E4 十位闪烁
1322          {
1323   1        if (return_await_number_table() == 1)
1324   1        {
1325   2          Show_four_number(Two_Menu_F2_E4);
1326   2          set_await_number_table(2);
1327   2        }
1328   1        if (return_await_number_table() == 3)
1329   1        {
1330   2          buf_display[0][1] = 0;
1331   2          display();
1332   2          set_await_number_table(0);
1333   2        }
1334   1      }
1335          
1336          void fun81(void) //F2_E4 个位闪烁
1337          {
1338   1        if (return_await_number_table() == 1)
1339   1        {
1340   2          Show_four_number(Two_Menu_F2_E4);
1341   2          set_await_number_table(2);
1342   2        }
1343   1        if (return_await_number_table() == 3)
1344   1        {
1345   2          buf_display[0][0] = 0;
1346   2          display();
1347   2          set_await_number_table(0);
1348   2        }
1349   1      }
1350          
1351          void fun82(void) //显示即时显示 还是循环显示
1352          {
1353   1        unsigned char temp=0;
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 23  

1354   1        temp = return_Two_Menu_F3_E1();
1355   1        Show_one_number(temp);
1356   1      }
1357          
1358          void fun83(void) //队列存储个数
1359          {
1360   1        unsigned char temp = 0;
1361   1        temp = return_Two_Menu_F3_E2();
1362   1        Show_two_number(temp);
1363   1      }
1364          
1365          void fun84(void) //F6_E1语音选择
1366          {
1367   1        unsigned char temp = 0;
1368   1        temp = return_Two_Menu_F6_E1();
1369   1        Show_one_number(temp);
1370   1      }
1371          
1372          void fun85(void) //F6_E2语音报读次数
1373          {
1374   1        unsigned char temp = 0;
1375   1        temp = return_Two_Menu_F6_E2();
1376   1        Show_one_number(temp);
1377   1      }
1378          
1379          void fun86(void) //F6_E3循环时候是否报读
1380          {
1381   1        unsigned char temp = 0;
1382   1        temp = return_Two_Menu_F6_E3();
1383   1        Show_one_number(temp);
1384   1      }
1385          
1386          void fun87(void) //F6_E4音量大小调整
1387          {
1388   1        unsigned char temp = 0;
1389   1        temp = return_Two_Menu_F6_E4();
1390   1        Show_one_number(temp);
1391   1      }
1392          
1393          void fun88(void) //F6_E5屏幕亮度调整
1394          {
1395   1        unsigned char temp = 0;
1396   1        temp = return_Two_Menu_F6_E5();
1397   1        Show_one_number(temp);
1398   1      }
1399          
1400          void fun89(void) //F7_E1 999*9
1401          {
1402   1        unsigned char temp = 0;
1403   1        temp = return_Two_Menu_F7_E1();
1404   1        Show_one_number(temp);
1405   1      }
1406          
1407          void fun90(void) //F7_E2 9999*9
1408          {
1409   1        unsigned char temp = 0;
1410   1        temp = return_Two_Menu_F7_E2();
1411   1        Show_one_number(temp);
1412   1      }
1413          
1414          void fun91(void) //F7_E3 999*99
1415          {
C51 COMPILER V9.00   TM1629                                                                09/18/2015 17:31:09 PAGE 24  

1416   1        unsigned char temp = 0;
1417   1        temp = return_Two_Menu_F7_E3();
1418   1        Show_one_number(temp);
1419   1      }
1420          
1421          void fun92(void) //F7_E4 9999*99
1422          {
1423   1        unsigned char temp = 0;
1424   1        temp = return_Two_Menu_F7_E4();
1425   1        Show_one_number(temp);
1426   1      }
1427          
1428          void fun93(void) //F8_E1单键位跟多键位切换
1429          {
1430   1        unsigned char temp = 0;
1431   1        temp = return_Two_Menu_F8_E1();
1432   1        Show_one_number(temp);
1433   1      }
1434          
1435          void fun94(void) //F8_E2键位设置
1436          {
1437   1        unsigned char temp = 0;
1438   1        temp = return_Two_Menu_F8_E2();
1439   1        Show_two_number(temp);
1440   1      }
1441          
1442          void fun95(void) //解码菜单
1443          {
1444   1        tm1629_load();
1445   1        display();;
1446   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4839    ----
   CONSTANT SIZE    =     18    ----
   XDATA SIZE       =    320      46
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
