C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE TM1629
OBJECT MODULE PLACED IN tm1629.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\tm1629.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRINT(
                    -.\tm1629.lst) TABS(2) OBJECT(tm1629.obj)

line level    source

   1          #include "tm1629.h"
   2          #include "timer.h"
   3          #include "usart.h"
   4          #include "ds1302.h"
   5          #include "key.h"
   6          
   7          unsigned char const CODE[] = { 0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 0x3
             -9, 0x5E, 0x79, 0x71, 0x76, 0x38, 0x5c, 0x73, 0x3e };//0-9 abcdef 显示器码数组
   8          unsigned char const INIT_CODE[] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };//逐段点亮数码管数组
   9          unsigned char const SHANGSHUO[] = { 0x40, 0x00 }; // 点亮数码管中间段以及灭
  10          unsigned char buf_display[6][8] = { 0 }; //3个TM1629显存数组
  11          unsigned char display_ram[240] = { 0 }; //程序运行时记录显示数据的内存 
  12          unsigned char await_time_table= 0 ;//用于记录待机显示横杠数码管次数 
  13          
  14          void writeDataTo1629(unsigned char p) //写数据给第一个TM1629
  15          {
  16   1        unsigned int i;
  17   1        TM1629_STB = 0;
  18   1        for (i = 0; i<8; i++)
  19   1        {
  20   2          TM1629_CLK = 0;
  21   2          if (p & 0x01)
  22   2            TM1629_DIO = 1;
  23   2          else
  24   2            TM1629_DIO = 0;
  25   2          _nop_();
  26   2          _nop_();
  27   2          _nop_();
  28   2          _nop_();
  29   2          TM1629_CLK = 1;
  30   2          p = p >> 1;
  31   2        }
  32   1        TM1629_CLK = 0;
  33   1        TM1629_DIO = 0;
  34   1      }
  35          
  36          void writeDataTo1629_2(unsigned char p) //写数据给第二个TM1629
  37          {
  38   1        unsigned int i;
  39   1        TM1629_STB2 = 0;
  40   1        for (i = 0; i<8; i++)
  41   1        {
  42   2          TM1629_CLK = 0;
  43   2          if (p & 0x01)
  44   2            TM1629_DIO = 1;
  45   2          else
  46   2            TM1629_DIO = 0;
  47   2          _nop_();
  48   2          _nop_();
  49   2          _nop_();
  50   2          _nop_();
  51   2          TM1629_CLK = 1;
  52   2          p = p >> 1;
  53   2        }
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 2   

  54   1        TM1629_CLK = 0;
  55   1        TM1629_DIO = 0;
  56   1      }
  57          
  58          void writeDataTo1629_3(unsigned char p) //写数据给第三个TM1629
  59          {
  60   1        unsigned int i;
  61   1        TM1629_STB3 = 0;
  62   1        for (i = 0; i<8; i++)
  63   1        {
  64   2          TM1629_CLK = 0;
  65   2          if (p & 0x01)
  66   2            TM1629_DIO = 1;
  67   2          else
  68   2            TM1629_DIO = 0;
  69   2          _nop_();
  70   2          _nop_();
  71   2          _nop_();
  72   2          _nop_();
  73   2          TM1629_CLK = 1;
  74   2          p = p >> 1;
  75   2        }
  76   1        TM1629_CLK = 0;
  77   1        TM1629_DIO = 0;
  78   1      }
  79          
  80          void send_command(unsigned char word) //写命令给第一个TM1629
  81          {
  82   1        TM1629_STB = 1;
  83   1        nop;
  84   1        TM1629_STB = 0;
  85   1        writeDataTo1629(word);
  86   1      }
  87          
  88          void send_command_2(unsigned char word) //写命令给第二个TM1629
  89          {
  90   1        TM1629_STB2 = 1;
  91   1        nop;
  92   1        TM1629_STB2 = 0;
  93   1        writeDataTo1629_2(word);
  94   1      }
  95          
  96          void send_command_3(unsigned char word) //写命令给第三个TM1629
  97          {
  98   1        TM1629_STB3 = 1;
  99   1        nop;
 100   1        TM1629_STB3 = 0;
 101   1        writeDataTo1629_3(word);
 102   1      }
 103          
 104          void display(void) //3个TM1629显示函数
 105          {
 106   1        unsigned char i;
 107   1        send_command(0x40); //设置数据命令:普通模式、地址自增1，写数据到显存
 108   1        send_command(0xc0); //设置显示地址命令：从00H开始
 109   1        for (i = 0; i<8; i++) //发送16字节的显存数据
 110   1        {
 111   2          writeDataTo1629(buf_display[0][i]);
 112   2          writeDataTo1629(buf_display[1][i]);
 113   2        }
 114   1        send_command(0x8C); //设置显示控制命令：打开显示，并设置为11/16.
 115   1        TM1629_STB = 1;
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 3   

 116   1      
 117   1        send_command_2(0x40); //设置数据命令:普通模式、地址自增1，写数据到显存
 118   1        send_command_2(0xc0); //设置显示地址命令：从00H开始
 119   1        for (i = 0; i<8; i++) //发送16字节的显存数据
 120   1        {
 121   2          writeDataTo1629_2(buf_display[2][i]);
 122   2          writeDataTo1629_2(buf_display[3][i]);
 123   2        }
 124   1        send_command_2(0x8C); //设置显示控制命令：打开显示，并设置为11/16.
 125   1        TM1629_STB2 = 1;
 126   1      
 127   1        send_command_3(0x40); //设置数据命令:普通模式、地址自增1，写数据到显存
 128   1        send_command_3(0xc0); //设置显示地址命令：从00H开始
 129   1        for (i = 0; i<8; i++) //发送16字节的显存数据
 130   1        {
 131   2          writeDataTo1629_3(buf_display[4][i]);
 132   2          writeDataTo1629_3(buf_display[5][i]);
 133   2        }
 134   1        send_command_3(0x8C); //设置显示控制命令：打开显示，并设置为11/16.
 135   1        TM1629_STB3 = 1;
 136   1      }
 137          
 138          void tm1629_init(void) //TM1629开机初始化函数
 139          {
 140   1        unsigned char i, j, k;    //k控制显示的具体数字，i和j控制buf_display的刷新
 141   1        for (k = 0; k<8; k++)
 142   1        {
 143   2          for (i = 0; i<6; i++)
 144   2          {
 145   3            for (j = 0; j<8; j++)
 146   3            {
 147   4              buf_display[i][j] = INIT_CODE[k];
 148   4            }
 149   3          }
 150   2          display();
 151   2          Tm1629_delay(30);
 152   2        }
 153   1      }
 154          
 155          
 156          void Tm1629_delay(unsigned char k) //延时函数
 157          {
 158   1        unsigned char i, j;
 159   1        for (; k>0; k--)
 160   1        {
 161   2          for (i = 255; i>0; i--)
 162   2          {
 163   3            for (j = 255; j>0; j--)
 164   3            {
 165   4              ;
 166   4      
 167   4            }
 168   3          }
 169   2        }
 170   1      }
 171          
 172          void tm1629_clear(void)//全部归零
 173          {
 174   1        unsigned char i, j;
 175   1        for (i = 0; i<6; i++)
 176   1        {
 177   2          for (j = 0; j<8; j++)
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 4   

 178   2          {
 179   3            buf_display[i][j] = 0x00;
 180   3          }
 181   2        }
 182   1      }
 183          
 184          void tm1629_await(void)
 185          {
 186   1        unsigned char i;  //k控制显示的具体数字，i和j控制buf_display的刷新
 187   1        unsigned char await_number_table_temp = 0;
 188   1        await_number_table_temp = return_await_number_table();
 189   1        if (await_number_table_temp == 1)
 190   1        {
 191   2          //GD5800_select_chapter(0x0008) ;
 192   2          tm1629_clear();
 193   2          i = await_time_table & 0x03;
 194   2          buf_display[0][i] = 0x40;
 195   2          display();
 196   2          set_await_number_table(0);
 197   2          await_time_table++;
 198   2          if (await_time_table == 4)
 199   2            await_time_table = 0;
 200   2        }
 201   1      }
 202          
 203          void Display_time(void)
 204          {
 205   1        tm1629_clear();
 206   1        Ds1302_Read_Time(); 
 207   1        buf_display[1][7] = CODE[2];        //年
 208   1        buf_display[1][6] = CODE[0];
 209   1        buf_display[1][5] = CODE[time_buf1[1] / 10];
 210   1        buf_display[1][4] = CODE[time_buf1[1] % 10];
 211   1      
 212   1        buf_display[1][3] = 0x40;          // -
 213   1        
 214   1        buf_display[1][2] = CODE[time_buf1[2] / 10]; //月
 215   1        buf_display[1][1] = CODE[time_buf1[2] % 10];
 216   1      
 217   1        buf_display[1][0] = 0x40;          // -
 218   1      
 219   1        buf_display[0][7] = CODE[time_buf1[3] / 10];
 220   1        buf_display[0][6] = CODE[time_buf1[3] % 10];//日
 221   1      
 222   1        buf_display[0][5] = CODE[time_buf1[7]];   //星期
 223   1      
 224   1        buf_display[0][3] = CODE[time_buf1[4] / 10]; //小时
 225   1        buf_display[0][2] = CODE[time_buf1[4] % 10];
 226   1        buf_display[0][1] = CODE[time_buf1[5] / 10]; //小时
 227   1        buf_display[0][0] = CODE[time_buf1[5] % 10];
 228   1      
 229   1        display();
 230   1      
 231   1      }
 232          
 233          void tm1629_f(unsigned char f_number) //第一行倒数二个显示F,倒数第一个显示f_number
 234          {
 235   1        tm1629_clear();
 236   1        buf_display[0][1] = CODE[0x0f];
 237   1        buf_display[0][0] = CODE[f_number];
 238   1        display();
 239   1      }
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 5   

 240          
 241          void tm1629_E(unsigned char f_number) //第一行倒数二个显示F,倒数第一个显示f_number
 242          {
 243   1        tm1629_clear();
 244   1        buf_display[0][1] = CODE[0x0E];
 245   1        buf_display[0][0] = CODE[f_number];
 246   1        display();
 247   1      }
 248          
 249          void Show_one_number(unsigned char f_number) //显示一个数字
 250          {
 251   1        tm1629_clear();
 252   1        //buf_display[0][1] = CODE[0x0E];
 253   1        buf_display[0][0] = CODE[f_number];
 254   1        display();
 255   1      }
 256          
 257          void Show_two_number(unsigned char f_number) //显示两个数字
 258          {
 259   1        tm1629_clear();
 260   1        buf_display[0][1] = CODE[f_number / 10];
 261   1        buf_display[0][0] = CODE[f_number % 10];
 262   1        display();
 263   1      }
 264          
 265          void Show_four_number(unsigned char* temp)
 266          {
 267   1        tm1629_clear();
 268   1        buf_display[0][3] = CODE[*(temp)];
 269   1        buf_display[0][2] = CODE[*(temp+1)];
 270   1        buf_display[0][1] = CODE[*(temp+2)];
 271   1        buf_display[0][0] = CODE[*(temp+3)];
 272   1        display();
 273   1      }
 274          
 275          void fun0(void) //待机显示函数
 276          {
 277   1        //tm1629_await();
 278   1        Display_time();
 279   1      }
 280          
 281          void fun1(void) //一级菜单F0
 282          {
 283   1        tm1629_f(0x00);
 284   1      }
 285          
 286          void fun2(void) //一级菜单F1
 287          {
 288   1        tm1629_f(0x01);
 289   1      }
 290          
 291          void fun3(void) //一级菜单F2
 292          {
 293   1        tm1629_f(0x02);
 294   1      }
 295          
 296          void fun4(void) //一级菜单F3
 297          {
 298   1        tm1629_f(0x03);
 299   1      }
 300          
 301          void fun5(void) //一级菜单F4
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 6   

 302          {
 303   1        tm1629_f(0x04);
 304   1      }
 305          
 306          void fun6(void) //一级菜单F5
 307          {
 308   1        tm1629_f(0x05);
 309   1      }
 310          
 311          void fun7(void) //一级菜单F6
 312          {
 313   1        tm1629_f(0x06);
 314   1      }
 315          
 316          void fun8(void) //一级菜单F7
 317          {
 318   1        tm1629_f(0x07);
 319   1      }
 320          
 321          void fun9(void) //一级菜单F8
 322          {
 323   1        tm1629_f(0x08);
 324   1      }
 325          
 326          void fun10(void) //一级菜单F9
 327          {
 328   1        tm1629_f(0x09);
 329   1      }
 330          
 331          void fun11(void) //一级菜单FA
 332          {
 333   1        tm1629_f(0x0a);
 334   1      }
 335          
 336          void fun12(void) //一级菜单Fb
 337          {
 338   1        tm1629_f(0x0b);
 339   1      }
 340          
 341          void fun13(void) //一级菜单FC
 342          {
 343   1        tm1629_f(0x0c);
 344   1      }
 345          
 346          void fun14(void) //一级菜单Fd
 347          {
 348   1        tm1629_f(0x0d);
 349   1      }
 350          
 351          void fun15(void) //设置年份
 352          {
 353   1        if (return_await_number_table() == 1)
 354   1        {
 355   2          Display_time();
 356   2          set_await_number_table(2);
 357   2        }
 358   1        if (return_await_number_table() == 3)
 359   1        {
 360   2          buf_display[1][7] = 0;
 361   2          buf_display[1][6] = 0;
 362   2          buf_display[1][5] = 0;
 363   2          buf_display[1][4] = 0;
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 7   

 364   2          display();
 365   2          set_await_number_table(0);
 366   2        }
 367   1        Ds1302_Write_Time();
 368   1      }
 369          
 370          void fun16(void) //设置月份
 371          {
 372   1        if (return_await_number_table() == 1)
 373   1        {
 374   2          Display_time();
 375   2          set_await_number_table(2);
 376   2        }
 377   1        if (return_await_number_table() == 3)
 378   1        {
 379   2          buf_display[1][2] = 0;
 380   2          buf_display[1][1] = 0;
 381   2          display();
 382   2          set_await_number_table(0);
 383   2        }
 384   1        Ds1302_Write_Time();
 385   1      }
 386          
 387          void fun17(void) //设置日期
 388          {
 389   1        if (return_await_number_table() == 1)
 390   1        {
 391   2          Display_time();
 392   2          set_await_number_table(2);
 393   2        }
 394   1        if (return_await_number_table() == 3)
 395   1        {
 396   2          buf_display[0][7] = 0;
 397   2          buf_display[0][6] = 0;
 398   2          display();
 399   2          set_await_number_table(0);
 400   2        }
 401   1        Ds1302_Write_Time();
 402   1      }
 403          
 404          void fun18(void) //设置星期
 405          {
 406   1        if (return_await_number_table() == 1)
 407   1        {
 408   2          Display_time();
 409   2          set_await_number_table(2);
 410   2        }
 411   1        if (return_await_number_table() == 3)
 412   1        {
 413   2          buf_display[0][5] = 0;
 414   2          display();
 415   2          set_await_number_table(0);
 416   2        }
 417   1        Ds1302_Write_Time();
 418   1      }
 419          
 420          void fun19(void) //设置小时
 421          {
 422   1        if (return_await_number_table() == 1)
 423   1        {
 424   2          Display_time();
 425   2          set_await_number_table(2);
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 8   

 426   2        }
 427   1        if (return_await_number_table() == 3)
 428   1        {
 429   2          buf_display[0][3] = 0;
 430   2          buf_display[0][2] = 0;
 431   2          display();
 432   2          set_await_number_table(0);
 433   2        }
 434   1        Ds1302_Write_Time();
 435   1      }
 436          
 437          void fun20(void) //设置分钟
 438          {
 439   1        if (return_await_number_table() == 1)
 440   1        {
 441   2          Display_time();
 442   2          set_await_number_table(2);
 443   2        }
 444   1        if (return_await_number_table() == 3)
 445   1        {
 446   2          buf_display[0][1] = 0;
 447   2          buf_display[0][0] = 0;
 448   2          display();
 449   2          set_await_number_table(0);
 450   2        }
 451   1        Ds1302_Write_Time();
 452   1      }
 453          
 454          void fun21(void) //二级菜单F1-E1
 455          {
 456   1        tm1629_E(0x01);
 457   1        Two_Menu_F1_E1[0] = 0;
 458   1        Two_Menu_F1_E1[1] = 0;
 459   1        Two_Menu_F1_E1[2] = 0;
 460   1        Two_Menu_F1_E1[3] = 1;
 461   1      }
 462          
 463          void fun22(void) //二级菜单F1-E2
 464          {
 465   1        tm1629_E(0x02);
 466   1        Two_Menu_F1_E2[0] = 0;
 467   1        Two_Menu_F1_E2[1] = 0;
 468   1        Two_Menu_F1_E2[2] = 0;
 469   1        Two_Menu_F1_E2[3] = 1;
 470   1      }
 471          
 472          void fun23(void) //二级菜单F1-E3
 473          {
 474   1        tm1629_E(0x03);
 475   1        Two_Menu_F1_E3[0] = 0;
 476   1        Two_Menu_F1_E3[1] = 0;
 477   1        Two_Menu_F1_E3[2] = 0;
 478   1        Two_Menu_F1_E3[3] = 1;
 479   1      }
 480          
 481          void fun24(void) //二级菜单F1-E4
 482          {
 483   1        tm1629_E(0x04);
 484   1        Two_Menu_F1_E4[0] = 0;
 485   1        Two_Menu_F1_E4[1] = 0;
 486   1        Two_Menu_F1_E4[2] = 0;
 487   1        Two_Menu_F1_E4[3] = 1;
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 9   

 488   1      }
 489          
 490          void fun25(void) //二级菜单F2-E1
 491          {
 492   1        tm1629_E(0x01);
 493   1        Two_Menu_F2_E1[0] = 0;
 494   1        Two_Menu_F2_E1[1] = 0;
 495   1        Two_Menu_F2_E1[2] = 0;
 496   1        Two_Menu_F2_E1[3] = 1;
 497   1      }
 498          
 499          void fun26(void) //二级菜单F2-E2
 500          {
 501   1        tm1629_E(0x02);
 502   1        Two_Menu_F2_E2[0] = 0;
 503   1        Two_Menu_F2_E2[1] = 0;
 504   1        Two_Menu_F2_E2[2] = 0;
 505   1        Two_Menu_F2_E2[3] = 1;
 506   1      }
 507          
 508          void fun27(void) //二级菜单F2-E3
 509          {
 510   1        tm1629_E(0x03);
 511   1        Two_Menu_F2_E3[0] = 0;
 512   1        Two_Menu_F2_E3[1] = 0;
 513   1        Two_Menu_F2_E3[2] = 0;
 514   1        Two_Menu_F2_E3[3] = 1;
 515   1      }
 516          
 517          void fun28(void) //二级菜单F2-E4
 518          {
 519   1        tm1629_E(0x04);
 520   1        Two_Menu_F2_E4[0] = 0;
 521   1        Two_Menu_F2_E4[1] = 0;
 522   1        Two_Menu_F2_E4[2] = 0;
 523   1        Two_Menu_F2_E4[3] = 1;
 524   1      }
 525          
 526          void fun29(void) //二级菜单F3-E1
 527          {
 528   1        tm1629_E(0x01);
 529   1      }
 530          
 531          void fun30(void) //二级菜单F3-E2
 532          {
 533   1        tm1629_E(0x02);
 534   1      }
 535          
 536          void fun31(void) //二级菜单F4
 537          {
 538   1        unsigned char temp = 0;
 539   1        temp = return_Two_Menu_F4_E1();
 540   1        Show_two_number(temp);
 541   1      }
 542          
 543          void fun32(void) //二级菜单F5
 544          {
 545   1        unsigned char temp = 0;
 546   1        temp = return_Two_Menu_F5_E1();
 547   1        Show_two_number(temp);
 548   1      }
 549          
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 10  

 550          void fun33(void) //二级菜单F6-E1
 551          {
 552   1        tm1629_E(0x01);
 553   1      }
 554          
 555          void fun34(void) //二级菜单F6-E2
 556          {
 557   1        tm1629_E(0x02);
 558   1      }
 559          
 560          void fun35(void) //二级菜单F6-E3
 561          {
 562   1        tm1629_E(0x03);
 563   1      }
 564          
 565          void fun36(void) //二级菜单F6-E4
 566          {
 567   1        tm1629_E(0x04);
 568   1      }
 569          
 570          void fun37(void) //二级菜单F6-E5
 571          {
 572   1        tm1629_E(0x05);
 573   1      }
 574          
 575          void fun38(void) //二级菜单F7-E1
 576          {
 577   1        tm1629_E(0x01);
 578   1      }
 579          
 580          void fun39(void) //二级菜单F7-E2
 581          {
 582   1        tm1629_E(0x02);
 583   1      }
 584          
 585          void fun40(void) //二级菜单F7-E3
 586          {
 587   1        tm1629_E(0x03);
 588   1      }
 589          
 590          void fun41(void) //二级菜单F7-E4
 591          {
 592   1        tm1629_E(0x04);
 593   1      }
 594          
 595          void fun42(void) //二级菜单F8-E1
 596          {
 597   1        tm1629_E(0x01);
 598   1      }
 599          
 600          void fun43(void) //二级菜单F8-E2
 601          {
 602   1        tm1629_E(0x02);
 603   1      }
 604          
 605          void fun44(void) //二级菜单F9-E1
 606          {
 607   1        tm1629_E(0x01);
 608   1      }
 609          
 610          void fun45(void) //二级菜单F9-E2
 611          {
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 11  

 612   1        tm1629_E(0x02);
 613   1      }
 614          
 615          void fun46(void) //二级菜单FA
 616          {
 617   1        tm1629_f(0x0f);
 618   1      }
 619          
 620          
 621          void fun47(void) //二级菜单Fb
 622          {
 623   1        tm1629_f(0x0f);
 624   1      }
 625          
 626          void fun48(void) //二级菜单FC
 627          {
 628   1        tm1629_f(0x0f);
 629   1      }
 630          
 631          void fun49(void) //二级菜单Fd
 632          {
 633   1        tm1629_f(0x0f);
 634   1      }
 635          
 636          void fun50(void) //F1_E1 千位闪烁
 637          {
 638   1        if (return_await_number_table() == 1)
 639   1        {
 640   2          Show_four_number(Two_Menu_F1_E1);
 641   2          set_await_number_table(2);
 642   2        }
 643   1        if (return_await_number_table() == 3)
 644   1        {
 645   2          buf_display[0][3] = 0;
 646   2          display();
 647   2          set_await_number_table(0);
 648   2        }
 649   1      }
 650          
 651          void fun51(void) //F1_E1 百位闪烁
 652          {
 653   1        if (return_await_number_table() == 1)
 654   1        {
 655   2          Show_four_number(Two_Menu_F1_E1);
 656   2          set_await_number_table(2);
 657   2        }
 658   1        if (return_await_number_table() == 3)
 659   1        {
 660   2          buf_display[0][2] = 0;
 661   2          display();
 662   2          set_await_number_table(0);
 663   2        }
 664   1      }
 665          
 666          void fun52(void)  //F1_E1 十位闪烁
 667          {
 668   1        if (return_await_number_table() == 1)
 669   1        {
 670   2          Show_four_number(Two_Menu_F1_E1);
 671   2          set_await_number_table(2);
 672   2        }
 673   1        if (return_await_number_table() == 3)
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 12  

 674   1        {
 675   2          buf_display[0][1] = 0;
 676   2          display();
 677   2          set_await_number_table(0);
 678   2        }
 679   1      }
 680          
 681          void fun53(void) //F1_E1 个位闪烁
 682          {
 683   1        if (return_await_number_table() == 1)
 684   1        {
 685   2          Show_four_number(Two_Menu_F1_E1);
 686   2          set_await_number_table(2);
 687   2        }
 688   1        if (return_await_number_table() == 3)
 689   1        {
 690   2          buf_display[0][0] = 0;
 691   2          display();
 692   2          set_await_number_table(0);
 693   2        }
 694   1      }
 695          
 696          void fun54(void) //F1_E2 千位闪烁
 697          {
 698   1        if (return_await_number_table() == 1)
 699   1        {
 700   2          Show_four_number(Two_Menu_F1_E2);
 701   2          set_await_number_table(2);
 702   2        }
 703   1        if (return_await_number_table() == 3)
 704   1        {
 705   2          buf_display[0][3] = 0;
 706   2          display();
 707   2          set_await_number_table(0);
 708   2        }
 709   1      }
 710          
 711          void fun55(void) //F1_E2 百位闪烁
 712          {
 713   1        if (return_await_number_table() == 1)
 714   1        {
 715   2          Show_four_number(Two_Menu_F1_E2);
 716   2          set_await_number_table(2);
 717   2        }
 718   1        if (return_await_number_table() == 3)
 719   1        {
 720   2          buf_display[0][2] = 0;
 721   2          display();
 722   2          set_await_number_table(0);
 723   2        }
 724   1      }
 725          
 726          void fun56(void) //F1_E2 十位闪烁
 727          {
 728   1        if (return_await_number_table() == 1)
 729   1        {
 730   2          Show_four_number(Two_Menu_F1_E2);
 731   2          set_await_number_table(2);
 732   2        }
 733   1        if (return_await_number_table() == 3)
 734   1        {
 735   2          buf_display[0][1] = 0;
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 13  

 736   2          display();
 737   2          set_await_number_table(0);
 738   2        }
 739   1      }
 740          
 741          void fun57(void) //F1_E2 个位闪烁
 742          {
 743   1        if (return_await_number_table() == 1)
 744   1        {
 745   2          Show_four_number(Two_Menu_F1_E2);
 746   2          set_await_number_table(2);
 747   2        }
 748   1        if (return_await_number_table() == 3)
 749   1        {
 750   2          buf_display[0][0] = 0;
 751   2          display();
 752   2          set_await_number_table(0);
 753   2        }
 754   1      }
 755          
 756          void fun58(void) //F1_E3 千位闪烁
 757          {
 758   1        if (return_await_number_table() == 1)
 759   1        {
 760   2          Show_four_number(Two_Menu_F1_E3);
 761   2          set_await_number_table(2);
 762   2        }
 763   1        if (return_await_number_table() == 3)
 764   1        {
 765   2          buf_display[0][3] = 0;
 766   2          display();
 767   2          set_await_number_table(0);
 768   2        }
 769   1      }
 770          
 771          void fun59(void) //F1_E3 百位闪烁
 772          {
 773   1        if (return_await_number_table() == 1)
 774   1        {
 775   2          Show_four_number(Two_Menu_F1_E3);
 776   2          set_await_number_table(2);
 777   2        }
 778   1        if (return_await_number_table() == 3)
 779   1        {
 780   2          buf_display[0][2] = 0;
 781   2          display();
 782   2          set_await_number_table(0);
 783   2        }
 784   1      }
 785          
 786          void fun60(void) //F1_E3 十位闪烁
 787          {
 788   1        if (return_await_number_table() == 1)
 789   1        {
 790   2          Show_four_number(Two_Menu_F1_E3);
 791   2          set_await_number_table(2);
 792   2        }
 793   1        if (return_await_number_table() == 3)
 794   1        {
 795   2          buf_display[0][1] = 0;
 796   2          display();
 797   2          set_await_number_table(0);
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 14  

 798   2        }
 799   1      }
 800          
 801          void fun61(void) //F1_E3 个位闪烁
 802          {
 803   1        if (return_await_number_table() == 1)
 804   1        {
 805   2          Show_four_number(Two_Menu_F1_E3);
 806   2          set_await_number_table(2);
 807   2        }
 808   1        if (return_await_number_table() == 3)
 809   1        {
 810   2          buf_display[0][0] = 0;
 811   2          display();
 812   2          set_await_number_table(0);
 813   2        }
 814   1      }
 815          
 816          void fun62(void) //F1_E4 千位闪烁
 817          {
 818   1        if (return_await_number_table() == 1)
 819   1        {
 820   2          Show_four_number(Two_Menu_F1_E4);
 821   2          set_await_number_table(2);
 822   2        }
 823   1        if (return_await_number_table() == 3)
 824   1        {
 825   2          buf_display[0][3] = 0;
 826   2          display();
 827   2          set_await_number_table(0);
 828   2        }
 829   1      }
 830          
 831          void fun63(void) //F1_E4 百位闪烁
 832          {
 833   1        if (return_await_number_table() == 1)
 834   1        {
 835   2          Show_four_number(Two_Menu_F1_E4);
 836   2          set_await_number_table(2);
 837   2        }
 838   1        if (return_await_number_table() == 3)
 839   1        {
 840   2          buf_display[0][2] = 0;
 841   2          display();
 842   2          set_await_number_table(0);
 843   2        }
 844   1      }
 845          
 846          void fun64(void) //F1_E4 十位闪烁
 847          {
 848   1        if (return_await_number_table() == 1)
 849   1        {
 850   2          Show_four_number(Two_Menu_F1_E4);
 851   2          set_await_number_table(2);
 852   2        }
 853   1        if (return_await_number_table() == 3)
 854   1        {
 855   2          buf_display[0][1] = 0;
 856   2          display();
 857   2          set_await_number_table(0);
 858   2        }
 859   1      }
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 15  

 860          
 861          void fun65(void) //F1_E4 个位闪烁
 862          {
 863   1        if (return_await_number_table() == 1)
 864   1        {
 865   2          Show_four_number(Two_Menu_F1_E4);
 866   2          set_await_number_table(2);
 867   2        }
 868   1        if (return_await_number_table() == 3)
 869   1        {
 870   2          buf_display[0][0] = 0;
 871   2          display();
 872   2          set_await_number_table(0);
 873   2        }
 874   1      }
 875          
 876          void fun66(void) //F2_E1 千位闪烁
 877          {
 878   1        if (return_await_number_table() == 1)
 879   1        {
 880   2          Show_four_number(Two_Menu_F2_E1);
 881   2          set_await_number_table(2);
 882   2        }
 883   1        if (return_await_number_table() == 3)
 884   1        {
 885   2          buf_display[0][3] = 0;
 886   2          display();
 887   2          set_await_number_table(0);
 888   2        }
 889   1      }
 890          
 891          void fun67(void) //F2_E1 百位闪烁
 892          {
 893   1        if (return_await_number_table() == 1)
 894   1        {
 895   2          Show_four_number(Two_Menu_F2_E1);
 896   2          set_await_number_table(2);
 897   2        }
 898   1        if (return_await_number_table() == 3)
 899   1        {
 900   2          buf_display[0][2] = 0;
 901   2          display();
 902   2          set_await_number_table(0);
 903   2        }
 904   1      }
 905          
 906          void fun68(void) //F2_E1 十位闪烁
 907          {
 908   1        if (return_await_number_table() == 1)
 909   1        {
 910   2          Show_four_number(Two_Menu_F2_E1);
 911   2          set_await_number_table(2);
 912   2        }
 913   1        if (return_await_number_table() == 3)
 914   1        {
 915   2          buf_display[0][1] = 0;
 916   2          display();
 917   2          set_await_number_table(0);
 918   2        }
 919   1      }
 920          
 921          void fun69(void) //F2_E1 个位闪烁
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 16  

 922          {
 923   1        if (return_await_number_table() == 1)
 924   1        {
 925   2          Show_four_number(Two_Menu_F2_E1);
 926   2          set_await_number_table(2);
 927   2        }
 928   1        if (return_await_number_table() == 3)
 929   1        {
 930   2          buf_display[0][0] = 0;
 931   2          display();
 932   2          set_await_number_table(0);
 933   2        }
 934   1      }
 935          
 936          void fun70(void) //F2_E2 千位闪烁
 937          {
 938   1        if (return_await_number_table() == 1)
 939   1        {
 940   2          Show_four_number(Two_Menu_F2_E2);
 941   2          set_await_number_table(2);
 942   2        }
 943   1        if (return_await_number_table() == 3)
 944   1        {
 945   2          buf_display[0][3] = 0;
 946   2          display();
 947   2          set_await_number_table(0);
 948   2        }
 949   1      }
 950          
 951          void fun71(void) //F2_E2 百位闪烁
 952          {
 953   1        if (return_await_number_table() == 1)
 954   1        {
 955   2          Show_four_number(Two_Menu_F2_E2);
 956   2          set_await_number_table(2);
 957   2        }
 958   1        if (return_await_number_table() == 3)
 959   1        {
 960   2          buf_display[0][2] = 0;
 961   2          display();
 962   2          set_await_number_table(0);
 963   2        }
 964   1      }
 965          
 966          void fun72(void) //F2_E2 十位闪烁
 967          {
 968   1        if (return_await_number_table() == 1)
 969   1        {
 970   2          Show_four_number(Two_Menu_F2_E2);
 971   2          set_await_number_table(2);
 972   2        }
 973   1        if (return_await_number_table() == 3)
 974   1        {
 975   2          buf_display[0][1] = 0;
 976   2          display();
 977   2          set_await_number_table(0);
 978   2        }
 979   1      }
 980          
 981          void fun73(void) //F2_E2 个位闪烁
 982          {
 983   1        if (return_await_number_table() == 1)
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 17  

 984   1        {
 985   2          Show_four_number(Two_Menu_F2_E2);
 986   2          set_await_number_table(2);
 987   2        }
 988   1        if (return_await_number_table() == 3)
 989   1        {
 990   2          buf_display[0][0] = 0;
 991   2          display();
 992   2          set_await_number_table(0);
 993   2        }
 994   1      }
 995          
 996          void fun74(void) //F2_E3 千位闪烁
 997          {
 998   1        if (return_await_number_table() == 1)
 999   1        {
1000   2          Show_four_number(Two_Menu_F2_E3);
1001   2          set_await_number_table(2);
1002   2        }
1003   1        if (return_await_number_table() == 3)
1004   1        {
1005   2          buf_display[0][3] = 0;
1006   2          display();
1007   2          set_await_number_table(0);
1008   2        }
1009   1      }
1010          
1011          void fun75(void) //F2_E3 百位闪烁
1012          {
1013   1        if (return_await_number_table() == 1)
1014   1        {
1015   2          Show_four_number(Two_Menu_F2_E3);
1016   2          set_await_number_table(2);
1017   2        }
1018   1        if (return_await_number_table() == 3)
1019   1        {
1020   2          buf_display[0][2] = 0;
1021   2          display();
1022   2          set_await_number_table(0);
1023   2        }
1024   1      }
1025          
1026          void fun76(void) //F2_E3 十位闪烁
1027          {
1028   1        if (return_await_number_table() == 1)
1029   1        {
1030   2          Show_four_number(Two_Menu_F2_E3);
1031   2          set_await_number_table(2);
1032   2        }
1033   1        if (return_await_number_table() == 3)
1034   1        {
1035   2          buf_display[0][1] = 0;
1036   2          display();
1037   2          set_await_number_table(0);
1038   2        }
1039   1      }
1040          
1041          void fun77(void) //F2_E3 个位闪烁
1042          {
1043   1        if (return_await_number_table() == 1)
1044   1        {
1045   2          Show_four_number(Two_Menu_F2_E3);
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 18  

1046   2          set_await_number_table(2);
1047   2        }
1048   1        if (return_await_number_table() == 3)
1049   1        {
1050   2          buf_display[0][0] = 0;
1051   2          display();
1052   2          set_await_number_table(0);
1053   2        }
1054   1      }
1055          
1056          void fun78(void) //F2_E4 千位闪烁
1057          {
1058   1        if (return_await_number_table() == 1)
1059   1        {
1060   2          Show_four_number(Two_Menu_F2_E4);
1061   2          set_await_number_table(2);
1062   2        }
1063   1        if (return_await_number_table() == 3)
1064   1        {
1065   2          buf_display[0][3] = 0;
1066   2          display();
1067   2          set_await_number_table(0);
1068   2        }
1069   1      }
1070          
1071          void fun79(void) //F2_E4 百位闪烁
1072          {
1073   1        if (return_await_number_table() == 1)
1074   1        {
1075   2          Show_four_number(Two_Menu_F2_E4);
1076   2          set_await_number_table(2);
1077   2        }
1078   1        if (return_await_number_table() == 3)
1079   1        {
1080   2          buf_display[0][2] = 0;
1081   2          display();
1082   2          set_await_number_table(0);
1083   2        }
1084   1      }
1085          
1086          void fun80(void) //F2_E4 十位闪烁
1087          {
1088   1        if (return_await_number_table() == 1)
1089   1        {
1090   2          Show_four_number(Two_Menu_F2_E4);
1091   2          set_await_number_table(2);
1092   2        }
1093   1        if (return_await_number_table() == 3)
1094   1        {
1095   2          buf_display[0][1] = 0;
1096   2          display();
1097   2          set_await_number_table(0);
1098   2        }
1099   1      }
1100          
1101          void fun81(void) //F2_E4 个位闪烁
1102          {
1103   1        if (return_await_number_table() == 1)
1104   1        {
1105   2          Show_four_number(Two_Menu_F2_E4);
1106   2          set_await_number_table(2);
1107   2        }
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 19  

1108   1        if (return_await_number_table() == 3)
1109   1        {
1110   2          buf_display[0][0] = 0;
1111   2          display();
1112   2          set_await_number_table(0);
1113   2        }
1114   1      }
1115          
1116          void fun82(void) //显示即时显示 还是循环显示
1117          {
1118   1        unsigned char temp=0;
1119   1        temp = return_Two_Menu_F3_E1();
1120   1        Show_one_number(temp);
1121   1      }
1122          
1123          void fun83(void) //队列存储个数
1124          {
1125   1        unsigned char temp = 0;
1126   1        temp = return_Two_Menu_F3_E2();
1127   1        Show_two_number(temp);
1128   1      }
1129          
1130          void fun84(void) //F6_E1语音选择
1131          {
1132   1        unsigned char temp = 0;
1133   1        temp = return_Two_Menu_F6_E1();
1134   1        Show_one_number(temp);
1135   1      }
1136          
1137          void fun85(void) //F6_E2语音报读次数
1138          {
1139   1        unsigned char temp = 0;
1140   1        temp = return_Two_Menu_F6_E2();
1141   1        Show_one_number(temp);
1142   1      }
1143          
1144          void fun86(void) //F6_E3循环时候是否报读
1145          {
1146   1        unsigned char temp = 0;
1147   1        temp = return_Two_Menu_F6_E3();
1148   1        Show_one_number(temp);
1149   1      }
1150          
1151          void fun87(void) //F6_E4音量大小调整
1152          {
1153   1        unsigned char temp = 0;
1154   1        temp = return_Two_Menu_F6_E4();
1155   1        Show_one_number(temp);
1156   1      }
1157          
1158          void fun88(void) //F6_E5屏幕亮度调整
1159          {
1160   1        unsigned char temp = 0;
1161   1        temp = return_Two_Menu_F6_E5();
1162   1        Show_one_number(temp);
1163   1      }
1164          
1165          void fun89(void) //F7_E1 999*9
1166          {
1167   1        unsigned char temp = 0;
1168   1        temp = return_Two_Menu_F7_E1();
1169   1        Show_one_number(temp);
C51 COMPILER V9.00   TM1629                                                                09/12/2015 17:33:14 PAGE 20  

1170   1      }
1171          
1172          void fun90(void) //F7_E2 9999*9
1173          {
1174   1        unsigned char temp = 0;
1175   1        temp = return_Two_Menu_F7_E2();
1176   1        Show_one_number(temp);
1177   1      }
1178          
1179          void fun91(void) //F7_E3 999*99
1180          {
1181   1        unsigned char temp = 0;
1182   1        temp = return_Two_Menu_F7_E3();
1183   1        Show_one_number(temp);
1184   1      }
1185          
1186          void fun92(void) //F7_E4 9999*99
1187          {
1188   1        unsigned char temp = 0;
1189   1        temp = return_Two_Menu_F7_E4();
1190   1        Show_one_number(temp);
1191   1      }
1192          
1193          void fun93(void) //F8_E1单键位跟多键位切换
1194          {
1195   1        unsigned char temp = 0;
1196   1        temp = return_Two_Menu_F8_E1();
1197   1        Show_one_number(temp);
1198   1      }
1199          
1200          void fun94(void) //F8_E2键位设置
1201          {
1202   1        unsigned char temp = 0;
1203   1        temp = return_Two_Menu_F8_E2();
1204   1        Show_two_number(temp);
1205   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2914    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    320       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
