C51 COMPILER V9.00   DECODER                                                               09/18/2015 15:48:09 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DECODER
OBJECT MODULE PLACED IN decoder.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\decoder.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRINT
                    -(.\decoder.lst) TABS(2) OBJECT(decoder.obj)

line level    source

   1          #include "decoder.h"
   2          #include "ev1527.h"
   3          #include "usart.h"
   4          #include "at24c256.h"
   5          #include "key.h"
   6          #include "menu.h"
   7          #include "tm1629.h"
   8          
   9          unsigned char buf_eeprom[8] = { 0 };//Ğ´ÈëEEPROM_buf
  10          
  11          void DecoderProcess(void)
  12          { 
  13   1        unsigned char i, j ,l ,k;
  14   1        unsigned char temp_buff[8];//½âÂëÓÃÁÙÊ±Êı×é
  15   1        unsigned char temp_buff1[PAGE_LENGTH] = { 0 };//²éÑ¯AT24C256ÁÙÊ±Êı×é
  16   1      
  17   1        unsigned char func_index_temp = 0;    //´´½¨ÁÙÊ±±äÁ¿£¬ÓÃÓÚ·Å»ØÆäËûÍâ²¿±äÁ¿
  18   1        unsigned char Two_Menu_F8_E1_temp = 0;  //´´½¨ÁÙÊ±±äÁ¿£¬ÓÃÓÚ·Å»ØÆäËûÍâ²¿±äÁ¿
  19   1        unsigned char Two_Menu_F3_E1_temp = 0;  //´´½¨ÁÙÊ±±äÁ¿£¬ÓÃÓÚ·Å»ØÆäËûÍâ²¿±äÁ¿  
  20   1        unsigned char Two_Menu_F3_E2_temp = 0;  //´´½¨ÁÙÊ±±äÁ¿£¬ÓÃÓÚ·Å»ØÆäËûÍâ²¿±äÁ¿
  21   1        unsigned char Two_Menu_F7_E1_temp = 0;  //´´½¨ÁÙÊ±±äÁ¿£¬ÓÃÓÚ·Å»ØÆäËûÍâ²¿±äÁ¿
  22   1      
  23   1        func_index_temp = return_func_index();  //·µ»ØËùĞèÒªµÄÍâ²¿±äÁ¿
  24   1        Two_Menu_F8_E1_temp = return_Two_Menu_F8_E1();  //·µ»ØËùĞèÒªµÄÍâ²¿±äÁ¿
  25   1        Two_Menu_F3_E1_temp = return_Two_Menu_F3_E1();  //·µ»ØËùĞèÒªµÄÍâ²¿±äÁ¿
  26   1        Two_Menu_F3_E2_temp = return_Two_Menu_F3_E2();  //·µ»ØËùĞèÒªµÄÍâ²¿±äÁ¿
  27   1        Two_Menu_F7_E1_temp = return_Two_Menu_F7_E1();  //·µ»ØËùĞèÒªµÄÍâ²¿±äÁ¿
  28   1      
  29   1        receive_rf_decoder(); //½âÂëº¯Êı
  30   1      
  31   1        if (return_again_receive_rf_decoder_finished() == 1) //±êÖ¾Î»µÈÓÚ1 ËµÃ÷ÔÚ2´Î¼ìÑéÏÂÍ¨¹ı,½ÓÊÕµ½ÓĞĞ§Âë
  32   1        {
  33   2      #ifdef DEBUG
  34   2          uart_printf("decoder_val is %02x %02x %02x .\r\n", (unsigned int)old2_RF_RECE_REG[0], (unsigned int)old2
             -_RF_RECE_REG[1], (unsigned int)old2_RF_RECE_REG[2]); //²âÊÔ°´¼ü¼üÖµ
  35   2      #endif
  36   2          switch (func_index_temp)
  37   2          {
  38   3          case MENU_STANDBY://´ı»ú×´Ì¬ÏÂ
  39   3          {
  40   4            //¼üÅÌ¹æÔò
  41   4            if ((old2_RF_RECE_REG[2] & 0xf0) == 0x00 && (((old2_RF_RECE_REG[0] >> 4) == Two_Menu_F7_E1_temp) || (Tw
             -o_Menu_F7_E1_temp == 11)))//¼üÅÌ¹æÔò£¬³ÌĞò°´Ä¬ÈÏµÄÀ´±à
  42   4            {
  43   5              temp_buff[0] = old2_RF_RECE_REG[2] & 0x0f;  //Îª°´¼üÖµ
  44   5              temp_buff[1] = old2_RF_RECE_REG[0] >> 4;  //Îª·ÀÇøºÅ
  45   5              temp_buff[2] = old2_RF_RECE_REG[0] & 0x0f;  //Îª3Î»×éÂëµÚÒ»Î»
  46   5              temp_buff[3] = old2_RF_RECE_REG[1] >> 4;  //Îª3Î»×éÂëµÚ¶şÎ»
  47   5              temp_buff[4] = old2_RF_RECE_REG[1] & 0x0f;  //Îª3Î»×éÂëµÚÈıÎ»
  48   5              temp_buff[5] = old2_RF_RECE_REG[0];     //±¸ÓÃÏî,ÔİÇÒ´æµÚÒ»Î»IDÂë
  49   5      
  50   5              tm1629_clear();//ÇåÆÁ
  51   5              decoder_temp_to_mcuram(display_ram, temp_buff);//½«ÁÙÊ±Êı×éµÄÊı¾İÒÆÈëµ¥Æ¬»úÔİ´æÊı×é 8×Ö½Ú×ª6×Ö½Ú
  52   5              tm1629_load();//µ¥Æ¬»ú°ÑÊı×éÄÚÈİÔØÈëÊıÂë¹ÜÏÔ´æÊı×éÖĞ
C51 COMPILER V9.00   DECODER                                                               09/18/2015 15:48:09 PAGE 2   

  53   5              display();//ÏÔÊ¾ÊıÂë¹Ü
  54   5              set_func_index(DECODER_MENU);//´ËÊ±ÌøÈë½âÂë²Ëµ¥£¬ÎªÏÂÒ»´Î½âÂë×ö×¼±¸
  55   5              clear_again_receive_rf_decoder_finished();//Çå³ı½âÂëÍê³É±êÖ¾Î»
  56   5      
  57   5              break;
  58   5            }
  59   4            //ºô½ĞÆ÷×¢²á,ËÑË÷ËùĞèÒªµÄºô½ĞÆ÷
  60   4             for (j = 0; j<(CALL_TABLE_NUMBER + CANCEL_TABLE_NUMBER + ALARM_TABLE_NUMBER); j++)//ËÑË÷±êÖ¾Î»
  61   4            {
  62   5              IRcvStr(I2C_ADDRESS, j*PAGE_LENGTH, temp_buff1, PAGE_LENGTH);//¶Á³ö32¸ö×Ö½Ú±êÖ¾Î»
  63   5              delay10ms();
  64   5              for (i = 0; i<PAGE_LENGTH; i++) //¶Ô¶Á³öµÄ32×Ö½Ú±êÖ¾Î»½øĞĞ²é¿´£¬¿´ÊÇ·ñÎª0
  65   5              {
  66   6                if (temp_buff1[i] == 0)//±êÖ¾Î»Îª0´ú±í¸Ã±êÖ¾Î»Ëù¶ÔÓ¦µÄÊı¾İÇøÓĞÊı¾İ
  67   6                { 
  68   7      #ifdef DEBUG
  69   7                  uart_printf("find a table!");
  70   7      #endif
  71   7                  IRcvStr(I2C_ADDRESS, CALL_DATA_START + (j * 32 + i) * 8, temp_buff, 8);//¶Á³ö¶ÔÓ¦µÄ8¸ö×Ö½ÚµÄÊı¾İ
  72   7                  delay10ms();
  73   7                  if (((Two_Menu_F8_E1_temp != 1) && temp_buff[5] == old2_RF_RECE_REG[0] && temp_buff[6] == old2_RF_RE
             -CE_REG[1] && ((temp_buff[7] >> 4) == (old2_RF_RECE_REG[2] >> 4))) || ((Two_Menu_F8_E1_temp == 1) && temp_buff[5] == old2
             -_RF_RECE_REG[0] && temp_buff[6] == old2_RF_RECE_REG[1] && temp_buff[7] == old2_RF_RECE_REG[2]))// ½øĞĞ¶Ô±È£¬¿´¿´Êı¾İÊÇ·ñ
             -·ûºÏ
  74   7                  {
  75   8                      tm1629_clear();//ÇåÆÁ
  76   8                      decoder_temp_to_mcuram(display_ram, temp_buff);//Èç¹û·ûºÏµÄ»°  ½«ÁÙÊ±Êı×éµÄÊı¾İÒÆÈëµ¥Æ¬»úÔİ´æÊı×é 
             -8×Ö½Ú×ª6×Ö½Ú
  77   8                      tm1629_load();//µ¥Æ¬»ú°ÑÊı×éÄÚÈİÔØÈëÊıÂë¹ÜÏÔ´æÊı×éÖĞ
  78   8                      display();//ÏÔÊ¾ÊıÂë¹Ü
  79   8      #ifdef DEBUG
  80   8                      uart_printf("decoder success!"); 
  81   8      #endif
  82   8      
  83   8      #ifdef DEBUG
  84   8                      uart_printf("display_ram is %02x %02x %02x %02x.\r\n", (unsigned int)display_ram[0], (unsigned int
             -)display_ram[1], (unsigned int)display_ram[2], (unsigned int)display_ram[3]); //²âÊÔ°´¼ü¼üÖµ
  85   8      #endif
  86   8      
  87   8                      set_func_index(DECODER_MENU);;//´ËÊ±ÌøÈë½âÂë²Ëµ¥£¬ÎªÏÂÒ»´Î½âÂë×ö×¼±¸
  88   8                      clear_again_receive_rf_decoder_finished();//Çå³ı½âÂëÍê³É±êÖ¾Î»
  89   8                      break;
  90   8                      break;
  91   8                  }
  92   7                }
  93   6              }
  94   5            } 
  95   4             break;
  96   4          }
  97   3      
  98   3          case DECODER_MENU: //½âÂë²Ëµ¥ÏÂ
  99   3          {
 100   4             //¼üÅÌ¹æÔò
 101   4            if ((old2_RF_RECE_REG[2] & 0xf0) == 0x00 && (((old2_RF_RECE_REG[0] >> 4) == Two_Menu_F7_E1_temp) || (Tw
             -o_Menu_F7_E1_temp == 11)))//¼üÅÌ¹æÔò£¬³ÌĞò°´Ä¬ÈÏµÄÀ´±à
 102   4            {
 103   5              temp_buff[0] = old2_RF_RECE_REG[2] & 0x0f;  //Îª°´¼üÖµ
 104   5              temp_buff[1] = old2_RF_RECE_REG[0] >> 4;  //Îª·ÀÇøºÅ
 105   5              temp_buff[2] = old2_RF_RECE_REG[0] & 0x0f;  //Îª3Î»×éÂëµÚÒ»Î»
 106   5              temp_buff[3] = old2_RF_RECE_REG[1] >> 4;  //Îª3Î»×éÂëµÚ¶şÎ»
 107   5              temp_buff[4] = old2_RF_RECE_REG[1] & 0x0f;  //Îª3Î»×éÂëµÚÈıÎ»
 108   5              temp_buff[5] = old2_RF_RECE_REG[0];     //±¸ÓÃÏî,ÔİÇÒ´æµÚÒ»Î»IDÂë
C51 COMPILER V9.00   DECODER                                                               09/18/2015 15:48:09 PAGE 3   

 109   5              if (Two_Menu_F3_E1_temp == 1)       //Îª¼´Ê±Ä£Ê½
 110   5              {
 111   6                for (l = Two_Menu_F3_E2_temp; l>1; l--) //ÕûÌåÍùÏÂÒÆÒ»×éÊı¾İ
 112   6                {
 113   7                  mcuram_to_mcuram_down(display_ram + (l - 2) * 6);
 114   7                }
 115   6                for (l = 0; l<6; l++) //½²µÚÒ»×éÊı¾İÇå0
 116   6                {
 117   7                  display_ram[l] = 0;
 118   7                }
 119   6                decoder_temp_to_mcuram(display_ram, temp_buff); //Èç¹û·ûºÏµÄ»°  ½«ÁÙÊ±Êı×éµÄÊı¾İÒÆÈëµ¥Æ¬»úÔİ´æÊı×é 8×
             -Ö½Ú×ª6×Ö½Ú
 120   6                tm1629_load();//µ¥Æ¬»ú°ÑÊı×éÄÚÈİÔØÈëÊıÂë¹ÜÏÔ´æÊı×éÖĞ
 121   6                display();//ÏÔÊ¾ÊıÂë¹Ü
 122   6              }
 123   5              else if (Two_Menu_F3_E1_temp == 2)//ÎªÑ­»·Ä£Ê½
 124   5              {
 125   6                for (k = 0; k < Two_Menu_F3_E2_temp; k++)
 126   6                {
 127   7                  if (display_ram[k * 6] == 0)//ÕÒ³öÎ»ÓÚ¶ÓÁĞ×îºóµÄÄÇ¸öµã
 128   7                  {
 129   8                    decoder_temp_to_mcuram(display_ram + k * 6, temp_buff);//Èç¹û·ûºÏµÄ»°  ½«ÁÙÊ±Êı×éµÄÊı¾İÒÆÈëµ¥Æ¬»úÔİ
             -´æÊı×é 8×Ö½Ú×ª6×Ö½Ú
 130   8                    tm1629_load();//µ¥Æ¬»ú°ÑÊı×éÄÚÈİÔØÈëÊıÂë¹ÜÏÔ´æÊı×éÖĞ
 131   8                    display();//ÏÔÊ¾ÊıÂë¹Ü
 132   8                    break;
 133   8                  }
 134   7                }
 135   6      
 136   6              }
 137   5              clear_again_receive_rf_decoder_finished();//Çå³ı½âÂëÍê³É±êÖ¾Î»
 138   5              break;
 139   5            }
 140   4            //ºô½ĞÆ÷×¢²á,ËÑË÷ËùĞèÒªµÄºô½ĞÆ÷
 141   4            for (j = 0; j<CALL_TABLE_NUMBER + ALARM_TABLE_NUMBER + CANCEL_TABLE_NUMBER; j++)//ËÑË÷±êÖ¾Î»
 142   4            {
 143   5              IRcvStr(I2C_ADDRESS, j*PAGE_LENGTH, temp_buff1, PAGE_LENGTH);//¶Á³ö32¸ö×Ö½Ú±êÖ¾Î»
 144   5              delay10ms();
 145   5              for (i = 0; i<PAGE_LENGTH; i++)
 146   5              {
 147   6                if (temp_buff1[i] == 0)//¶Ô¶Á³öµÄ32×Ö½Ú±êÖ¾Î»½øĞĞ²é¿´£¬¿´ÊÇ·ñÎª0
 148   6                {
 149   7                  IRcvStr(I2C_ADDRESS, CALL_DATA_START + (j * 32 + i) * 8, temp_buff, 8);//¶Á³ö¶ÔÓ¦µÄ8¸ö×Ö½ÚµÄÊı¾İ
 150   7                  delay10ms();
 151   7                  if (((Two_Menu_F8_E1_temp != 1) && temp_buff[5] == old2_RF_RECE_REG[0] && temp_buff[6] == old2_RF_RE
             -CE_REG[1] && ((temp_buff[7] >> 4) == (old2_RF_RECE_REG[2] >> 4))) || ((Two_Menu_F8_E1_temp == 1) && temp_buff[5] == old2
             -_RF_RECE_REG[0] && temp_buff[6] == old2_RF_RECE_REG[1] && temp_buff[7] == old2_RF_RECE_REG[2]))
 152   7                  {
 153   8      
 154   8                    if (Two_Menu_F3_E1_temp == 1)//Îª¼´Ê±Ä£Ê½
 155   8                    {
 156   9                      for (l = Two_Menu_F3_E2_temp; l>1; l--) //ÕûÌåÍùÏÂÒÆÒ»×éÊı¾İ
 157   9                      {
 158  10                        mcuram_to_mcuram_down(display_ram + (l - 2) * 6);
 159  10                      }
 160   9                      for (l = 0; l<6; l++)//½²µÚÒ»×éÊı¾İÇå0
 161   9                      {
 162  10                        display_ram[l] = 0;
 163  10                      }
 164   9                      decoder_temp_to_mcuram(display_ram, temp_buff);//Èç¹û·ûºÏµÄ»°  ½«ÁÙÊ±Êı×éµÄÊı¾İÒÆÈëµ¥Æ¬»úÔİ´æÊı×é 
             -8×Ö½Ú×ª6×Ö½Ú
 165   9                      tm1629_load();//µ¥Æ¬»ú°ÑÊı×éÄÚÈİÔØÈëÊıÂë¹ÜÏÔ´æÊı×éÖĞ
C51 COMPILER V9.00   DECODER                                                               09/18/2015 15:48:09 PAGE 4   

 166   9                      display();//ÏÔÊ¾ÊıÂë¹Ü
 167   9                    }
 168   8                  else if (Two_Menu_F3_E1_temp == 2)//ÎªÑ­»·Ä£Ê½
 169   8                  {
 170   9                    for (k = 0; k < Two_Menu_F3_E2_temp; k++)
 171   9                    {
 172  10                      if (display_ram[k * 6 ] == 0)//ÕÒ³öÎ»ÓÚ¶ÓÁĞ×îºóµÄÄÇ¸öµã
 173  10                      {
 174  11                        decoder_temp_to_mcuram(display_ram + k * 6, temp_buff);//  ½«ÁÙÊ±Êı×éµÄÊı¾İÒÆÈëµ¥Æ¬»úÔİ´æÊı×é 8×Ö
             -½Ú×ª6×Ö½Ú
 175  11                        tm1629_load();//µ¥Æ¬»ú°ÑÊı×éÄÚÈİÔØÈëÊıÂë¹ÜÏÔ´æÊı×éÖĞ
 176  11                        display();//ÏÔÊ¾ÊıÂë¹Ü
 177  11                        break;
 178  11                      }
 179  10                    }
 180   9                  }
 181   8      #ifdef DEBUG
 182   8                    uart_printf("decoder success!");
 183   8      #endif
 184   8      
 185   8      #ifdef DEBUG
 186   8                    uart_printf("display_ram is %02x %02x %02x %02x.\r\n", (unsigned int)display_ram[0], (unsigned int)
             -display_ram[1], (unsigned int)display_ram[2], (unsigned int)display_ram[3]); //²âÊÔ°´¼ü¼üÖµ
 187   8      #endif
 188   8                    clear_again_receive_rf_decoder_finished();
 189   8                    break;
 190   8                    break;
 191   8                  }
 192   7                }
 193   6              }
 194   5            }
 195   4            break;
 196   4          }
 197   3      
 198   3          case TWO_MENU_F1_E1_D1:
 199   3          case TWO_MENU_F1_E1_D2:
 200   3          case TWO_MENU_F1_E1_D3:
 201   3          case TWO_MENU_F1_E1_D4:
 202   3          {
 203   4            set_func_index(TWO_MENU_F1_E1_D4);
 204   4            buf_eeprom[0] = old2_RF_RECE_REG[2] & 0x0f;//°´¼üÖµ±£´æµ½0×Ö½Ú
 205   4            buf_eeprom[1] = Two_Menu_F1_E1[0];/*ÊıÖµ´æÈë1 2 3 4×Ö½Ú*/
 206   4            buf_eeprom[2] = Two_Menu_F1_E1[1];
 207   4            buf_eeprom[3] = Two_Menu_F1_E1[2];
 208   4            buf_eeprom[4] = Two_Menu_F1_E1[3];
 209   4            buf_eeprom[5] = old2_RF_RECE_REG[0];// IDÂë´æÈë 5 6 7 ×Ö½Ú
 210   4            buf_eeprom[6] = old2_RF_RECE_REG[1];
 211   4            if (Two_Menu_F8_E1_temp == 1)
 212   4            {
 213   5              buf_eeprom[7] = old2_RF_RECE_REG[2];
 214   5            }
 215   4            else
 216   4            {
 217   5              buf_eeprom[7] = old2_RF_RECE_REG[2] & 0xf0;
 218   5            }
 219   4      
 220   4            if (register_call_function(buf_eeprom))//ÊıÖµ×Ô¶¯¼Ó1
 221   4            {
 222   5      #ifdef DEBUG
 223   5              uart_printf("call is %02x %02x %02x .\r\n", (unsigned int)buf_eeprom[5], (unsigned int)buf_eeprom[6], 
             -(unsigned int)buf_eeprom[7]); //²âÊÔ°´¼ü¼üÖµ
 224   5              uart_printf("call is %02x %02x %02x %02x.\r\n", (unsigned int)Two_Menu_F1_E1[0], (unsigned int)Two_Men
C51 COMPILER V9.00   DECODER                                                               09/18/2015 15:48:09 PAGE 5   

             -u_F1_E1[1], (unsigned int)Two_Menu_F1_E1[2], (unsigned int)Two_Menu_F1_E1[3]);
 225   5              uart_printf("caller is rigister success \r\n");
 226   5      #endif          
 227   5              delay10ms();
 228   5              if (Two_Menu_F1_E1[3] == 9)
 229   5              {
 230   6                if (Two_Menu_F1_E1[2] == 9)
 231   6                {
 232   7                  if (Two_Menu_F1_E1[1] == 9)
 233   7                  {
 234   8                    Two_Menu_F1_E1[0]++;
 235   8                    Two_Menu_F1_E1[1] = 0;
 236   8                    Two_Menu_F1_E1[2] = 0;
 237   8                    if (Two_Menu_F1_E1[0] == 21)
 238   8                    {
 239   9                      Two_Menu_F1_E1[0] = 0;
 240   9                      Two_Menu_F1_E1[3] = 1;
 241   9                    }
 242   8                    else
 243   8                    {
 244   9                      Two_Menu_F1_E1[3] = 1;
 245   9                    }
 246   8                  }
 247   7                  else
 248   7                  {
 249   8                    Two_Menu_F1_E1[1]++;
 250   8                    Two_Menu_F1_E1[2] = 0;
 251   8                    Two_Menu_F1_E1[3] = 0;
 252   8                  }
 253   7                }
 254   6                else
 255   6                {
 256   7                  Two_Menu_F1_E1[2]++;
 257   7                  Two_Menu_F1_E1[3] = 0;
 258   7                }
 259   6              }
 260   5              else
 261   5                Two_Menu_F1_E1[3]++;
 262   5            }
 263   4            break;
 264   4          }
 265   3      
 266   3          case TWO_MENU_F1_E2_D1:
 267   3          case TWO_MENU_F1_E2_D2:
 268   3          case TWO_MENU_F1_E2_D3:
 269   3          case TWO_MENU_F1_E2_D4:
 270   3          {
 271   4                        set_func_index(TWO_MENU_F1_E2_D4);
 272   4                        buf_eeprom[0] = old2_RF_RECE_REG[2] & 0x0f;//°´¼üÖµ±£´æµ½0×Ö½Ú
 273   4                        buf_eeprom[1] = Two_Menu_F1_E2[0];/*ÊıÖµ´æÈë1 2 3 4×Ö½Ú*/
 274   4                        buf_eeprom[2] = Two_Menu_F1_E2[1];
 275   4                        buf_eeprom[3] = Two_Menu_F1_E2[2];
 276   4                        buf_eeprom[4] = Two_Menu_F1_E2[3];
 277   4                        buf_eeprom[5] = old2_RF_RECE_REG[0];// IDÂë´æÈë 5 6 7 ×Ö½Ú
 278   4                        buf_eeprom[6] = old2_RF_RECE_REG[1];
 279   4                        buf_eeprom[7] = old2_RF_RECE_REG[2] & 0xf0;
 280   4      
 281   4                        if (register_host_function(buf_eeprom))//ÊıÖµ×Ô¶¯¼Ó1
 282   4                        {
 283   5      #ifdef DEBUG
 284   5                          uart_printf("host is %02x %02x %02x .\r\n", (unsigned int)buf_eeprom[5], (unsigned int)buf_eepr
             -om[6], (unsigned int)buf_eeprom[7]); //²âÊÔ°´¼ü¼üÖµ
C51 COMPILER V9.00   DECODER                                                               09/18/2015 15:48:09 PAGE 6   

 285   5                          uart_printf("host is %02x %02x %02x %02x.\r\n", (unsigned int)Two_Menu_F1_E2[0], (unsigned int)
             -Two_Menu_F1_E2[1], (unsigned int)Two_Menu_F1_E2[2], (unsigned int)Two_Menu_F1_E2[3]);
 286   5                          uart_printf("host is rigister success \r\n");
 287   5      #endif          
 288   5                          delay10ms();
 289   5                          if (Two_Menu_F1_E2[3] == 9)
 290   5                          {
 291   6                            if (Two_Menu_F1_E2[2] == 9)
 292   6                            {
 293   7                              if (Two_Menu_F1_E2[1] == 9)
 294   7                              {
 295   8                                Two_Menu_F1_E2[0]++;
 296   8                                Two_Menu_F1_E2[1] = 0;
 297   8                                Two_Menu_F1_E2[2] = 0;
 298   8                                if (Two_Menu_F1_E2[0] == 21)
 299   8                                {
 300   9                                  Two_Menu_F1_E2[0] = 0;
 301   9                                  Two_Menu_F1_E2[3] = 1;
 302   9                                }
 303   8                                else
 304   8                                {
 305   9                                  Two_Menu_F1_E2[3] = 1;
 306   9                                }
 307   8      
 308   8      
 309   8                              }
 310   7                              else
 311   7                              {
 312   8                                Two_Menu_F1_E2[1]++;
 313   8                                Two_Menu_F1_E2[2] = 0;
 314   8                                Two_Menu_F1_E2[3] = 0;
 315   8                              }
 316   7                            }
 317   6                            else
 318   6                            {
 319   7                              Two_Menu_F1_E2[2]++;
 320   7                              Two_Menu_F1_E2[3] = 0;
 321   7                            }
 322   6                          }
 323   5                          else
 324   5                            Two_Menu_F1_E2[3]++;
 325   5                        }
 326   4                        break;
 327   4          }
 328   3      
 329   3          case TWO_MENU_F1_E3_D1:
 330   3          case TWO_MENU_F1_E3_D2:
 331   3          case TWO_MENU_F1_E3_D3:
 332   3          case TWO_MENU_F1_E3_D4:
 333   3          {
 334   4            set_func_index(TWO_MENU_F1_E3_D4);
 335   4            buf_eeprom[0] = old2_RF_RECE_REG[2] & 0x0f;//°´¼üÖµ±£´æµ½0×Ö½Ú
 336   4            buf_eeprom[1] = Two_Menu_F1_E3[0];/*ÊıÖµ´æÈë1 2 3 4×Ö½Ú*/
 337   4            buf_eeprom[2] = Two_Menu_F1_E3[1];
 338   4            buf_eeprom[3] = Two_Menu_F1_E3[2];
 339   4            buf_eeprom[4] = Two_Menu_F1_E3[3];
 340   4            buf_eeprom[5] = old2_RF_RECE_REG[0];// IDÂë´æÈë 5 6 7 ×Ö½Ú
 341   4            buf_eeprom[6] = old2_RF_RECE_REG[1];
 342   4            buf_eeprom[7] = old2_RF_RECE_REG[2] & 0xf0;
 343   4      
 344   4            if (register_alarm_function(buf_eeprom))//ÊıÖµ×Ô¶¯¼Ó1
 345   4            {
C51 COMPILER V9.00   DECODER                                                               09/18/2015 15:48:09 PAGE 7   

 346   5      #ifdef DEBUG
 347   5              uart_printf("alarm is %02x %02x %02x .\r\n", (unsigned int)buf_eeprom[5], (unsigned int)buf_eeprom[6],
             - (unsigned int)buf_eeprom[7]); //²âÊÔ°´¼ü¼üÖµ
 348   5              uart_printf("alarm is %02x %02x %02x %02x.\r\n", (unsigned int)Two_Menu_F1_E3[0], (unsigned int)Two_Me
             -nu_F1_E3[1], (unsigned int)Two_Menu_F1_E3[2], (unsigned int)Two_Menu_F1_E3[3]);
 349   5              uart_printf("alarm is rigister success \r\n");
 350   5      #endif          
 351   5              delay10ms();
 352   5              if (Two_Menu_F1_E3[3] == 9)
 353   5              {
 354   6                if (Two_Menu_F1_E3[2] == 9)
 355   6                {
 356   7                  if (Two_Menu_F1_E3[1] == 9)
 357   7                  {
 358   8                    Two_Menu_F1_E3[0]++;
 359   8                    Two_Menu_F1_E3[1] = 0;
 360   8                    Two_Menu_F1_E3[2] = 0;
 361   8                    if (Two_Menu_F1_E3[0] == 21)
 362   8                    {
 363   9                      Two_Menu_F1_E3[0] = 0;
 364   9                      Two_Menu_F1_E3[3] = 1;
 365   9                    }
 366   8                    else
 367   8                    {
 368   9                      Two_Menu_F1_E3[3] = 1;
 369   9                    }
 370   8                  }
 371   7                  else
 372   7                  {
 373   8                    Two_Menu_F1_E3[1]++;
 374   8                    Two_Menu_F1_E3[2] = 0;
 375   8                    Two_Menu_F1_E3[3] = 0;
 376   8                  }
 377   7                }
 378   6                else
 379   6                {
 380   7                  Two_Menu_F1_E3[2]++;
 381   7                  Two_Menu_F1_E3[3] = 0;
 382   7                }
 383   6              }
 384   5              else
 385   5                Two_Menu_F1_E2[3]++;
 386   5            }
 387   4            break;
 388   4          }
 389   3          case TWO_MENU_F1_E4_D1:
 390   3          case TWO_MENU_F1_E4_D2:
 391   3          case TWO_MENU_F1_E4_D3:
 392   3          case TWO_MENU_F1_E4_D4:
 393   3          {
 394   4            set_func_index(TWO_MENU_F1_E4_D4);
 395   4            buf_eeprom[0] = old2_RF_RECE_REG[2] & 0x0f;//°´¼üÖµ±£´æµ½0×Ö½Ú
 396   4            buf_eeprom[1] = Two_Menu_F1_E4[0];/*ÊıÖµ´æÈë1 2 3 4×Ö½Ú*/
 397   4            buf_eeprom[2] = Two_Menu_F1_E4[1];
 398   4            buf_eeprom[3] = Two_Menu_F1_E4[2];
 399   4            buf_eeprom[4] = Two_Menu_F1_E4[3];
 400   4            buf_eeprom[5] = old2_RF_RECE_REG[0];// IDÂë´æÈë 5 6 7 ×Ö½Ú
 401   4            buf_eeprom[6] = old2_RF_RECE_REG[1];
 402   4            buf_eeprom[7] = old2_RF_RECE_REG[2] & 0xf0;
 403   4      
 404   4            if (register_cancel_function(buf_eeprom))//ÊıÖµ×Ô¶¯¼Ó1
 405   4            {
C51 COMPILER V9.00   DECODER                                                               09/18/2015 15:48:09 PAGE 8   

 406   5      #ifdef DEBUG
 407   5              uart_printf("cancel is %02x %02x %02x .\r\n", (unsigned int)buf_eeprom[5], (unsigned int)buf_eeprom[6]
             -, (unsigned int)buf_eeprom[7]); //²âÊÔ°´¼ü¼üÖµ
 408   5              uart_printf("cancel is %02x %02x %02x %02x.\r\n", (unsigned int)Two_Menu_F1_E4[0], (unsigned int)Two_M
             -enu_F1_E4[1], (unsigned int)Two_Menu_F1_E4[2], (unsigned int)Two_Menu_F1_E4[3]);
 409   5              uart_printf("cancel is rigister success \r\n");
 410   5      #endif          
 411   5              delay10ms();
 412   5              if (Two_Menu_F1_E4[3] == 9)
 413   5              {
 414   6                if (Two_Menu_F1_E4[2] == 9)
 415   6                {
 416   7                  if (Two_Menu_F1_E4[1] == 9)
 417   7                  {
 418   8                    Two_Menu_F1_E4[0]++;
 419   8                    Two_Menu_F1_E4[1] = 0;
 420   8                    Two_Menu_F1_E4[2] = 0;
 421   8                    if (Two_Menu_F1_E4[0] == 21)
 422   8                    {
 423   9                      Two_Menu_F1_E4[0] = 0;
 424   9                      Two_Menu_F1_E4[3] = 1;
 425   9                    }
 426   8                    else
 427   8                    {
 428   9                      Two_Menu_F1_E4[3] = 1;
 429   9                    }
 430   8                  }
 431   7                  else
 432   7                  {
 433   8                    Two_Menu_F1_E4[1]++;
 434   8                    Two_Menu_F1_E4[2] = 0;
 435   8                    Two_Menu_F1_E4[3] = 0;
 436   8                  }
 437   7                }
 438   6                else
 439   6                {
 440   7                  Two_Menu_F1_E4[2]++;
 441   7                  Two_Menu_F1_E4[3] = 0;
 442   7                }
 443   6              }
 444   5              else
 445   5                Two_Menu_F1_E4[3]++;
 446   5            }
 447   4            break;
 448   4          }
 449   3      
 450   3      
 451   3          default:break;//Ä¬ÈÏµÄbreak
 452   3          }
 453   2        }
 454   1        clear_again_receive_rf_decoder_finished();//Çå³ı±êÖ¾Î»
 455   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2687    ----
   CONSTANT SIZE    =    490    ----
   XDATA SIZE       =      8      49
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.00   DECODER                                                               09/18/2015 15:48:09 PAGE 9   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
