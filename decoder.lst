C51 COMPILER V9.00   DECODER                                                               09/12/2015 12:08:50 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DECODER
OBJECT MODULE PLACED IN decoder.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\decoder.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRINT
                    -(.\decoder.lst) TABS(2) OBJECT(decoder.obj)

line level    source

   1          #include "decoder.h"
   2          #include "ev1527.h"
   3          #include "usart.h"
   4          #include "at24c256.h"
   5          #include "key.h"
   6          #include "menu.h"
   7          
   8          unsigned char buf_eeprom[8] = { 0 };//写入EEPROM_buf
   9          
  10          void DecoderProcess(void)
  11          {
  12   1        unsigned char func_index_temp = 0;
  13   1        unsigned char Two_Menu_F8_E1_temp = 0;
  14   1        func_index_temp = return_func_index();
  15   1        Two_Menu_F8_E1_temp = return_Two_Menu_F8_E1();
  16   1        receive_rf_decoder();
  17   1        if (return_again_receive_rf_decoder_finished() == 1)
  18   1        {
  19   2      #ifdef DEBUG
  20   2          uart_printf("decoder_val is %02x %02x %02x .\r\n", (unsigned int)old2_RF_RECE_REG[0], (unsigned int)old2
             -_RF_RECE_REG[1], (unsigned int)old2_RF_RECE_REG[2]); //测试按键键值
  21   2      #endif
  22   2          switch (func_index_temp)
  23   2          {
  24   3          case TWO_MENU_F1_E1_D1:
  25   3          case TWO_MENU_F1_E1_D2:
  26   3          case TWO_MENU_F1_E1_D3:
  27   3          case TWO_MENU_F1_E1_D4:
  28   3          {
  29   4            set_func_index(TWO_MENU_F1_E1_D4);
  30   4            buf_eeprom[0] = old2_RF_RECE_REG[2] & 0x0f;//按键值保存到0字节
  31   4            buf_eeprom[1] = Two_Menu_F1_E1[0];/*数值存入1 2 3 4字节*/
  32   4            buf_eeprom[2] = Two_Menu_F1_E1[1];
  33   4            buf_eeprom[3] = Two_Menu_F1_E1[2];
  34   4            buf_eeprom[4] = Two_Menu_F1_E1[3];
  35   4            buf_eeprom[5] = old2_RF_RECE_REG[0];// ID码存入 5 6 7 字节
  36   4            buf_eeprom[6] = old2_RF_RECE_REG[1];
  37   4            if (Two_Menu_F8_E1_temp == 1)
  38   4            {
  39   5              buf_eeprom[7] = old2_RF_RECE_REG[2];
  40   5            }
  41   4            else
  42   4            {
  43   5              buf_eeprom[7] = old2_RF_RECE_REG[2]&0xf0;
  44   5            }
  45   4            
  46   4      
  47   4            if (register_call_function(buf_eeprom))//数值自动加1
  48   4            {
  49   5      #ifdef DEBUG
  50   5            uart_printf("call is %02x %02x %02x .\r\n", (unsigned int)buf_eeprom[5], (unsigned int)buf_eeprom[6], (
             -unsigned int)buf_eeprom[7]); //测试按键键值
  51   5            uart_printf("call is %02x %02x %02x %02x.\r\n", (unsigned int)Two_Menu_F1_E1[0], (unsigned int)Two_Menu
             -_F1_E1[1], (unsigned int)Two_Menu_F1_E1[2], (unsigned int)Two_Menu_F1_E1[3]);
C51 COMPILER V9.00   DECODER                                                               09/12/2015 12:08:50 PAGE 2   

  52   5            uart_printf("caller is rigister success \r\n"); 
  53   5      #endif        
  54   5              
  55   5              delay10ms();
  56   5              if (Two_Menu_F1_E1[3] == 9)
  57   5              {
  58   6                if (Two_Menu_F1_E1[2] == 9)
  59   6                {
  60   7                  Two_Menu_F1_E1[1]++;
  61   7                  Two_Menu_F1_E1[2] = 0;
  62   7                  Two_Menu_F1_E1[3] = 0;
  63   7                }
  64   6                else
  65   6                {
  66   7                  Two_Menu_F1_E1[2]++;
  67   7                  Two_Menu_F1_E1[3] = 0;
  68   7                }
  69   6              }
  70   5              else
  71   5                Two_Menu_F1_E1[3]++;
  72   5            }
  73   4            break;
  74   4            }
  75   3          default:break;
  76   3          }
  77   2        }
  78   1        clear_again_receive_rf_decoder_finished();//清除标志位
  79   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    363    ----
   CONSTANT SIZE    =    122    ----
   XDATA SIZE       =      8       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
