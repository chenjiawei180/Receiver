C51 COMPILER V9.00   DECODER                                                               09/12/2015 15:35:40 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DECODER
OBJECT MODULE PLACED IN decoder.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\decoder.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRINT
                    -(.\decoder.lst) TABS(2) OBJECT(decoder.obj)

line level    source

   1          #include "decoder.h"
   2          #include "ev1527.h"
   3          #include "usart.h"
   4          #include "at24c256.h"
   5          #include "key.h"
   6          #include "menu.h"
   7          
   8          unsigned char buf_eeprom[8] = { 0 };//写入EEPROM_buf
   9          
  10          void DecoderProcess(void)
  11          {
  12   1        unsigned char func_index_temp = 0;
  13   1        unsigned char Two_Menu_F8_E1_temp = 0;
  14   1        func_index_temp = return_func_index();
  15   1        Two_Menu_F8_E1_temp = return_Two_Menu_F8_E1();
  16   1        receive_rf_decoder();
  17   1        if (return_again_receive_rf_decoder_finished() == 1)
  18   1        {
  19   2      #ifdef DEBUG
  20   2          uart_printf("decoder_val is %02x %02x %02x .\r\n", (unsigned int)old2_RF_RECE_REG[0], (unsigned int)old2
             -_RF_RECE_REG[1], (unsigned int)old2_RF_RECE_REG[2]); //测试按键键值
  21   2      #endif
  22   2          switch (func_index_temp)
  23   2          {
  24   3          case TWO_MENU_F1_E1_D1:
  25   3          case TWO_MENU_F1_E1_D2:
  26   3          case TWO_MENU_F1_E1_D3:
  27   3          case TWO_MENU_F1_E1_D4:
  28   3          {
  29   4                        set_func_index(TWO_MENU_F1_E1_D4);
  30   4                        buf_eeprom[0] = old2_RF_RECE_REG[2] & 0x0f;//按键值保存到0字节
  31   4                        buf_eeprom[1] = Two_Menu_F1_E1[0];/*数值存入1 2 3 4字节*/
  32   4                        buf_eeprom[2] = Two_Menu_F1_E1[1];
  33   4                        buf_eeprom[3] = Two_Menu_F1_E1[2];
  34   4                        buf_eeprom[4] = Two_Menu_F1_E1[3];
  35   4                        buf_eeprom[5] = old2_RF_RECE_REG[0];// ID码存入 5 6 7 字节
  36   4                        buf_eeprom[6] = old2_RF_RECE_REG[1];
  37   4                        if (Two_Menu_F8_E1_temp == 1)
  38   4                        {
  39   5                          buf_eeprom[7] = old2_RF_RECE_REG[2];
  40   5                        }
  41   4                        else
  42   4                        {
  43   5                          buf_eeprom[7] = old2_RF_RECE_REG[2] & 0xf0;
  44   5                        }
  45   4      
  46   4      
  47   4                        if (register_call_function(buf_eeprom))//数值自动加1
  48   4                        {
  49   5      #ifdef DEBUG
  50   5                          uart_printf("call is %02x %02x %02x .\r\n", (unsigned int)buf_eeprom[5], (unsigned int)buf_eepr
             -om[6], (unsigned int)buf_eeprom[7]); //测试按键键值
  51   5                          uart_printf("call is %02x %02x %02x %02x.\r\n", (unsigned int)Two_Menu_F1_E1[0], (unsigned int)
             -Two_Menu_F1_E1[1], (unsigned int)Two_Menu_F1_E1[2], (unsigned int)Two_Menu_F1_E1[3]);
C51 COMPILER V9.00   DECODER                                                               09/12/2015 15:35:40 PAGE 2   

  52   5                          uart_printf("caller is rigister success \r\n");
  53   5      #endif          
  54   5                          delay10ms();
  55   5                          if (Two_Menu_F1_E1[3] == 9)
  56   5                          {
  57   6                            if (Two_Menu_F1_E1[2] == 9)
  58   6                            {
  59   7                              if (Two_Menu_F1_E1[1] == 9)
  60   7                              {
  61   8                                Two_Menu_F1_E1[0]++;
  62   8                                Two_Menu_F1_E1[1] = 0;
  63   8                                Two_Menu_F1_E1[2] = 0;
  64   8                                if (Two_Menu_F1_E1[0] == 21)
  65   8                                {
  66   9                                  Two_Menu_F1_E1[0] = 0;
  67   9                                  Two_Menu_F1_E1[3] = 1;
  68   9                                }
  69   8                                else
  70   8                                {
  71   9                                  Two_Menu_F1_E1[3] = 1;
  72   9                                }
  73   8      
  74   8      
  75   8                              }
  76   7                              else
  77   7                              {
  78   8                                Two_Menu_F1_E1[1]++;
  79   8                                Two_Menu_F1_E1[2] = 0;
  80   8                                Two_Menu_F1_E1[3] = 0;
  81   8                              }
  82   7                            }
  83   6                            else
  84   6                            {
  85   7                              Two_Menu_F1_E1[2]++;
  86   7                              Two_Menu_F1_E1[3] = 0;
  87   7                            }
  88   6                          }
  89   5                          else
  90   5                            Two_Menu_F1_E1[3]++;
  91   5                        }
  92   4                        break;
  93   4          }
  94   3      
  95   3          case TWO_MENU_F1_E2_D1:
  96   3          case TWO_MENU_F1_E2_D2:
  97   3          case TWO_MENU_F1_E2_D3:
  98   3          case TWO_MENU_F1_E2_D4:
  99   3          {
 100   4                        set_func_index(TWO_MENU_F1_E2_D4);
 101   4                        buf_eeprom[0] = old2_RF_RECE_REG[2] & 0x0f;//按键值保存到0字节
 102   4                        buf_eeprom[1] = Two_Menu_F1_E2[0];/*数值存入1 2 3 4字节*/
 103   4                        buf_eeprom[2] = Two_Menu_F1_E2[1];
 104   4                        buf_eeprom[3] = Two_Menu_F1_E2[2];
 105   4                        buf_eeprom[4] = Two_Menu_F1_E2[3];
 106   4                        buf_eeprom[5] = old2_RF_RECE_REG[0];// ID码存入 5 6 7 字节
 107   4                        buf_eeprom[6] = old2_RF_RECE_REG[1];
 108   4                        buf_eeprom[7] = old2_RF_RECE_REG[2] & 0xf0;
 109   4      
 110   4                        if (register_host_function(buf_eeprom))//数值自动加1
 111   4                        {
 112   5      #ifdef DEBUG
 113   5                          uart_printf("host is %02x %02x %02x .\r\n", (unsigned int)buf_eeprom[5], (unsigned int)buf_eepr
C51 COMPILER V9.00   DECODER                                                               09/12/2015 15:35:40 PAGE 3   

             -om[6], (unsigned int)buf_eeprom[7]); //测试按键键值
 114   5                          uart_printf("host is %02x %02x %02x %02x.\r\n", (unsigned int)Two_Menu_F1_E2[0], (unsigned int)
             -Two_Menu_F1_E2[1], (unsigned int)Two_Menu_F1_E2[2], (unsigned int)Two_Menu_F1_E2[3]);
 115   5                          uart_printf("host is rigister success \r\n");
 116   5      #endif          
 117   5                          delay10ms();
 118   5                          if (Two_Menu_F1_E2[3] == 9)
 119   5                          {
 120   6                            if (Two_Menu_F1_E2[2] == 9)
 121   6                            {
 122   7                              if (Two_Menu_F1_E2[1] == 9)
 123   7                              {
 124   8                                Two_Menu_F1_E2[0]++;
 125   8                                Two_Menu_F1_E2[1] = 0;
 126   8                                Two_Menu_F1_E2[2] = 0;
 127   8                                if (Two_Menu_F1_E2[0] == 21)
 128   8                                {
 129   9                                  Two_Menu_F1_E2[0] = 0;
 130   9                                  Two_Menu_F1_E2[3] = 1;
 131   9                                }
 132   8                                else
 133   8                                {
 134   9                                  Two_Menu_F1_E2[3] = 1;
 135   9                                }
 136   8      
 137   8      
 138   8                              }
 139   7                              else
 140   7                              {
 141   8                                Two_Menu_F1_E2[1]++;
 142   8                                Two_Menu_F1_E2[2] = 0;
 143   8                                Two_Menu_F1_E2[3] = 0;
 144   8                              }
 145   7                            }
 146   6                            else
 147   6                            {
 148   7                              Two_Menu_F1_E2[2]++;
 149   7                              Two_Menu_F1_E2[3] = 0;
 150   7                            }
 151   6                          }
 152   5                          else
 153   5                            Two_Menu_F1_E2[3]++;
 154   5                        }
 155   4                        break;
 156   4          }
 157   3      
 158   3          case TWO_MENU_F1_E3_D1:
 159   3          case TWO_MENU_F1_E3_D2:
 160   3          case TWO_MENU_F1_E3_D3:
 161   3          case TWO_MENU_F1_E3_D4:
 162   3          {
 163   4                        set_func_index(TWO_MENU_F1_E3_D4);
 164   4                        buf_eeprom[0] = old2_RF_RECE_REG[2] & 0x0f;//按键值保存到0字节
 165   4                        buf_eeprom[1] = Two_Menu_F1_E3[0];/*数值存入1 2 3 4字节*/
 166   4                        buf_eeprom[2] = Two_Menu_F1_E3[1];
 167   4                        buf_eeprom[3] = Two_Menu_F1_E3[2];
 168   4                        buf_eeprom[4] = Two_Menu_F1_E3[3];
 169   4                        buf_eeprom[5] = old2_RF_RECE_REG[0];// ID码存入 5 6 7 字节
 170   4                        buf_eeprom[6] = old2_RF_RECE_REG[1];
 171   4                        buf_eeprom[7] = old2_RF_RECE_REG[2] & 0xf0;
 172   4      
 173   4                        if (register_alarm_function(buf_eeprom))//数值自动加1
C51 COMPILER V9.00   DECODER                                                               09/12/2015 15:35:40 PAGE 4   

 174   4                        {
 175   5      #ifdef DEBUG
 176   5                          uart_printf("alarm is %02x %02x %02x .\r\n", (unsigned int)buf_eeprom[5], (unsigned int)buf_eep
             -rom[6], (unsigned int)buf_eeprom[7]); //测试按键键值
 177   5                          uart_printf("alarm is %02x %02x %02x %02x.\r\n", (unsigned int)Two_Menu_F1_E3[0], (unsigned int
             -)Two_Menu_F1_E3[1], (unsigned int)Two_Menu_F1_E3[2], (unsigned int)Two_Menu_F1_E3[3]);
 178   5                          uart_printf("alarm is rigister success \r\n");
 179   5      #endif          
 180   5                          delay10ms();
 181   5                          if (Two_Menu_F1_E3[3] == 9)
 182   5                          {
 183   6                            if (Two_Menu_F1_E3[2] == 9)
 184   6                            {
 185   7                              if (Two_Menu_F1_E3[1] == 9)
 186   7                              {
 187   8                                Two_Menu_F1_E3[0]++;
 188   8                                Two_Menu_F1_E3[1] = 0;
 189   8                                Two_Menu_F1_E3[2] = 0;
 190   8                                if (Two_Menu_F1_E3[0] == 21)
 191   8                                {
 192   9                                  Two_Menu_F1_E3[0] = 0;
 193   9                                  Two_Menu_F1_E3[3] = 1;
 194   9                                }
 195   8                                else
 196   8                                {
 197   9                                  Two_Menu_F1_E3[3] = 1;
 198   9                                }
 199   8                              }
 200   7                              else
 201   7                              {
 202   8                                Two_Menu_F1_E3[1]++;
 203   8                                Two_Menu_F1_E3[2] = 0;
 204   8                                Two_Menu_F1_E3[3] = 0;
 205   8                              }
 206   7                            }
 207   6                            else
 208   6                            {
 209   7                              Two_Menu_F1_E3[2]++;
 210   7                              Two_Menu_F1_E3[3] = 0;
 211   7                            }
 212   6                          }
 213   5                          else
 214   5                            Two_Menu_F1_E2[3]++;
 215   5                        }
 216   4                        break;
 217   4          }
 218   3          case TWO_MENU_F1_E4_D1:
 219   3          case TWO_MENU_F1_E4_D2:
 220   3          case TWO_MENU_F1_E4_D3:
 221   3          case TWO_MENU_F1_E4_D4:
 222   3          {
 223   4                        set_func_index(TWO_MENU_F1_E4_D4);
 224   4                        buf_eeprom[0] = old2_RF_RECE_REG[2] & 0x0f;//按键值保存到0字节
 225   4                        buf_eeprom[1] = Two_Menu_F1_E4[0];/*数值存入1 2 3 4字节*/
 226   4                        buf_eeprom[2] = Two_Menu_F1_E4[1];
 227   4                        buf_eeprom[3] = Two_Menu_F1_E4[2];
 228   4                        buf_eeprom[4] = Two_Menu_F1_E4[3];
 229   4                        buf_eeprom[5] = old2_RF_RECE_REG[0];// ID码存入 5 6 7 字节
 230   4                        buf_eeprom[6] = old2_RF_RECE_REG[1];
 231   4                        buf_eeprom[7] = old2_RF_RECE_REG[2] & 0xf0;
 232   4      
 233   4                        if (register_cancel_function(buf_eeprom))//数值自动加1
C51 COMPILER V9.00   DECODER                                                               09/12/2015 15:35:40 PAGE 5   

 234   4                        {
 235   5      #ifdef DEBUG
 236   5                          uart_printf("cancel is %02x %02x %02x .\r\n", (unsigned int)buf_eeprom[5], (unsigned int)buf_ee
             -prom[6], (unsigned int)buf_eeprom[7]); //测试按键键值
 237   5                          uart_printf("cancel is %02x %02x %02x %02x.\r\n", (unsigned int)Two_Menu_F1_E4[0], (unsigned in
             -t)Two_Menu_F1_E4[1], (unsigned int)Two_Menu_F1_E4[2], (unsigned int)Two_Menu_F1_E4[3]);
 238   5                          uart_printf("cancel is rigister success \r\n");
 239   5      #endif          
 240   5                          delay10ms();
 241   5                          if (Two_Menu_F1_E4[3] == 9)
 242   5                          {
 243   6                            if (Two_Menu_F1_E4[2] == 9)
 244   6                            {
 245   7                              if (Two_Menu_F1_E4[1] == 9)
 246   7                              {
 247   8                                Two_Menu_F1_E4[0]++;
 248   8                                Two_Menu_F1_E4[1] = 0;
 249   8                                Two_Menu_F1_E4[2] = 0;
 250   8                                if (Two_Menu_F1_E4[0] == 21)
 251   8                                {
 252   9                                  Two_Menu_F1_E4[0] = 0;
 253   9                                  Two_Menu_F1_E4[3] = 1;
 254   9                                }
 255   8                                else
 256   8                                {
 257   9                                  Two_Menu_F1_E4[3] = 1;
 258   9                                }
 259   8                              }
 260   7                              else
 261   7                              {
 262   8                                Two_Menu_F1_E4[1]++;
 263   8                                Two_Menu_F1_E4[2] = 0;
 264   8                                Two_Menu_F1_E4[3] = 0;
 265   8                              }
 266   7                            }
 267   6                            else
 268   6                            {
 269   7                              Two_Menu_F1_E4[2]++;
 270   7                              Two_Menu_F1_E4[3] = 0;
 271   7                            }
 272   6                          }
 273   5                          else
 274   5                            Two_Menu_F1_E4[3]++;
 275   5                        }
 276   4                        break;
 277   4          }
 278   3          default:break;
 279   3          }
 280   2        }
 281   1        clear_again_receive_rf_decoder_finished();//清除标志位
 282   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1307    ----
   CONSTANT SIZE    =    389    ----
   XDATA SIZE       =      8       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.00   DECODER                                                               09/12/2015 15:35:40 PAGE 6   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
