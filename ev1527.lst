C51 COMPILER V9.00   EV1527                                                                09/18/2015 17:31:09 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE EV1527
OBJECT MODULE PLACED IN ev1527.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Receiver\ev1527.c LARGE BROWSE INCDIR(.\Receiver) DEBUG OBJECTEXTEND PRINT(
                    -.\ev1527.lst) TABS(2) OBJECT(ev1527.obj)

line level    source

   1          #include "ev1527.h"
   2          #include "timer.h"
   3          
   4          /********************解码方式专用变量*******************************/
   5          unsigned char Save_RF_trans1 = 0;
   6          unsigned char Save_RF_trans0 = 0;
   7          unsigned char RF_trans0 = 0;
   8          unsigned char RF_trans1 = 0;
   9          unsigned char RF_BIT_COUNTER = 0; 
  10          unsigned char Timer0_interrupt_count = 0; //进入中断后400MS  无结果 恢复初始化操作
  11          unsigned char P_RF_INT = 0x00;
  12          unsigned char RF_RECE_REG[3] = { 0 };
  13          
  14          unsigned int measure_sync_count1 = 70; //波长保存变量
  15          unsigned int measure_sync_count2 = 120;//同上
  16          
  17          unsigned char receive_rf_decoder_finished = 0;      //一次解码完成标志位
  18          unsigned char again_receive_rf_decoder_finished = 0;//二次解码完成标志位
  19          unsigned char rx_table = 0;             //二次解码switch步骤变量
  20          unsigned char again_and_again_decoder_table = 0;     //二次编码成功标志位
  21          
  22          unsigned char old1_RF_RECE_REG[3] = { 0 };//用于校验
  23          unsigned char old2_RF_RECE_REG[3] = { 0 };//用于读取
  24          
  25          void exint0_init(void) //外部中断0 初始化
  26          {
  27   1        EA = 1;
  28   1        EX0 = 1;
  29   1        IT0 = 1;
  30   1      }
  31          
  32          void exint0() interrupt 0 //外部中断0中断服务函数
  33          {
  34   1        EX0 = 0;
  35   1        if (TR1 == 0)
  36   1        {
  37   2          //Init_Timer1();//sjz add for initialization timer0 before enable it
  38   2          TR1 = 1;
  39   2        }
  40   1      }
  41          
  42          void RF_ini_receive(void) //初始化所有解码所用到的变量
  43          {
  44   1        Save_RF_trans1 = 0; Save_RF_trans0 = 0;
  45   1        RF_trans0 = RF_trans1 = 0;
  46   1        RF_BIT_COUNTER = 0;
  47   1        P_RF_INT = 0x00;
  48   1        Timer0_interrupt_count = 0;//sjz
  49   1      }
  50          
  51          void RF_decode_main(void)
  52          {
  53   1        if (P3_RF_RXD == 1)
  54   1        {
C51 COMPILER V9.00   EV1527                                                                09/18/2015 17:31:09 PAGE 2   

  55   2          ++RF_trans1;
  56   2        }
  57   1        else
  58   1        {
  59   2          ++RF_trans0;
  60   2        }
  61   1        Timer0_interrupt_count++;
  62   1        if (Timer0_interrupt_count>4000)/*4000*100us=400ms,*/
  63   1        {
  64   2          TR1 = 0;/*shut down timer0 interrupt sjz*/
  65   2          EX0 = 1;
  66   2          RF_ini_receive();
  67   2          return;
  68   2      
  69   2        }
  70   1        switch (P_RF_INT)
  71   1        {
  72   2        case 0:  //等待长低电平同步
  73   2          if (RF_trans1 > 0)
  74   2          {
  75   3            //包含的高脉冲太多
  76   3            RF_ini_receive();
  77   3            EX0 = 1;
  78   3            TR1 = 0;
  79   3            return;
  80   3          }
  81   2          if (RF_trans0 > measure_sync_count1)
  82   2          {
  83   3            //长低同步完成
  84   3            P_RF_INT++;
  85   3            RF_trans0 = RF_trans1 = 0;
  86   3          }
  87   2          break;
  88   2        case 1: //等待真正的同步头
  89   2          if ((RF_trans0 + RF_trans1) >measure_sync_count2)/*sjz change from 150 to 120,to shorten the detection w
             -hen  the header of synchronization coming*/
  90   2          {
  91   3            //10mS没有同步高脉冲
  92   3            RF_ini_receive();
  93   3            EX0 = 1;
  94   3            TR1 = 0;
  95   3            return;
  96   3          }
  97   2          if (RF_trans1 > 1)
  98   2          {
  99   3            //高电平同步到了(最少检测到 2 次)
 100   3            if (EX0 == 1)
 101   3            {
 102   4              EX0 = 0;/*double check,since we have already detect the synchronization,if EXTINT0 is enable,need to d
             -isable  sjz*/
 103   4            }
 104   3            P_RF_INT++;
 105   3            RF_trans0 = 0;
 106   3            // RF_L_wait_H = 1;
 107   3          }
 108   2          break;
 109   2        case 2:
 110   2          if (RF_trans0 > 0)
 111   2          {
 112   3            Save_RF_trans1 = RF_trans1;
 113   3            RF_trans1 = 0;
 114   3            P_RF_INT++;
C51 COMPILER V9.00   EV1527                                                                09/18/2015 17:31:09 PAGE 3   

 115   3          }
 116   2          if (RF_trans1>((measure_sync_count2 + measure_sync_count1) >> 3)) /*if the high level is bigger than 25*
             -100us,Then should be setted as noise instead of useful signal sjz*/
 117   2          {
 118   3            RF_ini_receive();//KEY_HOLD = 0;
 119   3            EX0 = 1;
 120   3            TR1 = 0;
 121   3            return;
 122   3          }
 123   2          break;
 124   2        case 3:if (RF_trans1 > 0)
 125   2        {
 126   3               Save_RF_trans0 = RF_trans0;
 127   3               RF_trans0 = 0;
 128   3               P_RF_INT = 2;
 129   3               RF_RECE_REG[RF_BIT_COUNTER / 8] <<= 1;
 130   3               if (Save_RF_trans1 >Save_RF_trans0)
 131   3               {
 132   4                 RF_RECE_REG[(RF_BIT_COUNTER) / 8] |= 0x01;
 133   4               }
 134   3               ++RF_BIT_COUNTER;
 135   3               if (RF_BIT_COUNTER >23)
 136   3               {
 137   4                 TR1 = 0;
 138   4                 RF_ini_receive();
 139   4                 receive_rf_decoder_finished = 1;
 140   4                 EX0 = 1;
 141   4                 break;
 142   4               }
 143   3        }
 144   2             if (RF_trans0>((measure_sync_count2 + measure_sync_count1) >> 3))
 145   2             {
 146   3               RF_ini_receive();
 147   3               EX0 = 1;
 148   3               TR1 = 0;
 149   3               return;
 150   3             }
 151   2             break;
 152   2        default: //异常处理
 153   2        {
 154   3               RF_ini_receive();
 155   3               EX0 = 1;
 156   3               TR1 = 0;
 157   3        }break;
 158   2        }
 159   1      }
 160          
 161          void receive_rf_decoder(void)
 162          {
 163   1        //unsigned char i, j;
 164   1        //unsigned char temp_buff[8];
 165   1        //unsigned char temp_buff1[32];
 166   1      
 167   1        if (receive_rf_decoder_finished == 1)
 168   1        {
 169   2          EX0 = 0;
 170   2          switch (rx_table)
 171   2          {
 172   3          case 0: //第一次取得码
 173   3            old1_RF_RECE_REG[0] = RF_RECE_REG[0];
 174   3            old1_RF_RECE_REG[1] = RF_RECE_REG[1];
 175   3            old1_RF_RECE_REG[2] = RF_RECE_REG[2];
C51 COMPILER V9.00   EV1527                                                                09/18/2015 17:31:09 PAGE 4   

 176   3            rx_table = 1;
 177   3            break;
 178   3          case 1:
 179   3            if (old1_RF_RECE_REG[0] == RF_RECE_REG[0] && old1_RF_RECE_REG[1] == RF_RECE_REG[1] && old1_RF_RECE_REG[
             -2] == RF_RECE_REG[2])
 180   3            {
 181   4              if (old2_RF_RECE_REG[0] == RF_RECE_REG[0] && old2_RF_RECE_REG[1] == RF_RECE_REG[1] && old2_RF_RECE_REG
             -[2] == RF_RECE_REG[2])
 182   4              {
 183   5                if (again_and_again_decoder_table == 0) //如果该位不等于0  代表着上一次解码等于这次
 184   5                {
 185   6                  old2_RF_RECE_REG[0] = RF_RECE_REG[0];
 186   6                  old2_RF_RECE_REG[1] = RF_RECE_REG[1];
 187   6                  old2_RF_RECE_REG[2] = RF_RECE_REG[2];
 188   6                  again_receive_rf_decoder_finished = 1;
 189   6                }
 190   5      
 191   5              }
 192   4              else
 193   4              {
 194   5                old2_RF_RECE_REG[0] = RF_RECE_REG[0];
 195   5                old2_RF_RECE_REG[1] = RF_RECE_REG[1];
 196   5                old2_RF_RECE_REG[2] = RF_RECE_REG[2];
 197   5                again_receive_rf_decoder_finished = 1;
 198   5              }
 199   4              again_and_again_decoder_table = 1;
 200   4              clear_return_standby_time();
 201   4      
 202   4      
 203   4              //for (j = 0; j<4; j++)
 204   4              //{
 205   4              //  IRcvStr(0xa0, HOST_CODE_TABLE_START + j*PAGE_LENGTH, temp_buff1, PAGE_LENGTH);
 206   4              //  delay10ms();
 207   4              //  for (i = 0; i<PAGE_LENGTH; i++)
 208   4              //  {
 209   4              //    if (temp_buff1[i] == 0)
 210   4              //    {
 211   4              //      IRcvStr(0xa0, HOST_CODE_DATA_START + (j*PAGE_LENGTH + i) * 8, temp_buff, 8);
 212   4              //      delay10ms();
 213   4              //      if (temp_buff[4] == old2_RF_RECE_REG[0] && temp_buff[5] == old2_RF_RECE_REG[1] && ((temp_buff[6] 
             ->> 4) == (old2_RF_RECE_REG[2] >> 4)))
 214   4              //      {
 215   4              //        register_manager = 1;
 216   4              //        clear_return_standby_time();
 217   4              //        break;
 218   4              //        break;
 219   4              //      }
 220   4              //    }
 221   4              //  }
 222   4              //}
 223   4      
 224   4              RF_RECE_REG[0] = 0;
 225   4              RF_RECE_REG[1] = 0;
 226   4              RF_RECE_REG[2] = 0;
 227   4              old1_RF_RECE_REG[0] = 0;
 228   4              old1_RF_RECE_REG[1] = 0;
 229   4              old1_RF_RECE_REG[2] = 0;
 230   4              //sound_table = 1;
 231   4              //func_f1_1_4_table = 1;
 232   4              rx_table = 0;
 233   4            }
 234   3            else
C51 COMPILER V9.00   EV1527                                                                09/18/2015 17:31:09 PAGE 5   

 235   3            {
 236   4              old1_RF_RECE_REG[0] = RF_RECE_REG[0];
 237   4              old1_RF_RECE_REG[1] = RF_RECE_REG[1];
 238   4              old1_RF_RECE_REG[2] = RF_RECE_REG[2];
 239   4            }
 240   3            break;
 241   3          }
 242   2          EX0 = 1;
 243   2          receive_rf_decoder_finished = 0;
 244   2        }
 245   1      }
 246          
 247          unsigned char return_again_receive_rf_decoder_finished(void)
 248          {
 249   1        unsigned char temp;
 250   1        temp = again_receive_rf_decoder_finished;
 251   1        return temp;
 252   1      }
 253          
 254          void clear_again_receive_rf_decoder_finished(void)
 255          {
 256   1        again_receive_rf_decoder_finished = 0;
 257   1      }
 258          
 259          unsigned char return_again_and_again_decoder_table(void)
 260          {
 261   1        unsigned char temp;
 262   1        temp = again_and_again_decoder_table;
 263   1        return temp;
 264   1      }
 265          
 266          void clear_again_and_again_decoder_table(void)
 267          {
 268   1        again_and_again_decoder_table = 0;
 269   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    670    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     24    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
